/*! ally.js - v1.4.1 - https://allyjs.io/ - MIT License */
// This customized library was built from https://github.com/prantlf/ally.js/tree/1.4.1-readonly.

// [OT] Modifications done:
//
// * Replace UMD with csui AMD at the top and bottom of the file.
// * Rename the local "define" fuunction to "localDefine" to prevent r.js from
//   namespacing it to "csui.define".
// * Include only the "get", "is" and "query" APIs.
// * Remove the noConflict method.

// [OT] Declare a csui module
csui.define('csui/lib/ally',[], function () {

    // [OT] Rename the local "define" function to "localDefine" to prevent
    //      r.js from namespacing it to "csui.define".
    var localDefine, module, exports;
    var ally_js = function() {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw a.code = "MODULE_NOT_FOUND", a;
                    }
                    var p = n[i] = {
                        exports: {}
                    };
                    e[i][0].call(p.exports, function(r) {
                        var n = e[i][1][r];
                        return o(n || r);
                    }, p, p.exports, r, e, n, t);
                }
                return n[i].exports;
            }
            for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
            return o;
        }
        return r;
    }()({
        1: [ function(require, module, exports) {
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _interopDefault(ex) {
                return ex && (typeof ex === "undefined" ? "undefined" : _typeof(ex)) === "object" && "default" in ex ? ex["default"] : ex;
            }
            var _platform = _interopDefault(require("platform"));
            var cssEscape = _interopDefault(require("css.escape"));
            var getDocument = function getDocument(node) {
                if (!node) {
                    return document;
                }
                if (node.nodeType === Node.DOCUMENT_NODE) {
                    return node;
                }
                return node.ownerDocument || document;
            };
            var activeElement = function activeElement() {
                var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context;
                var _document = getDocument(context);
                var activeElement = void 0;
                try {
                    activeElement = _document.activeElement;
                } catch (e) {}
                if (!activeElement || !activeElement.nodeType) {
                    activeElement = _document.body || _document.documentElement;
                }
                return activeElement;
            };
            var nodeArray = function nodeArray(input) {
                if (!input) {
                    return [];
                }
                if (Array.isArray(input)) {
                    return input;
                }
                if (input.nodeType !== undefined) {
                    return [ input ];
                }
                if (typeof input === "string") {
                    input = document.querySelectorAll(input);
                }
                if (input.length !== undefined) {
                    return [].slice.call(input, 0);
                }
                throw new TypeError("unexpected input " + String(input));
            };
            var contextToElement = function contextToElement(_ref2) {
                var context = _ref2.context, _ref2$label = _ref2.label, label = _ref2$label === undefined ? "context-to-element" : _ref2$label, resolveDocument = _ref2.resolveDocument, defaultToDocument = _ref2.defaultToDocument;
                var element = nodeArray(context)[0];
                if (resolveDocument && element && element.nodeType === Node.DOCUMENT_NODE) {
                    element = element.documentElement;
                }
                if (!element && defaultToDocument) {
                    return document.documentElement;
                }
                if (!element) {
                    throw new TypeError(label + " requires valid options.context");
                }
                if (element.nodeType !== Node.ELEMENT_NODE && element.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                    throw new TypeError(label + " requires options.context to be an Element");
                }
                return element;
            };
            var getShadowHost = function getShadowHost() {
                var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref3.context;
                var element = contextToElement({
                    label: "get/shadow-host",
                    context: context
                });
                var container = null;
                while (element) {
                    container = element;
                    element = element.parentNode;
                }
                if (container.nodeType === container.DOCUMENT_FRAGMENT_NODE && container.host) {
                    return container.host;
                }
                return null;
            };
            var shadowed = function shadowed(context) {
                var element = contextToElement({
                    label: "is/shadowed",
                    resolveDocument: true,
                    context: context
                });
                return Boolean(getShadowHost({
                    context: element
                }));
            };
            var getShadowHostParents = function getShadowHostParents() {
                var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref4.context;
                var list = [];
                var element = contextToElement({
                    label: "get/shadow-host-parents",
                    context: context
                });
                while (element) {
                    element = getShadowHost({
                        context: element
                    });
                    if (!element) {
                        break;
                    }
                    list.push(element);
                }
                return list;
            };
            function walkToShadowedElement() {
                var list = [ document.activeElement ];
                while (list[0] && list[0].shadowRoot) {
                    list.unshift(list[0].shadowRoot.activeElement);
                }
                return list;
            }
            function walkFromShadowedElement() {
                var hosts = getShadowHostParents({
                    context: document.activeElement
                });
                return [ document.activeElement ].concat(hosts);
            }
            var activeElements = function activeElements() {
                if (document.activeElement === null) {
                    document.body.focus();
                }
                if (shadowed(document.activeElement)) {
                    return walkFromShadowedElement();
                }
                return walkToShadowedElement();
            };
            var getParents = function getParents() {
                var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref5.context;
                var list = [];
                var element = contextToElement({
                    label: "get/parents",
                    context: context
                });
                while (element) {
                    list.push(element);
                    element = element.parentNode;
                    if (element && element.nodeType !== Node.ELEMENT_NODE) {
                        element = null;
                    }
                }
                return list;
            };
            var names = [ "matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector" ];
            var name = null;
            function findMethodName(element) {
                names.some(function(_name) {
                    if (!element[_name]) {
                        return false;
                    }
                    name = _name;
                    return true;
                });
            }
            function elementMatches(element, selector) {
                if (!name) {
                    findMethodName(element);
                }
                return element[name](selector);
            }
            var platform = JSON.parse(JSON.stringify(_platform));
            var os = platform.os.family || "";
            var ANDROID = os === "Android";
            var WINDOWS = os.slice(0, 7) === "Windows";
            var OSX = os === "OS X";
            var IOS = os === "iOS";
            var BLINK = platform.layout === "Blink";
            var GECKO = platform.layout === "Gecko";
            var TRIDENT = platform.layout === "Trident";
            var EDGE = platform.layout === "EdgeHTML";
            var WEBKIT = platform.layout === "WebKit";
            var version = parseFloat(platform.version);
            var majorVersion = Math.floor(version);
            platform.majorVersion = majorVersion;
            platform.is = {
                ANDROID: ANDROID,
                WINDOWS: WINDOWS,
                OSX: OSX,
                IOS: IOS,
                BLINK: BLINK,
                GECKO: GECKO,
                TRIDENT: TRIDENT,
                EDGE: EDGE,
                WEBKIT: WEBKIT,
                IE9: TRIDENT && majorVersion === 9,
                IE10: TRIDENT && majorVersion === 10,
                IE11: TRIDENT && majorVersion === 11
            };
            function before() {
                var data = {
                    activeElement: document.activeElement,
                    windowScrollTop: window.scrollTop,
                    windowScrollLeft: window.scrollLeft,
                    bodyScrollTop: document.body.scrollTop,
                    bodyScrollLeft: document.body.scrollLeft
                };
                var iframe = document.createElement("iframe");
                iframe.setAttribute("style", "position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;");
                iframe.setAttribute("aria-live", "off");
                iframe.setAttribute("aria-busy", "true");
                iframe.setAttribute("aria-hidden", "true");
                document.body.appendChild(iframe);
                var _window = iframe.contentWindow;
                var _document = _window.document;
                _document.open();
                _document.close();
                var wrapper = _document.createElement("div");
                _document.body.appendChild(wrapper);
                data.iframe = iframe;
                data.wrapper = wrapper;
                data.window = _window;
                data.document = _document;
                return data;
            }
            function test(data, options) {
                data.wrapper.innerHTML = "";
                var element = typeof options.element === "string" ? data.document.createElement(options.element) : options.element(data.wrapper, data.document);
                var focus = options.mutate && options.mutate(element, data.wrapper, data.document);
                if (!focus && focus !== false) {
                    focus = element;
                }
                !element.parentNode && data.wrapper.appendChild(element);
                focus && focus.focus && focus.focus();
                return options.validate ? options.validate(element, focus, data.document) : data.document.activeElement === focus;
            }
            function after(data) {
                if (data.activeElement === document.body) {
                    document.activeElement && document.activeElement.blur && document.activeElement.blur();
                    if (platform.is.IE10) {
                        document.body.focus();
                    }
                } else {
                    data.activeElement && data.activeElement.focus && data.activeElement.focus();
                }
                document.body.removeChild(data.iframe);
                window.scrollTop = data.windowScrollTop;
                window.scrollLeft = data.windowScrollLeft;
                document.body.scrollTop = data.bodyScrollTop;
                document.body.scrollLeft = data.bodyScrollLeft;
            }
            var detectFocus = function detectFocus(tests) {
                var data = before();
                var results = {};
                Object.keys(tests).map(function(key) {
                    results[key] = test(data, tests[key]);
                });
                after(data);
                return results;
            };
            var version$1 = "1.4.1";
            function readLocalStorage(key) {
                var data = void 0;
                try {
                    data = window.localStorage && window.localStorage.getItem(key);
                    data = data ? JSON.parse(data) : {};
                } catch (e) {
                    data = {};
                }
                return data;
            }
            function writeLocalStorage(key, value) {
                if (!document.hasFocus()) {
                    try {
                        window.localStorage && window.localStorage.removeItem(key);
                    } catch (e) {}
                    return;
                }
                try {
                    window.localStorage && window.localStorage.setItem(key, JSON.stringify(value));
                } catch (e) {}
            }
            var userAgent = typeof window !== "undefined" && window.navigator.userAgent || "";
            var cacheKey = "ally-supports-cache";
            var cache = readLocalStorage(cacheKey);
            if (cache.userAgent !== userAgent || cache.version !== version$1) {
                cache = {};
            }
            cache.userAgent = userAgent;
            cache.version = version$1;
            var cache$1 = {
                get: function get() {
                    return cache;
                },
                set: function set(values) {
                    Object.keys(values).forEach(function(key) {
                        cache[key] = values[key];
                    });
                    cache.time = new Date().toISOString();
                    writeLocalStorage(cacheKey, cache);
                }
            };
            var cssShadowPiercingDeepCombinator = function cssShadowPiercingDeepCombinator() {
                var combinator = void 0;
                try {
                    document.querySelector("html >>> :first-child");
                    combinator = ">>>";
                } catch (noArrowArrowArrow) {
                    try {
                        document.querySelector("html /deep/ :first-child");
                        combinator = "/deep/";
                    } catch (noDeep) {
                        combinator = "";
                    }
                }
                return combinator;
            };
            var gif = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
            var focusAreaImgTabindex = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" src="' + gif + '">';
                    return element.querySelector("area");
                }
            };
            var focusAreaTabindex = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area href="#void" tabindex="-1" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" alt="" src="' + gif + '">';
                    return false;
                },
                validate: function validate(element, focusTarget, _document) {
                    if (platform.is.GECKO) {
                        return true;
                    }
                    var focus = element.querySelector("area");
                    focus.focus();
                    return _document.activeElement === focus;
                }
            };
            var focusAreaWithoutHref = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = '<map name="image-map-area-href-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-area-href-test" alt="" src="' + gif + '">';
                    return element.querySelector("area");
                },
                validate: function validate(element, focusTarget, _document) {
                    if (platform.is.GECKO) {
                        return true;
                    }
                    return _document.activeElement === focusTarget;
                }
            };
            var focusAudioWithoutControls = {
                name: "can-focus-audio-without-controls",
                element: "audio",
                mutate: function mutate(element) {
                    try {
                        element.setAttribute("src", gif);
                    } catch (e) {}
                }
            };
            var invalidGif = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ";
            var focusBrokenImageMap = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = '<map name="broken-image-map-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#broken-image-map-test" alt="" src="' + invalidGif + '">';
                    return element.querySelector("area");
                }
            };
            var focusChildrenOfFocusableFlexbox = {
                element: "div",
                mutate: function mutate(element) {
                    element.setAttribute("tabindex", "-1");
                    element.setAttribute("style", "display: -webkit-flex; display: -ms-flexbox; display: flex;");
                    element.innerHTML = '<span style="display: block;">hello</span>';
                    return element.querySelector("span");
                }
            };
            var focusFieldsetDisabled = {
                element: "fieldset",
                mutate: function mutate(element) {
                    element.setAttribute("tabindex", 0);
                    element.setAttribute("disabled", "disabled");
                }
            };
            var focusFieldset = {
                element: "fieldset",
                mutate: function mutate(element) {
                    element.innerHTML = "<legend>legend</legend><p>content</p>";
                }
            };
            var focusFlexboxContainer = {
                element: "span",
                mutate: function mutate(element) {
                    element.setAttribute("style", "display: -webkit-flex; display: -ms-flexbox; display: flex;");
                    element.innerHTML = '<span style="display: block;">hello</span>';
                }
            };
            var focusFormDisabled = {
                element: "form",
                mutate: function mutate(element) {
                    element.setAttribute("tabindex", 0);
                    element.setAttribute("disabled", "disabled");
                }
            };
            var focusImgIsmap = {
                element: "a",
                mutate: function mutate(element) {
                    element.href = "#void";
                    element.innerHTML = '<img ismap src="' + gif + '" alt="">';
                    return element.querySelector("img");
                }
            };
            var focusImgUsemapTabindex = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = '<map name="image-map-tabindex-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" ' + 'src="' + gif + '">';
                    return element.querySelector("img");
                }
            };
            var focusInHiddenIframe = {
                element: function element(wrapper, _document) {
                    var iframe = _document.createElement("iframe");
                    wrapper.appendChild(iframe);
                    var iframeDocument = iframe.contentWindow.document;
                    iframeDocument.open();
                    iframeDocument.close();
                    return iframe;
                },
                mutate: function mutate(iframe) {
                    iframe.style.visibility = "hidden";
                    var iframeDocument = iframe.contentWindow.document;
                    var input = iframeDocument.createElement("input");
                    iframeDocument.body.appendChild(input);
                    return input;
                },
                validate: function validate(iframe) {
                    var iframeDocument = iframe.contentWindow.document;
                    var focus = iframeDocument.querySelector("input");
                    return iframeDocument.activeElement === focus;
                }
            };
            var result = !platform.is.WEBKIT;
            var focusInZeroDimensionObject = function focusInZeroDimensionObject() {
                return result;
            };
            var focusInvalidTabindex = {
                element: "div",
                mutate: function mutate(element) {
                    element.setAttribute("tabindex", "invalid-value");
                }
            };
            var focusLabelTabindex = {
                element: "label",
                mutate: function mutate(element) {
                    element.setAttribute("tabindex", "-1");
                },
                validate: function validate(element, focusTarget, _document) {
                    var variableToPreventDeadCodeElimination = element.offsetHeight;
                    element.focus();
                    return _document.activeElement === element;
                }
            };
            var svg = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb" + "G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ" + "zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==";
            var focusObjectSvgHidden = {
                element: "object",
                mutate: function mutate(element) {
                    element.setAttribute("type", "image/svg+xml");
                    element.setAttribute("data", svg);
                    element.setAttribute("width", "200");
                    element.setAttribute("height", "50");
                    element.style.visibility = "hidden";
                }
            };
            var focusObjectSvg = {
                name: "can-focus-object-svg",
                element: "object",
                mutate: function mutate(element) {
                    element.setAttribute("type", "image/svg+xml");
                    element.setAttribute("data", svg);
                    element.setAttribute("width", "200");
                    element.setAttribute("height", "50");
                },
                validate: function validate(element, focusTarget, _document) {
                    if (platform.is.GECKO) {
                        return true;
                    }
                    return _document.activeElement === element;
                }
            };
            var result$1 = !platform.is.IE9;
            var focusObjectSwf = function focusObjectSwf() {
                return result$1;
            };
            var focusRedirectImgUsemap = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = '<map name="focus-redirect-img-usemap"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#focus-redirect-img-usemap" alt="" ' + 'src="' + gif + '">';
                    return element.querySelector("img");
                },
                validate: function validate(element, focusTarget, _document) {
                    var target = element.querySelector("area");
                    return _document.activeElement === target;
                }
            };
            var focusRedirectLegend = {
                element: "fieldset",
                mutate: function mutate(element) {
                    element.innerHTML = '<legend>legend</legend><input tabindex="-1"><input tabindex="0">';
                    return false;
                },
                validate: function validate(element, focusTarget, _document) {
                    var focusable = element.querySelector('input[tabindex="-1"]');
                    var tabbable = element.querySelector('input[tabindex="0"]');
                    element.focus();
                    element.querySelector("legend").focus();
                    return _document.activeElement === focusable && "focusable" || _document.activeElement === tabbable && "tabbable" || "";
                }
            };
            var focusScrollBody = {
                element: "div",
                mutate: function mutate(element) {
                    element.setAttribute("style", "width: 100px; height: 50px; overflow: auto;");
                    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
                    return element.querySelector("div");
                }
            };
            var focusScrollContainerWithoutOverflow = {
                element: "div",
                mutate: function mutate(element) {
                    element.setAttribute("style", "width: 100px; height: 50px;");
                    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
                }
            };
            var focusScrollContainer = {
                element: "div",
                mutate: function mutate(element) {
                    element.setAttribute("style", "width: 100px; height: 50px; overflow: auto;");
                    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
                }
            };
            var focusSummary = {
                element: "details",
                mutate: function mutate(element) {
                    element.innerHTML = "<summary>foo</summary><p>content</p>";
                    return element.firstElementChild;
                }
            };
            function makeFocusableForeignObject() {
                var fragment = document.createElement("div");
                fragment.innerHTML = '<svg><foreignObject width="30" height="30">\n      <input type="text"/>\n  </foreignObject></svg>';
                return fragment.firstChild.firstChild;
            }
            var focusSvgForeignObjectHack = function focusSvgForeignObjectHack(element) {
                var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === "svg";
                if (!isSvgElement) {
                    return false;
                }
                var foreignObject = makeFocusableForeignObject();
                element.appendChild(foreignObject);
                var input = foreignObject.querySelector("input");
                input.focus();
                input.disabled = true;
                element.removeChild(foreignObject);
                return true;
            };
            function generate(element) {
                return '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + element + "</svg>";
            }
            function focus(element) {
                if (element.focus) {
                    return;
                }
                try {
                    HTMLElement.prototype.focus.call(element);
                } catch (e) {
                    focusSvgForeignObjectHack(element);
                }
            }
            function validate(element, focusTarget, _document) {
                focus(focusTarget);
                return _document.activeElement === focusTarget;
            }
            var focusSvgFocusableAttribute = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = generate('<text focusable="true">a</text>');
                    return element.querySelector("text");
                },
                validate: validate
            };
            var focusSvgTabindexAttribute = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = generate('<text tabindex="0">a</text>');
                    return element.querySelector("text");
                },
                validate: validate
            };
            var focusSvgNegativeTabindexAttribute = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = generate('<text tabindex="-1">a</text>');
                    return element.querySelector("text");
                },
                validate: validate
            };
            var focusSvgUseTabindex = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = generate([ '<g id="ally-test-target"><a xlink:href="#void"><text>link</text></a></g>', '<use xlink:href="#ally-test-target" x="0" y="0" tabindex="-1" />' ].join(""));
                    return element.querySelector("use");
                },
                validate: validate
            };
            var focusSvgForeignobjectTabindex = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = generate('<foreignObject tabindex="-1"><input type="text" /></foreignObject>');
                    return element.querySelector("foreignObject") || element.getElementsByTagName("foreignObject")[0];
                },
                validate: validate
            };
            var result$2 = Boolean(platform.is.GECKO && typeof SVGElement !== "undefined" && SVGElement.prototype.focus);
            var focusSvgInIframe = function focusSvgInIframe() {
                return result$2;
            };
            var focusSvg = {
                element: "div",
                mutate: function mutate(element) {
                    element.innerHTML = generate("");
                    return element.firstChild;
                },
                validate: validate
            };
            var focusTabindexTrailingCharacters = {
                element: "div",
                mutate: function mutate(element) {
                    element.setAttribute("tabindex", "3x");
                }
            };
            var focusTable = {
                element: "table",
                mutate: function mutate(element, wrapper, _document) {
                    var fragment = _document.createDocumentFragment();
                    fragment.innerHTML = "<tr><td>cell</td></tr>";
                    element.appendChild(fragment);
                }
            };
            var focusVideoWithoutControls = {
                element: "video",
                mutate: function mutate(element) {
                    try {
                        element.setAttribute("src", gif);
                    } catch (e) {}
                }
            };
            var result$3 = platform.is.GECKO || platform.is.TRIDENT || platform.is.EDGE;
            var tabsequenceAreaAtImgPosition = function tabsequenceAreaAtImgPosition() {
                return result$3;
            };
            var testCallbacks = {
                cssShadowPiercingDeepCombinator: cssShadowPiercingDeepCombinator,
                focusInZeroDimensionObject: focusInZeroDimensionObject,
                focusObjectSwf: focusObjectSwf,
                focusSvgInIframe: focusSvgInIframe,
                tabsequenceAreaAtImgPosition: tabsequenceAreaAtImgPosition
            };
            var testDescriptions = {
                focusAreaImgTabindex: focusAreaImgTabindex,
                focusAreaTabindex: focusAreaTabindex,
                focusAreaWithoutHref: focusAreaWithoutHref,
                focusAudioWithoutControls: focusAudioWithoutControls,
                focusBrokenImageMap: focusBrokenImageMap,
                focusChildrenOfFocusableFlexbox: focusChildrenOfFocusableFlexbox,
                focusFieldsetDisabled: focusFieldsetDisabled,
                focusFieldset: focusFieldset,
                focusFlexboxContainer: focusFlexboxContainer,
                focusFormDisabled: focusFormDisabled,
                focusImgIsmap: focusImgIsmap,
                focusImgUsemapTabindex: focusImgUsemapTabindex,
                focusInHiddenIframe: focusInHiddenIframe,
                focusInvalidTabindex: focusInvalidTabindex,
                focusLabelTabindex: focusLabelTabindex,
                focusObjectSvg: focusObjectSvg,
                focusObjectSvgHidden: focusObjectSvgHidden,
                focusRedirectImgUsemap: focusRedirectImgUsemap,
                focusRedirectLegend: focusRedirectLegend,
                focusScrollBody: focusScrollBody,
                focusScrollContainerWithoutOverflow: focusScrollContainerWithoutOverflow,
                focusScrollContainer: focusScrollContainer,
                focusSummary: focusSummary,
                focusSvgFocusableAttribute: focusSvgFocusableAttribute,
                focusSvgTabindexAttribute: focusSvgTabindexAttribute,
                focusSvgNegativeTabindexAttribute: focusSvgNegativeTabindexAttribute,
                focusSvgUseTabindex: focusSvgUseTabindex,
                focusSvgForeignobjectTabindex: focusSvgForeignobjectTabindex,
                focusSvg: focusSvg,
                focusTabindexTrailingCharacters: focusTabindexTrailingCharacters,
                focusTable: focusTable,
                focusVideoWithoutControls: focusVideoWithoutControls
            };
            function executeTests() {
                var results = detectFocus(testDescriptions);
                Object.keys(testCallbacks).forEach(function(key) {
                    results[key] = testCallbacks[key]();
                });
                return results;
            }
            var supportsCache = null;
            var _supports = function _supports() {
                if (supportsCache) {
                    return supportsCache;
                }
                supportsCache = cache$1.get();
                if (!supportsCache.time) {
                    cache$1.set(executeTests());
                    supportsCache = cache$1.get();
                }
                return supportsCache;
            };
            var supports$3 = void 0;
            var validIntegerPatternNoTrailing = /^\s*(-|\+)?[0-9]+\s*$/;
            var validIntegerPatternWithTrailing = /^\s*(-|\+)?[0-9]+.*$/;
            var validTabindex = function validTabindex(context) {
                if (!supports$3) {
                    supports$3 = _supports();
                }
                var validIntegerPattern = supports$3.focusTabindexTrailingCharacters ? validIntegerPatternWithTrailing : validIntegerPatternNoTrailing;
                var element = contextToElement({
                    label: "is/valid-tabindex",
                    resolveDocument: true,
                    context: context
                });
                var hasTabindex = element.hasAttribute("tabindex");
                var hasTabIndex = element.hasAttribute("tabIndex");
                if (!hasTabindex && !hasTabIndex) {
                    return false;
                }
                var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === "svg";
                if (isSvgElement && !supports$3.focusSvgTabindexAttribute) {
                    return false;
                }
                if (supports$3.focusInvalidTabindex) {
                    return true;
                }
                var tabindex = element.getAttribute(hasTabindex ? "tabindex" : "tabIndex");
                if (tabindex === "-32768") {
                    return false;
                }
                return Boolean(tabindex && validIntegerPattern.test(tabindex));
            };
            var tabindexValue = function tabindexValue(element) {
                if (!validTabindex(element)) {
                    return null;
                }
                var hasTabindex = element.hasAttribute("tabindex");
                var attributeName = hasTabindex ? "tabindex" : "tabIndex";
                var tabindex = parseInt(element.getAttribute(attributeName), 10);
                return isNaN(tabindex) ? -1 : tabindex;
            };
            function isUserModifyWritable(style) {
                var userModify = style.webkitUserModify || "";
                return Boolean(userModify && userModify.indexOf("write") !== -1);
            }
            function hasCssOverflowScroll(style) {
                return [ style.getPropertyValue("overflow"), style.getPropertyValue("overflow-x"), style.getPropertyValue("overflow-y") ].some(function(overflow) {
                    return overflow === "auto" || overflow === "scroll";
                });
            }
            function hasCssDisplayFlex(style) {
                return style.display.indexOf("flex") > -1;
            }
            function isScrollableContainer(element, nodeName, parentNodeName, parentStyle) {
                if (nodeName !== "div" && nodeName !== "span") {
                    return false;
                }
                if (parentNodeName && parentNodeName !== "div" && parentNodeName !== "span" && !hasCssOverflowScroll(parentStyle)) {
                    return false;
                }
                return element.offsetHeight < element.scrollHeight || element.offsetWidth < element.scrollWidth;
            }
            var supports$2 = void 0;
            function isFocusRelevantRules() {
                var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref6.context, _ref6$except = _ref6.except, except = _ref6$except === undefined ? {
                    flexbox: false,
                    scrollable: false,
                    shadow: false
                } : _ref6$except;
                if (!supports$2) {
                    supports$2 = _supports();
                }
                var element = contextToElement({
                    label: "is/focus-relevant",
                    resolveDocument: true,
                    context: context
                });
                if (!except.shadow && element.shadowRoot) {
                    return true;
                }
                var nodeName = element.nodeName.toLowerCase();
                if (nodeName === "input" && element.type === "hidden") {
                    return false;
                }
                if (nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea") {
                    return true;
                }
                if (nodeName === "legend" && supports$2.focusRedirectLegend) {
                    return true;
                }
                if (nodeName === "label") {
                    return true;
                }
                if (nodeName === "area") {
                    return true;
                }
                if (nodeName === "a" && element.hasAttribute("href")) {
                    return true;
                }
                if (nodeName === "object" && element.hasAttribute("usemap")) {
                    return false;
                }
                if (nodeName === "object") {
                    var svgType = element.getAttribute("type");
                    if (!supports$2.focusObjectSvg && svgType === "image/svg+xml") {
                        return false;
                    } else if (!supports$2.focusObjectSwf && svgType === "application/x-shockwave-flash") {
                        return false;
                    }
                }
                if (nodeName === "iframe" || nodeName === "object") {
                    return true;
                }
                if (nodeName === "embed" || nodeName === "keygen") {
                    return true;
                }
                if (element.hasAttribute("contenteditable")) {
                    return true;
                }
                if (nodeName === "audio" && (supports$2.focusAudioWithoutControls || element.hasAttribute("controls"))) {
                    return true;
                }
                if (nodeName === "video" && (supports$2.focusVideoWithoutControls || element.hasAttribute("controls"))) {
                    return true;
                }
                if (supports$2.focusSummary && nodeName === "summary") {
                    return true;
                }
                var validTabindex$$1 = validTabindex(element);
                if (nodeName === "img" && element.hasAttribute("usemap")) {
                    return validTabindex$$1 && supports$2.focusImgUsemapTabindex || supports$2.focusRedirectImgUsemap;
                }
                if (supports$2.focusTable && (nodeName === "table" || nodeName === "td")) {
                    return true;
                }
                if (supports$2.focusFieldset && nodeName === "fieldset") {
                    return true;
                }
                var isSvgElement = nodeName === "svg";
                var isSvgContent = element.ownerSVGElement;
                var focusableAttribute = element.getAttribute("focusable");
                var tabindex = tabindexValue(element);
                if (nodeName === "use" && tabindex !== null && !supports$2.focusSvgUseTabindex) {
                    return false;
                }
                if (nodeName === "foreignobject") {
                    return tabindex !== null && supports$2.focusSvgForeignobjectTabindex;
                }
                if (elementMatches(element, "svg a") && element.hasAttribute("xlink:href")) {
                    return true;
                }
                if ((isSvgElement || isSvgContent) && element.focus && !supports$2.focusSvgNegativeTabindexAttribute && tabindex < 0) {
                    return false;
                }
                if (isSvgElement) {
                    return validTabindex$$1 || supports$2.focusSvg || supports$2.focusSvgInIframe || Boolean(supports$2.focusSvgFocusableAttribute && focusableAttribute && focusableAttribute === "true");
                }
                if (isSvgContent) {
                    if (supports$2.focusSvgTabindexAttribute && validTabindex$$1) {
                        return true;
                    }
                    if (supports$2.focusSvgFocusableAttribute) {
                        return focusableAttribute === "true";
                    }
                }
                if (validTabindex$$1) {
                    return true;
                }
                var style = window.getComputedStyle(element, null);
                if (isUserModifyWritable(style)) {
                    return true;
                }
                if (supports$2.focusImgIsmap && nodeName === "img" && element.hasAttribute("ismap")) {
                    var hasLinkParent = getParents({
                        context: element
                    }).some(function(parent) {
                        return parent.nodeName.toLowerCase() === "a" && parent.hasAttribute("href");
                    });
                    if (hasLinkParent) {
                        return true;
                    }
                }
                if (!except.scrollable && supports$2.focusScrollContainer) {
                    if (supports$2.focusScrollContainerWithoutOverflow) {
                        if (isScrollableContainer(element, nodeName)) {
                            return true;
                        }
                    } else if (hasCssOverflowScroll(style)) {
                        return true;
                    }
                }
                if (!except.flexbox && supports$2.focusFlexboxContainer && hasCssDisplayFlex(style)) {
                    return true;
                }
                var parent = element.parentElement;
                if (!except.scrollable && parent) {
                    var parentNodeName = parent.nodeName.toLowerCase();
                    var parentStyle = window.getComputedStyle(parent, null);
                    if (supports$2.focusScrollBody && isScrollableContainer(parent, nodeName, parentNodeName, parentStyle)) {
                        return true;
                    }
                    if (supports$2.focusChildrenOfFocusableFlexbox) {
                        if (hasCssDisplayFlex(parentStyle)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            isFocusRelevantRules.except = function() {
                var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var isFocusRelevant = function isFocusRelevant(context) {
                    return isFocusRelevantRules({
                        context: context,
                        except: except
                    });
                };
                isFocusRelevant.rules = isFocusRelevantRules;
                return isFocusRelevant;
            };
            var isFocusRelevant = isFocusRelevantRules.except({});
            function findIndex(array, callback) {
                if (array.findIndex) {
                    return array.findIndex(callback);
                }
                var length = array.length;
                if (length === 0) {
                    return -1;
                }
                for (var i = 0; i < length; i++) {
                    if (callback(array[i], i, array)) {
                        return i;
                    }
                }
                return -1;
            }
            var getContentDocument = function getContentDocument(node) {
                try {
                    return node.contentDocument || node.contentWindow && node.contentWindow.document || node.getSVGDocument && node.getSVGDocument() || null;
                } catch (e) {
                    return null;
                }
            };
            var getWindow = function getWindow(node) {
                var _document = getDocument(node);
                return _document.defaultView || window;
            };
            var shadowPrefix = void 0;
            var selectInShadows = function selectInShadows(selector) {
                if (typeof shadowPrefix !== "string") {
                    var operator = cssShadowPiercingDeepCombinator();
                    if (operator) {
                        shadowPrefix = ", html " + operator + " ";
                    }
                }
                if (!shadowPrefix) {
                    return selector;
                }
                return selector + shadowPrefix + selector.replace(/\s*,\s*/g, ",").split(",").join(shadowPrefix);
            };
            var selector = void 0;
            function findDocumentHostElement(_window) {
                if (!selector) {
                    selector = selectInShadows("object, iframe");
                }
                if (_window._frameElement !== undefined) {
                    return _window._frameElement;
                }
                _window._frameElement = null;
                var potentialHosts = _window.parent.document.querySelectorAll(selector);
                [].some.call(potentialHosts, function(element) {
                    var _document = getContentDocument(element);
                    if (_document !== _window.document) {
                        return false;
                    }
                    _window._frameElement = element;
                    return true;
                });
                return _window._frameElement;
            }
            function getFrameElement(element) {
                var _window = getWindow(element);
                if (!_window.parent || _window.parent === _window) {
                    return null;
                }
                try {
                    return _window.frameElement || findDocumentHostElement(_window);
                } catch (e) {
                    return null;
                }
            }
            var notRenderedElementsPattern = /^(area)$/;
            function computedStyle(element, property) {
                return window.getComputedStyle(element, null).getPropertyValue(property);
            }
            function notDisplayed(_path) {
                return _path.some(function(element) {
                    return computedStyle(element, "display") === "none";
                });
            }
            function notVisible(_path) {
                var hidden = findIndex(_path, function(element) {
                    var visibility = computedStyle(element, "visibility");
                    return visibility === "hidden" || visibility === "collapse";
                });
                if (hidden === -1) {
                    return false;
                }
                var visible = findIndex(_path, function(element) {
                    return computedStyle(element, "visibility") === "visible";
                });
                if (visible === -1) {
                    return true;
                }
                if (hidden < visible) {
                    return true;
                }
                return false;
            }
            function collapsedParent(_path) {
                var offset = 1;
                if (_path[0].nodeName.toLowerCase() === "summary") {
                    offset = 2;
                }
                return _path.slice(offset).some(function(element) {
                    return element.nodeName.toLowerCase() === "details" && element.open === false;
                });
            }
            function isVisibleRules() {
                var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref7.context, _ref7$except = _ref7.except, except = _ref7$except === undefined ? {
                    notRendered: false,
                    cssDisplay: false,
                    cssVisibility: false,
                    detailsElement: false,
                    browsingContext: false
                } : _ref7$except;
                var element = contextToElement({
                    label: "is/visible",
                    resolveDocument: true,
                    context: context
                });
                var nodeName = element.nodeName.toLowerCase();
                if (!except.notRendered && notRenderedElementsPattern.test(nodeName)) {
                    return true;
                }
                var _path = getParents({
                    context: element
                });
                var isAudioWithoutControls = nodeName === "audio" && !element.hasAttribute("controls");
                if (!except.cssDisplay && notDisplayed(isAudioWithoutControls ? _path.slice(1) : _path)) {
                    return false;
                }
                if (!except.cssVisibility && notVisible(_path)) {
                    return false;
                }
                if (!except.detailsElement && collapsedParent(_path)) {
                    return false;
                }
                if (!except.browsingContext) {
                    var frameElement = getFrameElement(element);
                    var _isVisible = isVisibleRules.except(except);
                    if (frameElement && !_isVisible(frameElement)) {
                        return false;
                    }
                }
                return true;
            }
            isVisibleRules.except = function() {
                var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var isVisible = function isVisible(context) {
                    return isVisibleRules({
                        context: context,
                        except: except
                    });
                };
                isVisible.rules = isVisibleRules;
                return isVisible;
            };
            var isVisible = isVisibleRules.except({});
            function getMapByName(name, _document) {
                var map = _document.querySelector('map[name="' + cssEscape(name) + '"]');
                return map || null;
            }
            function getMapOfImage(element) {
                var usemap = element.getAttribute("usemap");
                if (!usemap) {
                    return null;
                }
                var _document = getDocument(element);
                return getMapByName(usemap.slice(1), _document);
            }
            function getImageOfArea(element) {
                var map = element.parentElement;
                if (!map.name || map.nodeName.toLowerCase() !== "map") {
                    return null;
                }
                var _document = getDocument(element);
                return _document.querySelector('img[usemap="#' + cssEscape(map.name) + '"]') || null;
            }
            var supports$4 = void 0;
            var validArea = function validArea(context) {
                if (!supports$4) {
                    supports$4 = _supports();
                }
                var element = contextToElement({
                    label: "is/valid-area",
                    context: context
                });
                var nodeName = element.nodeName.toLowerCase();
                if (nodeName !== "area") {
                    return false;
                }
                var hasTabindex = element.hasAttribute("tabindex");
                if (!supports$4.focusAreaTabindex && hasTabindex) {
                    return false;
                }
                var img = getImageOfArea(element);
                if (!img || !isVisible(img)) {
                    return false;
                }
                if (!supports$4.focusBrokenImageMap && (!img.complete || !img.naturalHeight || img.offsetWidth <= 0 || img.offsetHeight <= 0)) {
                    return false;
                }
                if (!supports$4.focusAreaWithoutHref && !element.href) {
                    return supports$4.focusAreaTabindex && hasTabindex || supports$4.focusAreaImgTabindex && img.hasAttribute("tabindex");
                }
                var childOfInteractive = getParents({
                    context: img
                }).slice(1).some(function(_element) {
                    var name = _element.nodeName.toLowerCase();
                    return name === "button" || name === "a";
                });
                if (childOfInteractive) {
                    return false;
                }
                return true;
            };
            var supports$6 = void 0;
            var disabledElementsPattern = void 0;
            var disabledElements = {
                input: true,
                select: true,
                textarea: true,
                button: true,
                fieldset: true,
                form: true
            };
            var isNativeDisabledSupported = function isNativeDisabledSupported(context) {
                if (!supports$6) {
                    supports$6 = _supports();
                    if (supports$6.focusFieldsetDisabled) {
                        delete disabledElements.fieldset;
                    }
                    if (supports$6.focusFormDisabled) {
                        delete disabledElements.form;
                    }
                    disabledElementsPattern = new RegExp("^(" + Object.keys(disabledElements).join("|") + ")$");
                }
                var element = contextToElement({
                    label: "is/native-disabled-supported",
                    context: context
                });
                var nodeName = element.nodeName.toLowerCase();
                return Boolean(disabledElementsPattern.test(nodeName));
            };
            var supports$5 = void 0;
            function isDisabledFieldset(element) {
                var nodeName = element.nodeName.toLowerCase();
                return nodeName === "fieldset" && element.disabled;
            }
            function isDisabledForm(element) {
                var nodeName = element.nodeName.toLowerCase();
                return nodeName === "form" && element.disabled;
            }
            var disabled = function disabled(context) {
                if (!supports$5) {
                    supports$5 = _supports();
                }
                var element = contextToElement({
                    label: "is/disabled",
                    context: context
                });
                if (element.hasAttribute("data-ally-disabled")) {
                    return true;
                }
                if (!isNativeDisabledSupported(element)) {
                    return false;
                }
                if (element.disabled) {
                    return true;
                }
                var parents = getParents({
                    context: element
                });
                if (parents.some(isDisabledFieldset)) {
                    return true;
                }
                if (!supports$5.focusFormDisabled && parents.some(isDisabledForm)) {
                    return true;
                }
                return false;
            };
            function isOnlyTabbableRules() {
                var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref8.context, _ref8$except = _ref8.except, except = _ref8$except === undefined ? {
                    onlyFocusableBrowsingContext: false,
                    visible: false
                } : _ref8$except;
                var element = contextToElement({
                    label: "is/only-tabbable",
                    resolveDocument: true,
                    context: context
                });
                if (!except.visible && !isVisible(element)) {
                    return false;
                }
                if (!except.onlyFocusableBrowsingContext && (platform.is.GECKO || platform.is.TRIDENT || platform.is.EDGE)) {
                    var frameElement = getFrameElement(element);
                    if (frameElement) {
                        if (tabindexValue(frameElement) < 0) {
                            return false;
                        }
                    }
                }
                var nodeName = element.nodeName.toLowerCase();
                var tabindex = tabindexValue(element);
                if (nodeName === "label" && platform.is.GECKO) {
                    return tabindex !== null && tabindex >= 0;
                }
                if (platform.is.GECKO && element.ownerSVGElement && !element.focus) {
                    if (nodeName === "a" && element.hasAttribute("xlink:href")) {
                        if (platform.is.GECKO) {
                            return true;
                        }
                    }
                }
                return false;
            }
            isOnlyTabbableRules.except = function() {
                var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var isOnlyTabbable = function isOnlyTabbable(context) {
                    return isOnlyTabbableRules({
                        context: context,
                        except: except
                    });
                };
                isOnlyTabbable.rules = isOnlyTabbableRules;
                return isOnlyTabbable;
            };
            var isOnlyTabbable = isOnlyTabbableRules.except({});
            var supports$1 = void 0;
            function isOnlyFocusRelevant(element) {
                var nodeName = element.nodeName.toLowerCase();
                if (nodeName === "embed" || nodeName === "keygen") {
                    return true;
                }
                var _tabindex = tabindexValue(element);
                if (element.shadowRoot && _tabindex === null) {
                    return true;
                }
                if (nodeName === "label") {
                    return !supports$1.focusLabelTabindex || _tabindex === null;
                }
                if (nodeName === "legend") {
                    return _tabindex === null;
                }
                if (supports$1.focusSvgFocusableAttribute && (element.ownerSVGElement || nodeName === "svg")) {
                    var focusableAttribute = element.getAttribute("focusable");
                    return focusableAttribute && focusableAttribute === "false";
                }
                if (nodeName === "img" && element.hasAttribute("usemap")) {
                    return _tabindex === null || !supports$1.focusImgUsemapTabindex;
                }
                if (nodeName === "area") {
                    return !validArea(element);
                }
                return false;
            }
            function isFocusableRules() {
                var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref9.context, _ref9$except = _ref9.except, except = _ref9$except === undefined ? {
                    disabled: false,
                    visible: false,
                    onlyTabbable: false
                } : _ref9$except;
                if (!supports$1) {
                    supports$1 = _supports();
                }
                var _isOnlyTabbable = isOnlyTabbable.rules.except({
                    onlyFocusableBrowsingContext: true,
                    visible: except.visible
                });
                var element = contextToElement({
                    label: "is/focusable",
                    resolveDocument: true,
                    context: context
                });
                var focusRelevant = isFocusRelevant.rules({
                    context: element,
                    except: except
                });
                if (!focusRelevant || isOnlyFocusRelevant(element)) {
                    return false;
                }
                if (!except.disabled && disabled(element)) {
                    return false;
                }
                if (!except.onlyTabbable && _isOnlyTabbable(element)) {
                    return false;
                }
                if (!except.visible) {
                    var visibilityOptions = {
                        context: element,
                        except: {}
                    };
                    if (supports$1.focusInHiddenIframe) {
                        visibilityOptions.except.browsingContext = true;
                    }
                    if (supports$1.focusObjectSvgHidden) {
                        var _nodeName2 = element.nodeName.toLowerCase();
                        if (_nodeName2 === "object") {
                            visibilityOptions.except.cssVisibility = true;
                        }
                    }
                    if (!isVisible.rules(visibilityOptions)) {
                        return false;
                    }
                }
                var frameElement = getFrameElement(element);
                if (frameElement) {
                    var _nodeName = frameElement.nodeName.toLowerCase();
                    if (_nodeName === "object" && !supports$1.focusInZeroDimensionObject) {
                        if (!frameElement.offsetWidth || !frameElement.offsetHeight) {
                            return false;
                        }
                    }
                }
                var nodeName = element.nodeName.toLowerCase();
                if (nodeName === "svg" && supports$1.focusSvgInIframe && !frameElement && element.getAttribute("tabindex") === null) {
                    return false;
                }
                return true;
            }
            isFocusableRules.except = function() {
                var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var isFocusable = function isFocusable(context) {
                    return isFocusableRules({
                        context: context,
                        except: except
                    });
                };
                isFocusable.rules = isFocusableRules;
                return isFocusable;
            };
            var isFocusable = isFocusableRules.except({});
            function createFilter(condition) {
                var filter = function filter(node) {
                    if (node.shadowRoot) {
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    if (condition(node)) {
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    return NodeFilter.FILTER_SKIP;
                };
                filter.acceptNode = filter;
                return filter;
            }
            var PossiblyFocusableFilter = createFilter(isFocusRelevant);
            function queryFocusableStrict() {
                var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref10.context, includeContext = _ref10.includeContext, includeOnlyTabbable = _ref10.includeOnlyTabbable, strategy = _ref10.strategy;
                if (!context) {
                    context = document.documentElement;
                }
                var _isFocusable = isFocusable.rules.except({
                    onlyTabbable: includeOnlyTabbable
                });
                var _document = getDocument(context);
                var walker = _document.createTreeWalker(context, NodeFilter.SHOW_ELEMENT, strategy === "all" ? PossiblyFocusableFilter : createFilter(_isFocusable), false);
                var list = [];
                while (walker.nextNode()) {
                    if (walker.currentNode.shadowRoot) {
                        if (_isFocusable(walker.currentNode)) {
                            list.push(walker.currentNode);
                        }
                        list = list.concat(queryFocusableStrict({
                            context: walker.currentNode.shadowRoot,
                            includeOnlyTabbable: includeOnlyTabbable,
                            strategy: strategy
                        }));
                    } else {
                        list.push(walker.currentNode);
                    }
                }
                if (includeContext) {
                    if (strategy === "all") {
                        if (isFocusRelevant(context)) {
                            list.unshift(context);
                        }
                    } else if (_isFocusable(context)) {
                        list.unshift(context);
                    }
                }
                return list;
            }
            var supports$7 = void 0;
            var selector$1 = void 0;
            var selector$2 = function selector$2() {
                if (!supports$7) {
                    supports$7 = _supports();
                }
                if (typeof selector$1 === "string") {
                    return selector$1;
                }
                selector$1 = "" + (supports$7.focusTable ? "table, td," : "") + (supports$7.focusFieldset ? "fieldset," : "") + "svg a," + "a[href]," + "area[href]," + "input, select, textarea, button," + "iframe, object, embed," + "keygen," + (supports$7.focusAudioWithoutControls ? "audio," : "audio[controls],") + (supports$7.focusVideoWithoutControls ? "video," : "video[controls],") + (supports$7.focusSummary ? "summary," : "") + "[tabindex]," + "[contenteditable]";
                selector$1 = selectInShadows(selector$1);
                return selector$1;
            };
            function queryFocusableQuick() {
                var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref11.context, includeContext = _ref11.includeContext, includeOnlyTabbable = _ref11.includeOnlyTabbable;
                var _selector = selector$2();
                var elements = context.querySelectorAll(_selector);
                var _isFocusable = isFocusable.rules.except({
                    onlyTabbable: includeOnlyTabbable
                });
                var result = [].filter.call(elements, _isFocusable);
                if (includeContext && _isFocusable(context)) {
                    result.unshift(context);
                }
                return result;
            }
            var focusable = function focusable() {
                var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref12.context, includeContext = _ref12.includeContext, includeOnlyTabbable = _ref12.includeOnlyTabbable, _ref12$strategy = _ref12.strategy, strategy = _ref12$strategy === undefined ? "quick" : _ref12$strategy;
                var element = contextToElement({
                    label: "query/focusable",
                    resolveDocument: true,
                    defaultToDocument: true,
                    context: context
                });
                var options = {
                    context: element,
                    includeContext: includeContext,
                    includeOnlyTabbable: includeOnlyTabbable,
                    strategy: strategy
                };
                if (strategy === "quick") {
                    return queryFocusableQuick(options);
                } else if (strategy === "strict" || strategy === "all") {
                    return queryFocusableStrict(options);
                }
                throw new TypeError('query/focusable requires option.strategy to be one of ["quick", "strict", "all"]');
            };
            var supports$8 = void 0;
            var focusableElementsPattern = /^(fieldset|table|td|body)$/;
            function isTabbableRules() {
                var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref13.context, _ref13$except = _ref13.except, except = _ref13$except === undefined ? {
                    flexbox: false,
                    scrollable: false,
                    shadow: false,
                    visible: false,
                    onlyTabbable: false
                } : _ref13$except;
                if (!supports$8) {
                    supports$8 = _supports();
                }
                var element = contextToElement({
                    label: "is/tabbable",
                    resolveDocument: true,
                    context: context
                });
                if (platform.is.BLINK && platform.is.ANDROID && platform.majorVersion > 42) {
                    return false;
                }
                var frameElement = getFrameElement(element);
                if (frameElement) {
                    if (platform.is.WEBKIT && platform.is.IOS) {
                        return false;
                    }
                    if (tabindexValue(frameElement) < 0) {
                        return false;
                    }
                    if (!except.visible && (platform.is.BLINK || platform.is.WEBKIT) && !isVisible(frameElement)) {
                        return false;
                    }
                    var frameNodeName = frameElement.nodeName.toLowerCase();
                    if (frameNodeName === "object") {
                        var isFixedBlink = platform.name === "Chrome" && platform.majorVersion >= 54 || platform.name === "Opera" && platform.majorVersion >= 41;
                        if (platform.is.WEBKIT || platform.is.BLINK && !isFixedBlink) {
                            return false;
                        }
                    }
                }
                var nodeName = element.nodeName.toLowerCase();
                var _tabindex = tabindexValue(element);
                var tabindex = _tabindex === null ? null : _tabindex >= 0;
                if (platform.is.EDGE && platform.majorVersion >= 14 && frameElement && element.ownerSVGElement && _tabindex < 0) {
                    return true;
                }
                var hasTabbableTabindexOrNone = tabindex !== false;
                var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0;
                if (element.hasAttribute("contenteditable")) {
                    return hasTabbableTabindexOrNone;
                }
                if (focusableElementsPattern.test(nodeName) && tabindex !== true) {
                    return false;
                }
                if (platform.is.WEBKIT && platform.is.IOS) {
                    var potentiallyTabbable = nodeName === "input" && element.type === "text" || element.type === "password" || nodeName === "select" || nodeName === "textarea" || element.hasAttribute("contenteditable");
                    if (!potentiallyTabbable) {
                        var style = window.getComputedStyle(element, null);
                        potentiallyTabbable = isUserModifyWritable(style);
                    }
                    if (!potentiallyTabbable) {
                        return false;
                    }
                }
                if (nodeName === "use" && _tabindex !== null) {
                    if (platform.is.BLINK || platform.is.WEBKIT && platform.majorVersion === 9) {
                        return true;
                    }
                }
                if (elementMatches(element, "svg a") && element.hasAttribute("xlink:href")) {
                    if (hasTabbableTabindexOrNone) {
                        return true;
                    }
                    if (element.focus && !supports$8.focusSvgNegativeTabindexAttribute) {
                        return true;
                    }
                }
                if (nodeName === "svg" && supports$8.focusSvgInIframe && hasTabbableTabindexOrNone) {
                    return true;
                }
                if (platform.is.TRIDENT || platform.is.EDGE) {
                    if (nodeName === "svg") {
                        if (supports$8.focusSvg) {
                            return true;
                        }
                        return element.hasAttribute("focusable") || hasTabbableTabindex;
                    }
                    if (element.ownerSVGElement) {
                        if (supports$8.focusSvgTabindexAttribute && hasTabbableTabindex) {
                            return true;
                        }
                        return element.hasAttribute("focusable");
                    }
                }
                if (element.tabIndex === undefined) {
                    return Boolean(except.onlyTabbable);
                }
                if (nodeName === "audio") {
                    if (!element.hasAttribute("controls")) {
                        return false;
                    } else if (platform.is.BLINK) {
                        return true;
                    }
                }
                if (nodeName === "video") {
                    if (!element.hasAttribute("controls")) {
                        if (platform.is.TRIDENT || platform.is.EDGE) {
                            return false;
                        }
                    } else if (platform.is.BLINK || platform.is.GECKO) {
                        return true;
                    }
                }
                if (nodeName === "object") {
                    if (platform.is.BLINK || platform.is.WEBKIT) {
                        return false;
                    }
                }
                if (nodeName === "iframe") {
                    return false;
                }
                if (!except.scrollable && platform.is.GECKO) {
                    var _style = window.getComputedStyle(element, null);
                    if (hasCssOverflowScroll(_style)) {
                        return hasTabbableTabindexOrNone;
                    }
                }
                if (platform.is.TRIDENT || platform.is.EDGE) {
                    if (nodeName === "area") {
                        var img = getImageOfArea(element);
                        if (img && tabindexValue(img) < 0) {
                            return false;
                        }
                    }
                    var _style2 = window.getComputedStyle(element, null);
                    if (isUserModifyWritable(_style2)) {
                        return element.tabIndex >= 0;
                    }
                    if (!except.flexbox && hasCssDisplayFlex(_style2)) {
                        if (_tabindex !== null) {
                            return hasTabbableTabindex;
                        }
                        return isFocusRelevantWithoutFlexbox(element) && isTabbableWithoutFlexbox(element);
                    }
                    if (isScrollableContainer(element, nodeName)) {
                        return false;
                    }
                    var parent = element.parentElement;
                    if (parent) {
                        var parentNodeName = parent.nodeName.toLowerCase();
                        var parentStyle = window.getComputedStyle(parent, null);
                        if (isScrollableContainer(parent, nodeName, parentNodeName, parentStyle)) {
                            return false;
                        }
                        if (hasCssDisplayFlex(parentStyle)) {
                            return hasTabbableTabindex;
                        }
                    }
                }
                return element.tabIndex >= 0;
            }
            isTabbableRules.except = function() {
                var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var isTabbable = function isTabbable(context) {
                    return isTabbableRules({
                        context: context,
                        except: except
                    });
                };
                isTabbable.rules = isTabbableRules;
                return isTabbable;
            };
            var isFocusRelevantWithoutFlexbox = isFocusRelevant.rules.except({
                flexbox: true
            });
            var isTabbableWithoutFlexbox = isTabbableRules.except({
                flexbox: true
            });
            var isTabbable = isTabbableRules.except({});
            var queryTabbable = function queryTabbable() {
                var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref14.context, includeContext = _ref14.includeContext, includeOnlyTabbable = _ref14.includeOnlyTabbable, strategy = _ref14.strategy;
                var _isTabbable = isTabbable.rules.except({
                    onlyTabbable: includeOnlyTabbable
                });
                return focusable({
                    context: context,
                    includeContext: includeContext,
                    includeOnlyTabbable: includeOnlyTabbable,
                    strategy: strategy
                }).filter(_isTabbable);
            };
            function compareDomPosition(a, b) {
                return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
            }
            var sortDomOrder = function sortDomOrder(elements) {
                return elements.sort(compareDomPosition);
            };
            function getFirstSuccessorOffset(list, target) {
                return findIndex(list, function(element) {
                    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;
                });
            }
            function findInsertionOffsets(list, elements, resolveElement) {
                var insertions = [];
                elements.forEach(function(element) {
                    var replace = true;
                    var offset = list.indexOf(element);
                    if (offset === -1) {
                        offset = getFirstSuccessorOffset(list, element);
                        replace = false;
                    }
                    if (offset === -1) {
                        offset = list.length;
                    }
                    var injections = nodeArray(resolveElement ? resolveElement(element) : element);
                    if (!injections.length) {
                        return;
                    }
                    insertions.push({
                        offset: offset,
                        replace: replace,
                        elements: injections
                    });
                });
                return insertions;
            }
            function insertElementsAtOffsets(list, insertions) {
                var inserted = 0;
                insertions.sort(function(a, b) {
                    return a.offset - b.offset;
                });
                insertions.forEach(function(insertion) {
                    var remove = insertion.replace ? 1 : 0;
                    var args = [ insertion.offset + inserted, remove ].concat(insertion.elements);
                    list.splice.apply(list, args);
                    inserted += insertion.elements.length - remove;
                });
            }
            var mergeInDomOrder = function mergeInDomOrder() {
                var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, list = _ref15.list, elements = _ref15.elements, resolveElement = _ref15.resolveElement;
                var _list = list.slice(0);
                var _elements = nodeArray(elements).slice(0);
                sortDomOrder(_elements);
                var insertions = findInsertionOffsets(_list, _elements, resolveElement);
                insertElementsAtOffsets(_list, insertions);
                return _list;
            };
            var supports = void 0;
            function formControlElement(element) {
                var nodeName = element.nodeName.toLowerCase();
                return nodeName === "input" || nodeName === "textarea" || nodeName === "select" || nodeName === "button";
            }
            function resolveLabelElement(element, _document) {
                var forId = element.getAttribute("for");
                if (forId) {
                    return _document.getElementById(forId);
                }
                return element.querySelector("input, select, textarea");
            }
            function resolveLegendWithinFieldset(element) {
                var fieldset = element.parentNode;
                var focusable$$1 = focusable({
                    context: fieldset,
                    strategy: "strict"
                });
                return focusable$$1.filter(formControlElement)[0] || null;
            }
            function resolveLegendWithinDocument(element, _document) {
                var tabbable = queryTabbable({
                    context: _document.body,
                    strategy: "strict"
                });
                if (!tabbable.length) {
                    return null;
                }
                var merged = mergeInDomOrder({
                    list: tabbable,
                    elements: [ element ]
                });
                var offset = merged.indexOf(element);
                if (offset === merged.length - 1) {
                    return null;
                }
                return merged[offset + 1];
            }
            function resolveLegendElement(element, _document) {
                if (!supports.focusRedirectLegend) {
                    return null;
                }
                var fieldset = element.parentNode;
                if (fieldset.nodeName.toLowerCase() !== "fieldset") {
                    return null;
                }
                if (supports.focusRedirectLegend === "tabbable") {
                    return resolveLegendWithinDocument(element, _document);
                }
                return resolveLegendWithinFieldset(element, _document);
            }
            function resolveImgElement(element) {
                if (!supports.focusRedirectImgUsemap) {
                    return null;
                }
                var map = getMapOfImage(element);
                return map && map.querySelector("area") || null;
            }
            var getFocusRedirectTarget = function getFocusRedirectTarget() {
                var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref16.context, skipFocusable = _ref16.skipFocusable;
                if (!supports) {
                    supports = _supports();
                }
                var element = contextToElement({
                    label: "get/focus-redirect-target",
                    context: context
                });
                if (!skipFocusable && isFocusable(element)) {
                    return null;
                }
                var nodeName = element.nodeName.toLowerCase();
                var _document = getDocument(element);
                if (nodeName === "label") {
                    return resolveLabelElement(element, _document);
                }
                if (nodeName === "legend") {
                    return resolveLegendElement(element, _document);
                }
                if (nodeName === "img") {
                    return resolveImgElement(element, _document);
                }
                return null;
            };
            var focusTarget = function focusTarget() {
                var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref17.context, except = _ref17.except;
                var element = contextToElement({
                    label: "get/focus-target",
                    context: context
                });
                var result = null;
                var getTarget = function getTarget(_element) {
                    var focusable = isFocusable.rules({
                        context: _element,
                        except: except
                    });
                    if (focusable) {
                        result = _element;
                        return true;
                    }
                    result = getFocusRedirectTarget({
                        context: _element,
                        skipFocusable: true
                    });
                    return Boolean(result);
                };
                if (getTarget(element)) {
                    return result;
                }
                getParents({
                    context: element
                }).slice(1).some(getTarget);
                return result;
            };
            function getParentComparator() {
                var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, parent = _ref18.parent, element = _ref18.element, includeSelf = _ref18.includeSelf;
                if (parent) {
                    return function isChildOf(node) {
                        return Boolean(includeSelf && node === parent || parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);
                    };
                } else if (element) {
                    return function isParentOf(node) {
                        return Boolean(includeSelf && element === node || node.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);
                    };
                }
                throw new TypeError("util/compare-position#getParentComparator required either options.parent or options.element");
            }
            function queryInsignificantBranches(_ref19) {
                var context = _ref19.context, filter = _ref19.filter;
                var containsFilteredElement = function containsFilteredElement(node) {
                    var containsNode = getParentComparator({
                        parent: node
                    });
                    return filter.some(containsNode);
                };
                var insiginificantBranches = [];
                var CollectInsignificantBranchesFilter = function CollectInsignificantBranchesFilter(node) {
                    if (filter.some(function(element) {
                        return node === element;
                    })) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    if (containsFilteredElement(node)) {
                        return NodeFilter.FILTER_ACCEPT;
                    }
                    insiginificantBranches.push(node);
                    return NodeFilter.FILTER_REJECT;
                };
                CollectInsignificantBranchesFilter.acceptNode = CollectInsignificantBranchesFilter;
                var _document = getDocument(context);
                var walker = _document.createTreeWalker(context, NodeFilter.SHOW_ELEMENT, CollectInsignificantBranchesFilter, false);
                while (walker.nextNode()) {}
                return insiginificantBranches;
            }
            var insignificantBranches = function insignificantBranches() {
                var _ref20 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref20.context, filter = _ref20.filter;
                context = contextToElement({
                    label: "get/insignificant-branches",
                    defaultToDocument: true,
                    context: context
                });
                filter = nodeArray(filter);
                if (!filter.length) {
                    throw new TypeError("get/insignificant-branches requires valid options.filter");
                }
                return queryInsignificantBranches({
                    context: context,
                    filter: filter
                });
            };
            var get = {
                activeElement: activeElement,
                activeElements: activeElements,
                focusRedirectTarget: getFocusRedirectTarget,
                focusTarget: focusTarget,
                insignificantBranches: insignificantBranches,
                parents: getParents,
                shadowHostParents: getShadowHostParents,
                shadowHost: getShadowHost
            };
            var activeElement$1 = function activeElement$1(context) {
                var element = contextToElement({
                    label: "is/active-element",
                    resolveDocument: true,
                    context: context
                });
                var _document = getDocument(element);
                if (_document.activeElement === element) {
                    return true;
                }
                var shadowHost = getShadowHost({
                    context: element
                });
                if (shadowHost && shadowHost.shadowRoot.activeElement === element) {
                    return true;
                }
                return false;
            };
            var is = {
                activeElement: activeElement$1,
                disabled: disabled,
                focusRelevant: isFocusRelevant,
                focusable: isFocusable,
                onlyTabbable: isOnlyTabbable,
                shadowed: shadowed,
                tabbable: isTabbable,
                validArea: validArea,
                validTabindex: validTabindex,
                visible: isVisible
            };
            function hasAutofocus(element) {
                return element.hasAttribute("autofocus");
            }
            function hasNoPositiveTabindex(element) {
                return element.tabIndex <= 0;
            }
            var firstTabbable = function firstTabbable() {
                var _ref21 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref21.context, sequence = _ref21.sequence, strategy = _ref21.strategy, ignoreAutofocus = _ref21.ignoreAutofocus, defaultToContext = _ref21.defaultToContext, includeOnlyTabbable = _ref21.includeOnlyTabbable;
                var index = -1;
                if (!sequence) {
                    context = nodeArray(context || document.body)[0];
                    sequence = queryTabbable({
                        context: context,
                        includeOnlyTabbable: includeOnlyTabbable,
                        strategy: strategy
                    });
                }
                if (sequence.length && !ignoreAutofocus) {
                    index = findIndex(sequence, hasAutofocus);
                }
                if (sequence.length && index === -1) {
                    index = findIndex(sequence, hasNoPositiveTabindex);
                }
                var _isFocusable = isFocusable.rules.except({
                    onlyTabbable: includeOnlyTabbable
                });
                if (index === -1 && defaultToContext && context && _isFocusable(context)) {
                    return context;
                }
                return sequence[index] || null;
            };
            var filter = function filter(node) {
                if (node.shadowRoot) {
                    return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_SKIP;
            };
            filter.acceptNode = filter;
            function queryShadowHosts() {
                var _ref22 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref22.context;
                var element = contextToElement({
                    label: "query/shadow-hosts",
                    resolveDocument: true,
                    defaultToDocument: true,
                    context: context
                });
                var _document = getDocument(context);
                var walker = _document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, filter, false);
                var list = [];
                if (element.shadowRoot) {
                    list.push(element);
                    list = list.concat(queryShadowHosts({
                        context: element.shadowRoot
                    }));
                }
                while (walker.nextNode()) {
                    list.push(walker.currentNode);
                    list = list.concat(queryShadowHosts({
                        context: walker.currentNode.shadowRoot
                    }));
                }
                return list;
            }
            var Maps = function() {
                function Maps(context) {
                    _classCallCheck(this, Maps);
                    this._document = getDocument(context);
                    this.maps = {};
                }
                _createClass(Maps, [ {
                    key: "getAreasFor",
                    value: function getAreasFor(name) {
                        if (!this.maps[name]) {
                            this.addMapByName(name);
                        }
                        return this.maps[name];
                    }
                }, {
                    key: "addMapByName",
                    value: function addMapByName(name) {
                        var map = getMapByName(name, this._document);
                        if (!map) {
                            return;
                        }
                        this.maps[map.name] = queryTabbable({
                            context: map
                        });
                    }
                }, {
                    key: "extractAreasFromList",
                    value: function extractAreasFromList(elements) {
                        return elements.filter(function(element) {
                            var nodeName = element.nodeName.toLowerCase();
                            if (nodeName !== "area") {
                                return true;
                            }
                            var map = element.parentNode;
                            if (!this.maps[map.name]) {
                                this.maps[map.name] = [];
                            }
                            this.maps[map.name].push(element);
                            return false;
                        }, this);
                    }
                } ]);
                return Maps;
            }();
            var sortArea = function sortArea(elements, context) {
                var usemaps = context.querySelectorAll("img[usemap]");
                var maps = new Maps(context);
                var _elements = maps.extractAreasFromList(elements);
                if (!usemaps.length) {
                    return _elements;
                }
                return mergeInDomOrder({
                    list: _elements,
                    elements: usemaps,
                    resolveElement: function resolveElement(image) {
                        var name = image.getAttribute("usemap").slice(1);
                        return maps.getAreasFor(name);
                    }
                });
            };
            var Shadows = function() {
                function Shadows(context, sortElements) {
                    _classCallCheck(this, Shadows);
                    this.context = context;
                    this.sortElements = sortElements;
                    this.hostCounter = 1;
                    this.inHost = {};
                    this.inDocument = [];
                    this.hosts = {};
                    this.elements = {};
                }
                _createClass(Shadows, [ {
                    key: "_registerHost",
                    value: function _registerHost(host) {
                        if (host._sortingId) {
                            return;
                        }
                        host._sortingId = "shadow-" + this.hostCounter++;
                        this.hosts[host._sortingId] = host;
                        var parentHost = getShadowHost({
                            context: host
                        });
                        if (parentHost) {
                            this._registerHost(parentHost);
                            this._registerHostParent(host, parentHost);
                        } else {
                            this.inDocument.push(host);
                        }
                    }
                }, {
                    key: "_registerHostParent",
                    value: function _registerHostParent(host, parent) {
                        if (!this.inHost[parent._sortingId]) {
                            this.inHost[parent._sortingId] = [];
                        }
                        this.inHost[parent._sortingId].push(host);
                    }
                }, {
                    key: "_registerElement",
                    value: function _registerElement(element, host) {
                        if (!this.elements[host._sortingId]) {
                            this.elements[host._sortingId] = [];
                        }
                        this.elements[host._sortingId].push(element);
                    }
                }, {
                    key: "extractElements",
                    value: function extractElements(elements) {
                        return elements.filter(function(element) {
                            var host = getShadowHost({
                                context: element
                            });
                            if (!host) {
                                return true;
                            }
                            this._registerHost(host);
                            this._registerElement(element, host);
                            return false;
                        }, this);
                    }
                }, {
                    key: "sort",
                    value: function sort(elements) {
                        var _elements = this._injectHosts(elements);
                        _elements = this._replaceHosts(_elements);
                        this._cleanup();
                        return _elements;
                    }
                }, {
                    key: "_injectHosts",
                    value: function _injectHosts(elements) {
                        Object.keys(this.hosts).forEach(function(_sortingId) {
                            var _list = this.elements[_sortingId];
                            var _elements = this.inHost[_sortingId];
                            var _context = this.hosts[_sortingId].shadowRoot;
                            this.elements[_sortingId] = this._merge(_list, _elements, _context);
                        }, this);
                        return this._merge(elements, this.inDocument, this.context);
                    }
                }, {
                    key: "_merge",
                    value: function _merge(list, elements, context) {
                        var merged = mergeInDomOrder({
                            list: list,
                            elements: elements
                        });
                        return this.sortElements(merged, context);
                    }
                }, {
                    key: "_replaceHosts",
                    value: function _replaceHosts(elements) {
                        return mergeInDomOrder({
                            list: elements,
                            elements: this.inDocument,
                            resolveElement: this._resolveHostElement.bind(this)
                        });
                    }
                }, {
                    key: "_resolveHostElement",
                    value: function _resolveHostElement(host) {
                        var merged = mergeInDomOrder({
                            list: this.elements[host._sortingId],
                            elements: this.inHost[host._sortingId],
                            resolveElement: this._resolveHostElement.bind(this)
                        });
                        var _tabindex = tabindexValue(host);
                        if (_tabindex !== null && _tabindex > -1) {
                            return [ host ].concat(merged);
                        }
                        return merged;
                    }
                }, {
                    key: "_cleanup",
                    value: function _cleanup() {
                        Object.keys(this.hosts).forEach(function(key) {
                            delete this.hosts[key]._sortingId;
                        }, this);
                    }
                } ]);
                return Shadows;
            }();
            var sortShadowed = function sortShadowed(elements, context, sortElements) {
                var shadows = new Shadows(context, sortElements);
                var _elements = shadows.extractElements(elements);
                if (_elements.length === elements.length) {
                    return sortElements(elements);
                }
                return shadows.sort(_elements);
            };
            var sortTabindex = function sortTabindex(elements) {
                var map = {};
                var indexes = [];
                var normal = elements.filter(function(element) {
                    var tabIndex = element.tabIndex;
                    if (tabIndex === undefined) {
                        tabIndex = tabindexValue(element);
                    }
                    if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {
                        return true;
                    }
                    if (!map[tabIndex]) {
                        map[tabIndex] = [];
                        indexes.push(tabIndex);
                    }
                    map[tabIndex].push(element);
                    return false;
                });
                var _elements = indexes.sort().map(function(tabIndex) {
                    return map[tabIndex];
                }).reduceRight(function(previous, current) {
                    return current.concat(previous);
                }, normal);
                return _elements;
            };
            var supports$9 = void 0;
            function moveContextToBeginning(elements, context) {
                var pos = elements.indexOf(context);
                if (pos > 0) {
                    var tmp = elements.splice(pos, 1);
                    return tmp.concat(elements);
                }
                return elements;
            }
            function sortElements(elements, _context) {
                if (supports$9.tabsequenceAreaAtImgPosition) {
                    elements = sortArea(elements, _context);
                }
                elements = sortTabindex(elements);
                return elements;
            }
            var tabsequence = function tabsequence() {
                var _ref23 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref23.context, includeContext = _ref23.includeContext, includeOnlyTabbable = _ref23.includeOnlyTabbable, strategy = _ref23.strategy;
                if (!supports$9) {
                    supports$9 = _supports();
                }
                var _context = nodeArray(context)[0] || document.documentElement;
                var elements = queryTabbable({
                    context: _context,
                    includeContext: includeContext,
                    includeOnlyTabbable: includeOnlyTabbable,
                    strategy: strategy
                });
                if (document.body.createShadowRoot && platform.is.BLINK) {
                    elements = sortShadowed(elements, _context, sortElements);
                } else {
                    elements = sortElements(elements, _context);
                }
                if (includeContext) {
                    elements = moveContextToBeginning(elements, _context);
                }
                return elements;
            };
            var query = {
                firstTabbable: firstTabbable,
                focusable: focusable,
                shadowHosts: queryShadowHosts,
                tabbable: queryTabbable,
                tabsequence: tabsequence
            };
            var conflicted = typeof window !== "undefined" && window.ally;
            var ally_js = {
                get: get,
                is: is,
                query: query,
                noConflict: function noConflict() {
                    if (typeof window !== "undefined" && window.ally === this) {
                        window.ally = conflicted;
                    }
                    return this;
                }
            };
            module.exports = ally_js;
        }, {
            "css.escape": 2,
            platform: 3
        } ],
        2: [ function(require, module, exports) {
            (function(global) {
                (function(root, factory) {
                    if (typeof exports == "object") {
                        module.exports = factory(root);
                    // [OT] Rename the local "define" function to "localDefine"
                    //      to prevent r.js from namespacing it to "csui.define".
                    } else if (typeof localDefine == "function" && localDefine.amd) {
                        localDefine([], factory.bind(root, root));
                    } else {
                        factory(root);
                    }
                })(typeof global != "undefined" ? global : this, function(root) {
                    if (root.CSS && root.CSS.escape) {
                        return root.CSS.escape;
                    }
                    var cssEscape = function(value) {
                        if (arguments.length == 0) {
                            throw new TypeError("`CSS.escape` requires an argument.");
                        }
                        var string = String(value);
                        var length = string.length;
                        var index = -1;
                        var codeUnit;
                        var result = "";
                        var firstCodeUnit = string.charCodeAt(0);
                        while (++index < length) {
                            codeUnit = string.charCodeAt(index);
                            if (codeUnit == 0) {
                                result += "";
                                continue;
                            }
                            if (codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || index == 0 && codeUnit >= 48 && codeUnit <= 57 || index == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45) {
                                result += "\\" + codeUnit.toString(16) + " ";
                                continue;
                            }
                            if (index == 0 && length == 1 && codeUnit == 45) {
                                result += "\\" + string.charAt(index);
                                continue;
                            }
                            if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
                                result += string.charAt(index);
                                continue;
                            }
                            result += "\\" + string.charAt(index);
                        }
                        return result;
                    };
                    if (!root.CSS) {
                        root.CSS = {};
                    }
                    root.CSS.escape = cssEscape;
                    return cssEscape;
                });
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {} ],
        3: [ function(require, module, exports) {
            (function(global) {
                (function() {
                    "use strict";
                    var objectTypes = {
                        function: true,
                        object: true
                    };
                    var root = objectTypes[typeof window] && window || this;
                    var oldRoot = root;
                    var freeExports = objectTypes[typeof exports] && exports;
                    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                    var freeGlobal = freeExports && freeModule && typeof global == "object" && global;
                    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
                        root = freeGlobal;
                    }
                    var maxSafeInteger = Math.pow(2, 53) - 1;
                    var reOpera = /\bOpera/;
                    var thisBinding = this;
                    var objectProto = Object.prototype;
                    var hasOwnProperty = objectProto.hasOwnProperty;
                    var toString = objectProto.toString;
                    function capitalize(string) {
                        string = String(string);
                        return string.charAt(0).toUpperCase() + string.slice(1);
                    }
                    function cleanupOS(os, pattern, label) {
                        var data = {
                            "10.0": "10",
                            "6.4": "10 Technical Preview",
                            "6.3": "8.1",
                            "6.2": "8",
                            "6.1": "Server 2008 R2 / 7",
                            "6.0": "Server 2008 / Vista",
                            "5.2": "Server 2003 / XP 64-bit",
                            "5.1": "XP",
                            "5.01": "2000 SP1",
                            "5.0": "2000",
                            "4.0": "NT",
                            "4.90": "ME"
                        };
                        if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
                            os = "Windows " + data;
                        }
                        os = String(os);
                        if (pattern && label) {
                            os = os.replace(RegExp(pattern, "i"), label);
                        }
                        os = format(os.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]);
                        return os;
                    }
                    function each(object, callback) {
                        var index = -1, length = object ? object.length : 0;
                        if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
                            while (++index < length) {
                                callback(object[index], index, object);
                            }
                        } else {
                            forOwn(object, callback);
                        }
                    }
                    function format(string) {
                        string = trim(string);
                        return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);
                    }
                    function forOwn(object, callback) {
                        for (var key in object) {
                            if (hasOwnProperty.call(object, key)) {
                                callback(object[key], key, object);
                            }
                        }
                    }
                    function getClassOf(value) {
                        return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
                    }
                    function isHostType(object, property) {
                        var type = object != null ? typeof object[property] : "number";
                        return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object[property] : true);
                    }
                    function qualify(string) {
                        return String(string).replace(/([ -])(?!$)/g, "$1?");
                    }
                    function reduce(array, callback) {
                        var accumulator = null;
                        each(array, function(value, index) {
                            accumulator = callback(accumulator, value, index, array);
                        });
                        return accumulator;
                    }
                    function trim(string) {
                        return String(string).replace(/^ +| +$/g, "");
                    }
                    function parse(ua) {
                        var context = root;
                        var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
                        if (isCustomContext) {
                            context = ua;
                            ua = null;
                        }
                        var nav = context.navigator || {};
                        var userAgent = nav.userAgent || "";
                        ua || (ua = userAgent);
                        var isModuleScope = isCustomContext || thisBinding == oldRoot;
                        var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());
                        var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
                        var java = /\bJava/.test(javaClass) && context.java;
                        var rhino = java && getClassOf(context.environment) == enviroClass;
                        var alpha = java ? "a" : "";
                        var beta = java ? "b" : "";
                        var doc = context.document || {};
                        var opera = context.operamini || context.opera;
                        var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
                        var data;
                        var arch = ua;
                        var description = [];
                        var prerelease = null;
                        var useFeatures = ua == userAgent;
                        var version = useFeatures && opera && typeof opera.version == "function" && opera.version();
                        var isSpecialCasedOS;
                        var layout = getLayout([ {
                            label: "EdgeHTML",
                            pattern: "Edge"
                        }, "Trident", {
                            label: "WebKit",
                            pattern: "AppleWebKit"
                        }, "iCab", "Presto", "NetFront", "Tasman", "KHTML", "Gecko" ]);
                        var name = getName([ "Adobe AIR", "Arora", "Avant Browser", "Breach", "Camino", "Epiphany", "Fennec", "Flock", "Galeon", "GreenBrowser", "iCab", "Iceweasel", "K-Meleon", "Konqueror", "Lunascape", "Maxthon", {
                            label: "Microsoft Edge",
                            pattern: "Edge"
                        }, "Midori", "Nook Browser", "PaleMoon", "PhantomJS", "Raven", "Rekonq", "RockMelt", "SeaMonkey", {
                            label: "Silk",
                            pattern: "(?:Cloud9|Silk-Accelerated)"
                        }, "Sleipnir", "SlimBrowser", {
                            label: "SRWare Iron",
                            pattern: "Iron"
                        }, "Sunrise", "Swiftfox", "WebPositive", "Opera Mini", {
                            label: "Opera Mini",
                            pattern: "OPiOS"
                        }, "Opera", {
                            label: "Opera",
                            pattern: "OPR"
                        }, "Chrome", {
                            label: "Chrome Mobile",
                            pattern: "(?:CriOS|CrMo)"
                        }, {
                            label: "Firefox",
                            pattern: "(?:Firefox|Minefield)"
                        }, {
                            label: "Firefox for iOS",
                            pattern: "FxiOS"
                        }, {
                            label: "IE",
                            pattern: "IEMobile"
                        }, {
                            label: "IE",
                            pattern: "MSIE"
                        }, "Safari" ]);
                        var product = getProduct([ {
                            label: "BlackBerry",
                            pattern: "BB10"
                        }, "BlackBerry", {
                            label: "Galaxy S",
                            pattern: "GT-I9000"
                        }, {
                            label: "Galaxy S2",
                            pattern: "GT-I9100"
                        }, {
                            label: "Galaxy S3",
                            pattern: "GT-I9300"
                        }, {
                            label: "Galaxy S4",
                            pattern: "GT-I9500"
                        }, "Google TV", "Lumia", "iPad", "iPod", "iPhone", "Kindle", {
                            label: "Kindle Fire",
                            pattern: "(?:Cloud9|Silk-Accelerated)"
                        }, "Nexus", "Nook", "PlayBook", "PlayStation 3", "PlayStation 4", "PlayStation Vita", "TouchPad", "Transformer", {
                            label: "Wii U",
                            pattern: "WiiU"
                        }, "Wii", "Xbox One", {
                            label: "Xbox 360",
                            pattern: "Xbox"
                        }, "Xoom" ]);
                        var manufacturer = getManufacturer({
                            Apple: {
                                iPad: 1,
                                iPhone: 1,
                                iPod: 1
                            },
                            Archos: {},
                            Amazon: {
                                Kindle: 1,
                                "Kindle Fire": 1
                            },
                            Asus: {
                                Transformer: 1
                            },
                            "Barnes & Noble": {
                                Nook: 1
                            },
                            BlackBerry: {
                                PlayBook: 1
                            },
                            Google: {
                                "Google TV": 1,
                                Nexus: 1
                            },
                            HP: {
                                TouchPad: 1
                            },
                            HTC: {},
                            LG: {},
                            Microsoft: {
                                Xbox: 1,
                                "Xbox One": 1
                            },
                            Motorola: {
                                Xoom: 1
                            },
                            Nintendo: {
                                "Wii U": 1,
                                Wii: 1
                            },
                            Nokia: {
                                Lumia: 1
                            },
                            Samsung: {
                                "Galaxy S": 1,
                                "Galaxy S2": 1,
                                "Galaxy S3": 1,
                                "Galaxy S4": 1
                            },
                            Sony: {
                                "PlayStation 4": 1,
                                "PlayStation 3": 1,
                                "PlayStation Vita": 1
                            }
                        });
                        var os = getOS([ "Windows Phone", "Android", "CentOS", {
                            label: "Chrome OS",
                            pattern: "CrOS"
                        }, "Debian", "Fedora", "FreeBSD", "Gentoo", "Haiku", "Kubuntu", "Linux Mint", "OpenBSD", "Red Hat", "SuSE", "Ubuntu", "Xubuntu", "Cygwin", "Symbian OS", "hpwOS", "webOS ", "webOS", "Tablet OS", "Linux", "Mac OS X", "Macintosh", "Mac", "Windows 98;", "Windows " ]);
                        function getLayout(guesses) {
                            return reduce(guesses, function(result, guess) {
                                return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                            });
                        }
                        function getManufacturer(guesses) {
                            return reduce(guesses, function(result, value, key) {
                                return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
                            });
                        }
                        function getName(guesses) {
                            return reduce(guesses, function(result, guess) {
                                return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                            });
                        }
                        function getOS(guesses) {
                            return reduce(guesses, function(result, guess) {
                                var pattern = guess.pattern || qualify(guess);
                                if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
                                    result = cleanupOS(result, pattern, guess.label || guess);
                                }
                                return result;
                            });
                        }
                        function getProduct(guesses) {
                            return reduce(guesses, function(result, guess) {
                                var pattern = guess.pattern || qualify(guess);
                                if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
                                    if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
                                        result[0] += " " + result[1];
                                    }
                                    guess = guess.label || guess;
                                    result = format(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
                                }
                                return result;
                            });
                        }
                        function getVersion(patterns) {
                            return reduce(patterns, function(result, pattern) {
                                return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
                            });
                        }
                        function toStringPlatform() {
                            return this.description || "";
                        }
                        layout && (layout = [ layout ]);
                        if (manufacturer && !product) {
                            product = getProduct([ manufacturer ]);
                        }
                        if (data = /\bGoogle TV\b/.exec(product)) {
                            product = data[0];
                        }
                        if (/\bSimulator\b/i.test(ua)) {
                            product = (product ? product + " " : "") + "Simulator";
                        }
                        if (name == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
                            description.push("running in Turbo/Uncompressed mode");
                        }
                        if (name == "IE" && /\blike iPhone OS\b/.test(ua)) {
                            data = parse(ua.replace(/like iPhone OS/, ""));
                            manufacturer = data.manufacturer;
                            product = data.product;
                        } else if (/^iP/.test(product)) {
                            name || (name = "Safari");
                            os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
                        } else if (name == "Konqueror" && !/buntu/i.test(os)) {
                            os = "Kubuntu";
                        } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua)) {
                            name = "Android Browser";
                            os = /\bAndroid\b/.test(os) ? os : "Android";
                        } else if (name == "Silk") {
                            if (!/\bMobi/i.test(ua)) {
                                os = "Android";
                                description.unshift("desktop mode");
                            }
                            if (/Accelerated *= *true/i.test(ua)) {
                                description.unshift("accelerated");
                            }
                        } else if (name == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
                            description.push("identifying as Firefox " + data[1]);
                        } else if (name == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
                            os || (os = "Firefox OS");
                            product || (product = data[1]);
                        } else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
                            if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
                                name = null;
                            }
                            if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
                                name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
                            }
                        }
                        if (!version) {
                            version = getVersion([ "(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))", "Version", qualify(name), "(?:Firefox|Minefield|NetFront)" ]);
                        }
                        if (data = layout == "iCab" && parseFloat(version) > 3 && "WebKit" || /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name) && "NetFront") {
                            layout = [ data ];
                        }
                        if (name == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
                            name += " Mobile";
                            os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
                            description.unshift("desktop mode");
                        } else if (/\bWPDesktop\b/i.test(ua)) {
                            name = "IE Mobile";
                            os = "Windows Phone 8.x";
                            description.unshift("desktop mode");
                            version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
                        } else if (name != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
                            if (name) {
                                description.push("identifying as " + name + (version ? " " + version : ""));
                            }
                            name = "IE";
                            version = data[1];
                        }
                        if (useFeatures) {
                            if (isHostType(context, "global")) {
                                if (java) {
                                    data = java.lang.System;
                                    arch = data.getProperty("os.arch");
                                    os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
                                }
                                if (isModuleScope && isHostType(context, "system") && (data = [ context.system ])[0]) {
                                    os || (os = data[0].os || null);
                                    try {
                                        data[1] = context.require("ringo/engine").version;
                                        version = data[1].join(".");
                                        name = "RingoJS";
                                    } catch (e) {
                                        if (data[0].global.system == context.system) {
                                            name = "Narwhal";
                                        }
                                    }
                                } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
                                    name = "Node.js";
                                    arch = data.arch;
                                    os = data.platform;
                                    version = /[\d.]+/.exec(data.version)[0];
                                } else if (rhino) {
                                    name = "Rhino";
                                }
                            } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
                                name = "Adobe AIR";
                                os = data.flash.system.Capabilities.os;
                            } else if (getClassOf(data = context.phantom) == phantomClass) {
                                name = "PhantomJS";
                                version = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
                            } else if (typeof doc.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
                                version = [ version, doc.documentMode ];
                                if ((data = +data[1] + 4) != version[1]) {
                                    description.push("IE " + version[1] + " mode");
                                    layout && (layout[1] = "");
                                    version[1] = data;
                                }
                                version = name == "IE" ? String(version[1].toFixed(1)) : version[0];
                            }
                            os = os && format(os);
                        }
                        if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
                            prerelease = /b/i.test(data) ? "beta" : "alpha";
                            version = version.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
                        }
                        if (name == "Fennec" || name == "Firefox" && /\b(?:Android|Firefox OS)\b/.test(os)) {
                            name = "Firefox Mobile";
                        } else if (name == "Maxthon" && version) {
                            version = version.replace(/\.[\d.]+/, ".x");
                        } else if (/\bXbox\b/i.test(product)) {
                            os = null;
                            if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
                                description.unshift("mobile mode");
                            }
                        } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == "Windows CE" || /Mobi/i.test(ua))) {
                            name += " Mobile";
                        } else if (name == "IE" && useFeatures && context.external === null) {
                            description.unshift("platform preview");
                        } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version)) {
                            data = [ data, /BB10/.test(ua) ];
                            os = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
                            version = null;
                        } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os) || name == "IE" && (os && !/^Win/.test(os) && version > 5.5 || /\bWindows XP\b/.test(os) && version > 8 || version == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
                            data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
                            if (reOpera.test(name)) {
                                if (/\bIE\b/.test(data) && os == "Mac OS") {
                                    os = null;
                                }
                                data = "identify" + data;
                            } else {
                                data = "mask" + data;
                                if (operaClass) {
                                    name = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
                                } else {
                                    name = "Opera";
                                }
                                if (/\bIE\b/.test(data)) {
                                    os = null;
                                }
                                if (!useFeatures) {
                                    version = null;
                                }
                            }
                            layout = [ "Presto" ];
                            description.push(data);
                        }
                        if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
                            data = [ parseFloat(data.replace(/\.(\d)$/, ".0$1")), data ];
                            if (name == "Safari" && data[1].slice(-1) == "+") {
                                name = "WebKit Nightly";
                                prerelease = "alpha";
                                version = data[1].slice(0, -1);
                            } else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
                                version = null;
                            }
                            data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
                            if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
                                layout = [ "Blink" ];
                            }
                            if (!useFeatures || !likeChrome && !data[1]) {
                                layout && (layout[1] = "like Safari");
                                data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : "8");
                            } else {
                                layout && (layout[1] = "like Chrome");
                                data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
                            }
                            layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
                            if (name == "Safari" && (!version || parseInt(version) > 45)) {
                                version = data;
                            }
                        }
                        if (name == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
                            name += " ";
                            description.unshift("desktop mode");
                            if (data == "zvav") {
                                name += "Mini";
                                version = null;
                            } else {
                                name += "Mobile";
                            }
                            os = os.replace(RegExp(" *" + data + "$"), "");
                        } else if (name == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
                            description.unshift("desktop mode");
                            name = "Chrome Mobile";
                            version = null;
                            if (/\bOS X\b/.test(os)) {
                                manufacturer = "Apple";
                                os = "iOS 4.3+";
                            } else {
                                os = null;
                            }
                        }
                        if (version && version.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf("/" + data + "-") > -1) {
                            os = trim(os.replace(data, ""));
                        }
                        if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
                            (data = layout[layout.length - 1]) && description.push(data);
                        }
                        if (description.length) {
                            description = [ "(" + description.join("; ") + ")" ];
                        }
                        if (manufacturer && product && product.indexOf(manufacturer) < 0) {
                            description.push("on " + manufacturer);
                        }
                        if (product) {
                            description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
                        }
                        if (os) {
                            data = / ([\d.+]+)$/.exec(os);
                            isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
                            os = {
                                architecture: 32,
                                family: data && !isSpecialCasedOS ? os.replace(data[0], "") : os,
                                version: data ? data[1] : null,
                                toString: function() {
                                    var version = this.version;
                                    return this.family + (version && !isSpecialCasedOS ? " " + version : "") + (this.architecture == 64 ? " 64-bit" : "");
                                }
                            };
                        }
                        if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
                            if (os) {
                                os.architecture = 64;
                                os.family = os.family.replace(RegExp(" *" + data), "");
                            }
                            if (name && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
                                description.unshift("32-bit");
                            }
                        } else if (os && /^OS X/.test(os.family) && name == "Chrome" && parseFloat(version) >= 39) {
                            os.architecture = 64;
                        }
                        ua || (ua = null);
                        var platform = {};
                        platform.description = ua;
                        platform.layout = layout && layout[0];
                        platform.manufacturer = manufacturer;
                        platform.name = name;
                        platform.prerelease = prerelease;
                        platform.product = product;
                        platform.ua = ua;
                        platform.version = name && version;
                        platform.os = os || {
                            architecture: null,
                            family: null,
                            version: null,
                            toString: function() {
                                return "null";
                            }
                        };
                        platform.parse = parse;
                        platform.toString = toStringPlatform;
                        if (platform.version) {
                            description.unshift(version);
                        }
                        if (platform.name) {
                            description.unshift(name);
                        }
                        if (os && name && !(os == String(os).split(" ")[0] && (os == name.split(" ")[0] || product))) {
                            description.push(product ? "(" + os + ")" : "on " + os);
                        }
                        if (description.length) {
                            platform.description = description.join(" ");
                        }
                        return platform;
                    }
                    var platform = parse();
                    // [OT] Rename the local "define" function to "localDefine"
                    //      to prevent r.js from namespacing it to "csui.define".
                    if (typeof localDefine == "function" && typeof localDefine.amd == "object" && localDefine.amd) {
                        root.platform = platform;
                        localDefine(function() {
                            return platform;
                        });
                    } else if (freeExports && freeModule) {
                        forOwn(platform, function(value, key) {
                            freeExports[key] = value;
                        });
                    } else {
                        root.platform = platform;
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {} ]
    }, {}, [ 1 ])(1);

  // [OT] Remove the noConflict method.
  delete ally_js.noConflict;
  return ally_js;
});

/* =============================================================
 * bootstrap3-typeahead.js v3.1.0
 * https://github.com/bassjobsen/Bootstrap-3-Typeahead
 * =============================================================
 * Original written by @mdo and @fat
 * =============================================================
 * Copyright 2014 Bass Jobsen @bassjobsen
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */

/* =============================================================
 * Changes:
 *  - changed 'jquery' constant to 'csui/lib/jquery'.
 *  - changed 'worker' to handle 'source' functions returning a promise.
 *  - changed 'show' to support perfect-scrollbar in case the plugin is
 *    available and it is configured to use. Therefore additional library
 *    options are introduced
 *     - prettyScrolling: Flag whether to render a perfect-scrollbar or not.
 *     - scrollContainer: The perfect-scrollbar container element.
 *     - scrollContainerHeight: The maximum height of the scroll container.
 *     - currentHighlighter : to handle actions on current active element.
 *     - nextHighlighter : to handle actions on next active element.
 */

csui.define('csui/lib/bootstrap3-typeahead',['csui/lib/jquery'], function ($) {
  'use strict';
  // jshint laxcomma: true

  /* TYPEAHEAD PUBLIC CLASS DEFINITION
   * ================================= */

  var Typeahead = function (element, options) {
    this.$element = $(element);
    this.scrollContainerHeight = !!options.scrollContainerHeight;
    this.options = $.extend({}, $.fn.typeahead.defaults, options);
    this.matcher = this.options.matcher || this.matcher;
    this.sorter = this.options.sorter || this.sorter;
    this.select = this.options.select || this.select;
    this.autoSelect = typeof this.options.autoSelect == 'boolean' ? this.options.autoSelect : true;
    this.highlighter = this.options.highlighter || this.highlighter;
    this.render = this.options.render || this.render;
    this.updater = this.options.updater || this.updater;
    this.displayText = this.options.displayText || this.displayText;
    this.source = this.options.source;
    this.delay = this.options.delay;
    this.$menu = $(this.options.menu);
    this.options.pickerListId && this.$menu.attr('id', options.pickerListId);
    this.options.pickerListClass && this.$menu.addClass(this.options.pickerListClass);
    this.$appendTo = this.options.appendTo ? $(this.options.appendTo) : null;
    this.shown = false;
    this.blur = this.options.blur || this.blur;
    this.focus = this.options.focus || this.focus;
    this.listen();
    this.showHintOnFocus = typeof this.options.showHintOnFocus == 'boolean' || this.options.showHintOnFocus === 'all' ? this.options.showHintOnFocus : false;
    this.afterSelect = this.options.afterSelect;
    this.currentHighlighter = this.options.currentHighlighter;
    this.nextHighlighter = this.options.nextHighlighter;
    this.accessibility = this.options.accessibility;
    this.addItem = false;
    // perfect-scrollbar support
    this.prettyScrolling = ($.isFunction($.fn.perfectScrollbar) && this.options.prettyScrolling);
    this.$scrollContainer = this.options.scrollContainer ? $(this.options.scrollContainer) : this.$menu;
    this.handleNoResults = !!this.options.handleNoResults;
    this.emptyTemplate = (!!this.handleNoResults && !!this.options.emptyTemplate) ?
                         this.options.emptyTemplate : "";
    if (this.handleNoResults) {
      this.dataFound = false;
    }
    if (this.options.showMore) {
      this.options.rollOver = false;
    }
  };

  Typeahead.prototype = {

    constructor: Typeahead,

    select: function () {
      var val = this.$menu.find('.binf-active').data('value');
      this.$element.data('active', val);
      if (this.autoSelect || val) {
        var newVal = this.updater(val);
        this.$element
            .val(this.displayText(newVal) || newVal)
            .trigger('change');
        this.afterSelect(newVal);
      }
      return this.hide();
    },

    updater: function (item) {
      return item;
    },

    setSource: function (source) {
      this.source = source;
    },

    show: function () {
      var pos = $.extend({}, this.$element.position(), {
        height: this.$element.outerHeight()
      }), scrollHeight;

      scrollHeight = typeof this.options.scrollHeight == 'function' ?
                     this.options.scrollHeight.call() :
                     this.options.scrollHeight;

        this.$appendTo = this.$appendTo
            ? this.$scrollContainer.appendTo(this.$appendTo)
            : this.$scrollContainer.insertAfter(this.$element);

      if (this.options.beforeShow) {
        this.options.beforeShow(this);
      }

      (this.$appendTo ? this.$menu.appendTo(this.$appendTo) : this.$menu.insertAfter(this.$element))
          .css({
            top: pos.top + pos.height + scrollHeight
            , left: pos.left
          })
          .show();

      if (this.$scrollContainer[0]!==this.$menu[0]) {
        this.$scrollContainer.show();
      }

      var scrollContainerHeight, scrollBorderPadding, scrollContentHeight;
      var heights = [], height;
      if (this.options.showMore && this.allItems) {
        // menu contains items for first page, use this as scroll container height.
        this.$scrollContainer.css("height","auto");
        this.scrollItemsHeight = this.$scrollContainer.outerHeight();
        this.$menu.html(this.allItems);
        delete this.allItems;
      }
      this.scrollItemsHeight && heights.push(this.scrollItemsHeight);

      if (this.scrollContainerHeight || !(this.options.showMore && this.options.items>0)) {
        scrollContainerHeight = isNaN(this.options.scrollContainerHeight) ? undefined : this.options.scrollContainerHeight-0;
        if (scrollContainerHeight) {
          heights.push(scrollContainerHeight);
        } else if (this.options.scrollContainerHeight!=="auto") {
          this.$scrollContainer.css("height", this.options.scrollContainerHeight);
          height = this.$scrollContainer.outerHeight();
        }
      }

      if (heights.length>0 || height) {
        scrollBorderPadding = this.$scrollContainer.outerHeight() - this.$scrollContainer.height();
        scrollContentHeight = contentHeight.call(this);
        heights.push(scrollContentHeight+scrollBorderPadding);
        scrollContainerHeight = heights.length===1 ? heights[0] : Math.min.apply(Math,heights);
        if (!height || scrollContainerHeight<height) {
          this.$scrollContainer.css("height", scrollContainerHeight);
        }
      }

      // perfect-scrollbar support
      var scrollYMarginOffset = this.prettyScrolling ? 15 : 0;
      if (this.prettyScrolling) {
        this.$scrollContainer.perfectScrollbar({
          suppressScrollX: true,
          scrollYMarginOffset: scrollYMarginOffset
        });
      }

      if (this.prettyScrolling || this.options.showMore) {
        !this.processMore && this.$scrollContainer.scrollTop(0);
      }

      this.shown = true;

      if (this.options.afterShow) {
        this.options.afterShow(this);
      }

      if (this.options.showMore) {
        scrollContentHeight = contentHeight.call(this);
        scrollContainerHeight = this.$scrollContainer.outerHeight();
        scrollBorderPadding = scrollContainerHeight - this.$scrollContainer.height();
        if (scrollContainerHeight-scrollBorderPadding+scrollYMarginOffset>=scrollContentHeight) {
          if (this.options.showMore && this.options.showMore()) {
            // force a scrollbar
            $('<li class="typeahead-force-scrollbar"></li>').appendTo(this.$menu).css({
              'background-color': 'transparent',
              'height': scrollYMarginOffset + 1
            });
            this.prettyScrolling && this.$scrollContainer.perfectScrollbar("update");
          }
        }
      }

      return this;
    },

    hide: function () {

      this.$scrollContainer.hide();
      if (this.$scrollContainer[0]!==this.$menu[0]) {
        this.$menu.hide();
      }
      this.shown = false;
      return this;
    },

    lookup: function (query) {
      if (typeof(query) != 'undefined' && query !== null) {
        this.query = query;
      } else {
        this.query = this.$element.val() || '';
      }

      if (this.query.length < this.options.minLength) {
        return this.shown ? this.hide() : this;
      }

      var worker = $.proxy(function () {
        var that = this;

        // don't call source callback with too short query, when user types fast.
        if (this.query.length < this.options.minLength) {
          return;
        }
        if ($.isFunction(this.source)) {
          $.when(this.source(this.query, $.proxy(this.process, this))).done(function (items) {
            that.process(items);
          });
        } else if (this.source) {
          this.process(this.source);
        }
      }, this);

      clearTimeout(this.lookupWorker);
      this.lookupWorker = setTimeout(worker, this.delay);
    },

    process: function (items) {
      this.dataFound = true;
      var that = this;

      items = $.grep(items, function (item) {
        return that.matcher(item);
      });
      if (items.length === 0 && this.handleNoResults) {
        this.dataFound = false;
        return this.renderNoResults().show();
      }

      items = this.sorter(items);

      if (!items.length && !this.options.addItem) {
        return this.shown ? this.hide() : this;
      }

      if (items.length > 0) {
        this.$element.data('active', items[0]);
      } else {
        this.$element.data('active', null);
      }

      // Add item
      if (this.options.addItem) {
        items.push(this.options.addItem);
      }

      if (this.options.items == 'all' || this.options.showMore) {
        return this.render(items).show();
      } else {
        return this.render(items.slice(0, this.options.items)).show();
      }
    },

    matcher: function (item) {
      var it = this.displayText(item);
      return ~it.toLowerCase().indexOf(this.query.toLowerCase());
    },

    sorter: function (items) {
      var beginswith        = []
          , caseSensitive   = []
          , caseInsensitive = []
          , item;

      while ((item = items.shift())) {
        var it = this.displayText(item);
        if (!it.toLowerCase().indexOf(this.query.toLowerCase())) {
          beginswith.push(item);
        } else if (~it.indexOf(this.query)) {
          caseSensitive.push(item);
        } else {
          caseInsensitive.push(item);
        }
      }

      return beginswith.concat(caseSensitive, caseInsensitive);
    },

    highlighter: function (item) {
      var html = $('<div></div>');
      var query = this.query;
      var i = item.toLowerCase().indexOf(query.toLowerCase());
      var len, leftPart, middlePart, rightPart, strong;
      len = query.length;
      if (len === 0) {
        return html.text(item).html();
      }
      while (i > -1) {
        leftPart = item.substr(0, i);
        middlePart = item.substr(i, len);
        rightPart = item.substr(i + len);
        strong = $('<strong></strong>').text(middlePart);
        html
            .append(document.createTextNode(leftPart))
            .append(strong);
        item = rightPart;
        i = item.toLowerCase().indexOf(query.toLowerCase());
      }
      return html.append(document.createTextNode(item)).html();
    },

    render: function (items) {
      var that = this;
      var self = this;
      var activeFound = false;
      var limited = [];
      items = $(items).map(function (i, item) {
        function create_item(){
          i = $(that.options.item).data('value', item);
          i.find('a').html(that.highlighter(text));
          i.attr("id", "user-item" + item.cid);
          if (text == self.$element.val()) {
            i.addClass('binf-active');
            self.$element.data('active', item);
            activeFound = true;
          }
        }
        var text = self.displayText(item);
        create_item();
        if (self.options.showMore && !self.scrollItemsHeight && self.options.items>0) {
          if (limited.length<self.options.items) {
            limited.push(i[0]);
            create_item();
          }
        }
        return i[0];
      });

      if (this.autoSelect && !activeFound) {
        items.first().addClass('binf-active');
        this.$element.data('active', items.first().data('value'));
      }
      if (this.options.items>0 && limited.length===this.options.items) {
        this.allItems = items;
        this.$menu.html(limited);
      } else {
        delete this.allItems;
        this.$menu.html(items);
      }
      this.nextHighlighter(items.first());
      return this;
    },

    renderNoResults: function () {
      this.$menu.html(this.emptyTemplate).addClass("csui-no-results-wrapper");
      return this;
    },

    displayText: function (item) {
      return item.name || item;
    },

    next: function (event) {
      var active = this.$menu.find('.binf-active')
          , next = active.next();

      if (!next.length) {
        if (active.length && !this.options.rollOver && this.shown) {
          return;
        }
        next = $(this.$menu.find('li')[0]);
      }

      active.removeClass('binf-active');
      this.currentHighlighter(active);
      this.accessibility && this.accessibility(next);
      next.addClass('binf-active');
      this.scrollIntoView(next[0],event);
      this.nextHighlighter(next);
    },

    prev: function (event) {
      var active = this.$menu.find('.binf-active')
          , prev = active.prev();

      if (!prev.length) {
        if (!this.options.rollOver) {
          return;
        }
        prev = this.$menu.find('li').last();
      }

      active.removeClass('binf-active');
      this.currentHighlighter(active);
      this.accessibility && this.accessibility(prev);
      prev.addClass('binf-active');
      this.scrollIntoView(prev[0],event);
      this.nextHighlighter(prev);
    },

    forward: function (event) {

      function nextPageIndex(menuItems,index) {
        if (index>=menuItems.length-1) {
          return undefined;
        }
        var top = topPos(menuItems,index);
        var scrollContainerHeight = this.$scrollContainer.height();
        for (var ii = index+1; ii<menuItems.length; ii++) {
          var bottom = bottomPos(menuItems,ii);
          if (bottom-scrollContainerHeight>top) {
            ii--;
            break;
          } else if (ii+1>=menuItems.length) {
            return undefined;
          } else if (bottom-scrollContainerHeight===top) {
            break;
          }
        }
        if (ii<=index) {
          ii = index + 1;
        }
        if (ii<menuItems.length) {
          return ii;
        }
        return undefined;
      }

      function checkForward(active,index) {
        var menuItems = this.$menu.find("li:not(.typeahead-force-scrollbar)");
        var newIndex = nextPageIndex.call(this,menuItems,index);
        if (newIndex==null) {
          if (this.options.showMore && this.options.showMore()) {
            if ($.isFunction(this.source)) {
              this.source(this.query,$.proxy(processForward, this, index),{more:true}).then(function (items) {
                processForward.call(this,index,items);
              }.bind(this));
              return;
            } else if (this.source) {
              processForward.call(this,index,this.source);
            }
            return;
          }
          newIndex = menuItems.length - 1;
        }
        jumpForward.call(this,active,$(menuItems[newIndex]));
      }

      function processForward(index,items) {
        this.processMore = true;
        this.process(items);
        delete this.processMore;
        checkForward.call(this,this.$menu.find('.binf-active'),index);
      }

      function jumpForward(active,forward) {
        active.removeClass('binf-active');
        this.currentHighlighter(active);
        this.accessibility && this.accessibility(forward);
        forward.addClass('binf-active');
        this.scrollIntoView(forward[0],event);
        this.nextHighlighter(forward);
      }

      var active = this.$menu.find('.binf-active');
      if (!active.length) {
        jumpForward.call(this,active,$(this.$menu.find('li')[0]));
      } else {
        checkForward.call(this,active,this.$menu.find('li').index(active));
      }
    },

    backward: function (event) {

      function prevPageIndex(menuItems,index) {
        if (index<=0) {
          return undefined;
        }
        var bottom = bottomPos(menuItems,index);
        var scrollContainerHeight = this.$scrollContainer.height();
        for (var ii = index-1; ii>=0; ii--) {
          var top = topPos(menuItems,ii);
          if (bottom-scrollContainerHeight>top) {
            ii++;
            break;
          } else if (bottom-scrollContainerHeight===top) {
            break;
          }
        }
        if (ii>=index) {
          ii = index - 1;
        }
        if (ii>=0) {
          return ii;
        }
        return undefined;
      }

      var active = this.$menu.find('.binf-active');
      var backward;

      if (!active.length) {
        return;
      } else {
        var menuItems = this.$menu.find("li:not(.typeahead-force-scrollbar)");
        var index = menuItems.index(active);
        var newIndex = prevPageIndex.call(this,menuItems,index);
        if (newIndex==null) {
          newIndex = 0;
        }
        backward = $(menuItems[newIndex]);
      }

      active.removeClass('binf-active');
      this.currentHighlighter(active);
      this.accessibility && this.accessibility(backward);
      backward.addClass('binf-active');
      this.scrollIntoView(backward[0],event);
      this.nextHighlighter(backward);
    },

    first: function (event) {
      var active = this.$menu.find('.binf-active');
      var first = this.$menu.find('li').first();
      active.removeClass('binf-active');
      this.currentHighlighter(active);
      this.accessibility && this.accessibility(first);
      first.addClass('binf-active');
      this.scrollIntoView(first,event);
      this.nextHighlighter(first);
    },

    last: function (event) {
      var active = this.$menu.find('.binf-active');
      var last = this.$menu.find('li').last();
      active.removeClass('binf-active');
      this.currentHighlighter(active);
      this.accessibility && this.accessibility(last);
      last.addClass('binf-active');
      this.scrollIntoView(last,event);
      this.nextHighlighter(last);
    },

    listen: function () {
      this.$element
          .on('focus', $.proxy(this.focus, this))
          .on('blur', $.proxy(this.blur, this))
          .on('keypress', $.proxy(this.keypress, this))
          .on('keyup', $.proxy(this.keyup, this));

      if (this.eventSupported('keydown')) {
        this.$element.on('keydown', $.proxy(this.keydown, this));
      }

      this.$menu
          .on('click', $.proxy(this.click, this))
          .on('mouseenter', 'li', $.proxy(this.mouseenter, this))
          .on('mouseleave', 'li', $.proxy(this.mouseleave, this));
    },

    destroy: function () {
      this.$element.data('typeahead', null);
      this.$element.data('active', null);
      this.$element
          .off('focus')
          .off('blur')
          .off('keypress')
          .off('keyup');

      if (this.eventSupported('keydown')) {
        this.$element.off('keydown');
      }

      this.$menu.remove();
    },

    eventSupported: function (eventName) {
      var isSupported = eventName in this.$element;
      if (!isSupported) {
        this.$element.setAttribute(eventName, 'return;');
        isSupported = typeof this.$element[eventName] === 'function';
      }
      return isSupported;
    },

    move: function (e) {
      function handleKey() {
        if (!this.shown) {
          return;
        }
        
        // up arrow with the shiftKey (this is actually the left parenthesis)
        // down arrow with the shiftKey (this is actually the right parenthesis)
        if (e.shiftKey) {
          return;
        }
        e.preventDefault();
        return true;
      }

      switch (e.keyCode) {
      case 9: // tab
      case 13: // enter
      case 27: // escape
        this.shown && e.preventDefault();
        break;

      case 33: // page up
        handleKey.call(this) && this.backward(e);
        break;

      case 34: // page down
        handleKey.call(this) && this.forward(e);
        break;

      case 35: // last pos
        if (e.ctrlKey) {
          !this.shown && e.preventDefault();
          handleKey.call(this) && this.last(e);
        }
        break;

      case 36: // first pos
        if (e.ctrlKey) {
          !this.shown && e.preventDefault();
          handleKey.call(this) && this.first(e);
        }
        break;

      case 38: // up arrow
        handleKey.call(this) && this.prev(e);
        break;

      case 40: // down arrow
        handleKey.call(this) && this.next(e);
        break;
      }
    },

    keydown: function (e) {
      this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40, 38, 33, 34, 35, 36, 9, 13, 27]);
      if (!this.shown && e.keyCode == 40) {
        this.lookup();
      } else {
        this.move(e);
      }
    },

    keypress: function (e) {
      if (this.suppressKeyPressRepeat) {
        return;
      }
      this.move(e);
    },

    keyup: function (e) {
      switch (e.keyCode) {
      case 40: // down arrow
      case 39: // arrow right : Fix LPAD-95055 : with each ARROW RIGHT the user list flickers and the query is executed again
      case 38: // up arrow
      case 37: // arrow left : Fix LPAD-95055 : with each ARROW LEFT the user list flickers and the query is executed again
      case 36: // first pos
      case 35: // last pos
      case 34: // page down
      case 33: // page up
      case 16: // shift
      case 17: // ctrl
      case 18: // alt
        break;

      case 9: // tab
      case 13: // enter
        if (!this.shown) {
          return;
        }
        if (this.handleNoResults && !this.dataFound) {
          return;
        }
        this.select();
        break;

      case 27: // escape
        if (!this.shown) {
          return;
        }
        this.hide();
        break;
      case 116: // Refresh/F5. suppress menu being displayed in oversize.
      case 113: // F2 restricts to open dropdown
        return;
      default:
        this.lookup();
      }

      e.preventDefault();
    },

    focus: function (e) {    
      if (!this.focused) {
        this.focused = true;
        if (this.options.showHintOnFocus && this.skipShowHintOnFocus !== true) {
            if (this.options.showHintOnFocus === 'all') {
                this.lookup('');
            } else {
                this.lookup();
            }
        }
    }
    if (this.skipShowHintOnFocus) {
        this.skipShowHintOnFocus = false;
    }
    },

    blur: function (e) {
      this.focused = false;
      if (!this.mousedover && this.shown) {
        this.hide();
      }
    },

    click: function (e) {
      e.preventDefault();
      if(!!this.dataFound) {
        var clicked = (e.target && e.target.nodeName==="LI") ? e.target : $(e.target).parentsUntil(this.$menu,"li")[0];
        if (clicked) {
          this.currentHighlighter(this.$menu.find('.binf-active'));
          this.$menu.find('.binf-active').removeClass('binf-active');
          $(clicked).addClass('binf-active');
          this.nextHighlighter(this.$menu.find('.binf-active'));
        }
        this.skipShowHintOnFocus = true;
        this.select();
       this.$element[0].focus();
      } else {
        this.hide();
      }
    },

    mouseenter: function (e) {
      this.mousedover = true;
      if (this.scrollByKey) {
        // skip, if mouseenter is generated by a keyboard scroll.
        delete this.scrollByKey;
      } else {
        this.currentHighlighter(this.$menu.find('.binf-active'));
        this.$menu.find('.binf-active').removeClass('binf-active');
        $(e.currentTarget).addClass('binf-active');
        this.nextHighlighter(this.$menu.find('.binf-active'));
      }
    },

    mouseleave: function (e) {
      this.mousedover = false;
      if (!this.focused && this.shown) {
        this.hide();
      }
    },

    /**
     * scroll item into viewable area. if event is passed scroll is handled as triggered by keyboard.
     *
     * @param {*} item (mandatory) item to scroll into view
     * @param {*} keyEvent (optional) event used as marker to handle this scroll as tribbered by keyboard
     */
    scrollIntoView: function (item,keyEvent) {
      var currentItem         = this.$menu.find(item),
          parentScrollElement = this.$scrollContainer,
          currentItemHeight   = currentItem.outerHeight(),
          parentBorderTop     = parentScrollElement[0].clientTop,
          parentPaddingTop    = parseFloat(parentScrollElement.css("padding-top").replace('px',''))||0,
          parentSpaceTop      = parentBorderTop + parentPaddingTop,
          offSetVariation     = currentItem.offset().top - parentScrollElement.offset().top - parentSpaceTop,
          menuScrollTop       = parentScrollElement.scrollTop(),
          menuScrollHeight    = parentScrollElement.height();

      if (keyEvent) {
        var scrollByKey = this.scrollByKey = { keyEvent: keyEvent };
        setTimeout(function(){
          if (this.scrollByKey && this.scrollByKey===scrollByKey) {
            // autodelete keyEvent after timeout, to ensure clean-up, if mouseenter event is not triggered.
            delete this.scrollByKey;
          }
        }.bind(this),30);
      }

      // scroll more than needed to get some space between last item and bottom
      var offset = scrollMore(currentItem);
      if (offSetVariation < 0) {
        parentScrollElement.scrollTop(menuScrollTop + offSetVariation);
      } else if (offSetVariation + currentItemHeight + offset > menuScrollHeight) {
        parentScrollElement.scrollTop(
            menuScrollTop + offSetVariation + offset + currentItemHeight - menuScrollHeight
        );
      }
    }

  };

  function topPos(menuItems,index) {
    var top = $(menuItems[index]).offset().top + $(menuItems[index]).outerHeight() - scrollMore(menuItems[index]);
    return top;
  }

  function bottomPos(menuItems,index) {
    var bottom = $(menuItems[index]).offset().top + $(menuItems[index]).outerHeight();
    if (index+1<menuItems.length) {
      bottom += scrollMore(menuItems[index+1]);
    }
    return bottom;
  }
  function scrollMore(menuItem) {
    var outerHeight = $(menuItem).outerHeight();
    return Math.min(Math.max(2*$(menuItem).height()-outerHeight,0.4*outerHeight),32);
  }

  function contentHeight() {
    var sum;
    if (this.$scrollContainer[0]===this.$menu[0]) {
      sum = 0;
      this.$menu.find("li:not(.typeahead-force-scrollbar)").each(function (ix,el) {
        sum += $(el).outerHeight();
      });
    } else {
      sum = this.$menu.outerHeight() - (this.$menu.find("li.typeahead-force-scrollbar").outerHeight()||0);
    }
    return sum;
  }


  /* TYPEAHEAD PLUGIN DEFINITION
   * =========================== */

  var old = $.fn.typeahead;

  $.fn.typeahead = function (option) {
    var arg = arguments;
    if (typeof option == 'string' && option == 'getActive') {
      return this.data('active');
    }
    return this.each(function () {
      var $this     = $(this)
          , data    = $this.data('typeahead')
          , options = typeof option == 'object' && option;
      if (!data) {
        $this.data('typeahead', (data = new Typeahead(this, options)));
      }
      if (typeof option == 'string') {
        if (arg.length > 1) {
          data[option].apply(data, Array.prototype.slice.call(arg, 1));
        } else {
          data[option]();
        }
      }
    });
  };

  $.fn.typeahead.defaults = {
    source: []
    , items: 8
    , menu: '<ul class="typeahead binf-dropdown-menu" role="listbox" id="user-picker-ul"></ul>'
    , item: '<li role="option"><a href="#"></a></li>'
    , minLength: 1
    , scrollHeight: 0
    , autoSelect: true
    , afterSelect: $.noop
    , currentHighlighter: $.noop
    , nextHighlighter: $.noop
    , addItem: false
    , delay: 0
    // implement perfect-scrollbar support
    , prettyScrolling: false
    , scrollContainer: '<div class="typeahead scroll-container"></div>'
    , scrollContainerHeight: 320
    , rollOver: true
  };

  $.fn.typeahead.Constructor = Typeahead;

  /* TYPEAHEAD NO CONFLICT
   * =================== */

  $.fn.typeahead.noConflict = function () {
    $.fn.typeahead = old;
    return this;
  };

  /* TYPEAHEAD DATA-API
   * ================== */

  $(document).on('focus.typeahead.data-api', '[data-provide="typeahead"]', function (e) {
    var $this = $(this);
    if ($this.data('typeahead')) {
      return;
    }
    $this.typeahead($this.data());
  });

});

/*
 * jquery.mousehover 0.2.1
 * https://github.com/prantlf/jquery.mousehover
 *
 * Copyright (c) 2017 Ferdinand Prantl
 * Licensed under the MIT license.
 */

// [OT] Modifications done:
//
// * Replace UMD with csui AMD at the top and bottom of the file
// * Return the .fn function
// * Disclose iPad and iPhone from mousehover checks

// [OT] Declare a csui module
csui.define('csui/lib/jquery.mousehover',['csui/lib/jquery'], function($) {
  'use strict';

  // Remember the existing mousehover plugin, if there is any, to be able
  // to restore it by calling noConflict.
  var oldMousehover = $.fn.mousehover,
      eventTimeProperty;

  // Convert any combination of input parametrs to the parameters object,
  // which has the same structure and all values available.
  // Arguments:
  // .mousehover(handlerIn)
  // .mousehover(handlerIn, handlerOut)
  // .mousehover(handlerIn, options)
  // .mousehover(handlerIn, handlerOut, options)
  // .mousehover({handlerIn, handlerOut, options})
  // .mousehover('off')
  // .mousehover('off', options)
  // Result:
  // .handlerIn:  function
  // .handlerOut: function
  // .namespace:  string (empty or starting with '.')
  function normalizeParameters(handlerIn, handlerOut, options) {
    var namespace;
    if (typeof handlerIn === 'object') {
      return handlerIn;
    }
    // The first parameter has to be always present. Function handler,
    // string method name, or an object literal.
    if (!handlerIn) {
      throw new Error('Missing event handler or method.');
    }
    if (!options) {
      options = typeof handlerOut === 'object' ? handlerOut : {};
    }
    // Prepend '.' to allow simple concatenation of the namespace.
    namespace = options.namespace;
    namespace = namespace ? '.' + namespace : '';
    // There is just one method supported right now - "off". It will be
    // detected by the missing "handlerIn"" parameter.
    if (typeof handlerIn === 'string') {
      if (handlerIn !== 'off') {
        throw new Error('Unsupported method.')
      }
      return {
        namespace: namespace
      };
    }
    return {
      handlerIn: handlerIn,
      handlerOut: typeof handlerOut === 'function' ? handlerOut : handlerIn,
      namespace: namespace
    };
  }

  // [OT] Some taps on iPad were not detected as emulated. Not clear why.
  // There i no mouse on iPad today, avoid any mouse detection.
  if (navigator.userAgent.indexOf('iPad') > 0 ||
      navigator.userAgent.indexOf('iPhone') > 0) {
    // Do nothing on iOS.
    $.fn.mousehover = function (handlerIn, handlerOut, options) {
      return this;
    };
  // If the browser supports pointer events, we can detect mouse reliably.
  // } else if ('onpointerenter' in window ) {
  // [OT] Pointer events are not detected properly in BCW.
  // navigator.pointerEnabled is undefined in browsers where as in SAP BCW it is false.
  // Adding extra check to bypass pointer event binding in SAP BCW.
  } else if ('onpointerenter' in window && navigator.pointerEnabled !== false) {
    $.fn.mousehover = function (handlerIn, handlerOut, options) {
      var parameters = normalizeParameters(handlerIn, handlerOut, options),
          namespace = parameters.namespace;
      handlerIn = parameters.handlerIn;
      // Missing "handlerIn" parameter means, that existing event handlers
      // should be unregistered.
      if (!handlerIn) {
        return this.off('pointerenter' + namespace +
                        ' pointerleave' + namespace);
      }
      handlerOut = parameters.handlerOut;
      return this.on('pointerenter' + namespace, function (event) {
                   if (event.originalEvent.pointerType === 'mouse') {
                     handlerIn.call(this, event);
                   }
                 })
                 .on('pointerleave' + namespace, function (event) {
                   if (event.originalEvent.pointerType === 'mouse') {
                     handlerOut.call(this, event);
                   }
                 });
    };

  // If the browser has support for touch events, the mouseenter and
  // mouseleave events can be emulated on tapping the display.
  } else if ('ontouchstart' in window) {
    eventTimeProperty = 'mousehover-start';
    $.fn.mousehover = function (handlerIn, handlerOut, options) {
      var parameters = normalizeParameters(handlerIn, handlerOut, options),
          namespace = parameters.namespace;
      handlerIn = parameters.handlerIn;
      // Missing "handlerIn" parameter means, that existing event handlers
      // should be unregistered.
      if (!handlerIn) {
        return this.off('touchend' + namespace +
                        ' mouseenter' + namespace +
                        ' mouseleave' + namespace);
      }
      handlerOut = parameters.handlerOut;
      // Store the time of the event, which would shortly preceed the
      // mouseenter event on touch-capable devices, if it were an emulated
      // mouse event caused by tapping the display.
      return this.on('touchend' + namespace, function () {
                   $(this).data(eventTimeProperty, new Date().getTime());
                 })
                 // If the first event handler remembered its time and the
                 // mouseenter event comes too soon, it was triggered by
                 // tapping and should be ignored.
                 .on('mouseenter' + namespace, function (event) {
                   var $this = $(this),
                       once = $this.data(eventTimeProperty),
                       now;
                   if (once) {
                     now = new Date().getTime();
                     // The time interval between the touchend event, which
                     // can identify, that the mouseenter event was emulated,
                     // and the mouseenter event itself can vary.
                     if (now - once < 50) {
                       return $(this).removeData(eventTimeProperty);
                     }
                   }
                   // Enable handling of the complementary mouseleave event.
                   $(this).data(eventTimeProperty, true);
                   handlerIn.call(this, event);
                 })
                 // The mouseleave event should call the hover event handler
                 // only if it was triggered by the mouseenter event earlier.
                 .on('mouseleave' + namespace, function (event) {
                   var $this = $(this);
                   if ($this.data(eventTimeProperty)) {
                     $this.removeData(eventTimeProperty);
                     handlerOut.call(this, event);
                   }
                 });
    };

  // If the browser has no support for touch events, we can assume, that
  // the only device, which can trigger the mouseenter eveny, is the mouse.
  } else {
    // Default to jQuery.hover behaviour on devices without touch capability.
    $.fn.mousehover = function (handlerIn, handlerOut, options) {
      var parameters = normalizeParameters(handlerIn, handlerOut, options),
          namespace = parameters.namespace;
      handlerIn = parameters.handlerIn;
      // Missing "handlerIn" parameter means, that existing event handlers
      // should be unregistered.
      if (!handlerIn) {
        return this.off('mouseenter' + namespace +
                        ' mouseleave' + namespace);
      }
      handlerOut = parameters.handlerOut;
      return this.on('mouseenter' + namespace, handlerIn)
                 .on('mouseleave' + namespace, handlerOut);
    };
  }

  // Restores the earlier mousehover plugin, which had been registered in
  // jQuery before this one. This plugin is returned for explicit usage.
  $.fn.mousehover.noConflict = function () {
    $.fn.mousehover = oldMousehover;
    return this;
  };

  // [OT] Return the .fn function
  return $.fn.mousehover;
});

/*!
 * jquery.fancytree.js
 * Tree view control with support for lazy loading and much more.
 * https://github.com/mar10/fancytree/
 *
 * Copyright (c) 2008-2019, Martin Wendt (http://wwWendt.de)
 * Released under the MIT license
 * https://github.com/mar10/fancytree/wiki/LicenseInfo
 *
 * @version 2.30.2
 * @date 2019-01-13T08:17:01Z
 *
 * Changes done by OT:
 *  1. Changed scrollIntoView method to take care of "perfect scrolling" containers
 *  2. Change shortcut methods (e.g. focus) to use explicit "trigger" (to avoid JQmigrate warnings)
 */

/** Core Fancytree module.
 */

 // [OT] Use csui module names in the UMD wrapper
csui.define('csui/lib/fancytree/jquery.fancytree',[
	'csui/lib/jquery', 'csui/lib/jquery.ui/js/jquery-ui'
], function ($) {
	"use strict";

	// prevent duplicate loading
	if ($.ui && $.ui.fancytree) {
		$.ui.fancytree.warn("Fancytree: ignored duplicate include");
		return;
	}

	/******************************************************************************
	 * Private functions and variables
	 */

	var i,
		attr,
		FT = null, // initialized below
		TEST_IMG = new RegExp(/\.|\//), // strings are considered image urls if they contain '.' or '/'
		REX_HTML = /[&<>"'\/]/g, // Escape those characters
		REX_TOOLTIP = /[<>"'\/]/g, // Don't escape `&` in tooltips
		RECURSIVE_REQUEST_ERROR = "$recursive_request",
		ENTITY_MAP = {
			"&": "&amp;",
			"<": "&lt;",
			">": "&gt;",
			'"': "&quot;",
			"'": "&#39;",
			"/": "&#x2F;",
		},
		IGNORE_KEYCODES = { 16: true, 17: true, 18: true },
		SPECIAL_KEYCODES = {
			8: "backspace",
			9: "tab",
			10: "return",
			13: "return",
			// 16: null, 17: null, 18: null,  // ignore shift, ctrl, alt
			19: "pause",
			20: "capslock",
			27: "esc",
			32: "space",
			33: "pageup",
			34: "pagedown",
			35: "end",
			36: "home",
			37: "left",
			38: "up",
			39: "right",
			40: "down",
			45: "insert",
			46: "del",
			59: ";",
			61: "=",
			// 91: null, 93: null,  // ignore left and right meta
			96: "0",
			97: "1",
			98: "2",
			99: "3",
			100: "4",
			101: "5",
			102: "6",
			103: "7",
			104: "8",
			105: "9",
			106: "*",
			107: "+",
			109: "-",
			110: ".",
			111: "/",
			112: "f1",
			113: "f2",
			114: "f3",
			115: "f4",
			116: "f5",
			117: "f6",
			118: "f7",
			119: "f8",
			120: "f9",
			121: "f10",
			122: "f11",
			123: "f12",
			144: "numlock",
			145: "scroll",
			173: "-",
			186: ";",
			187: "=",
			188: ",",
			189: "-",
			190: ".",
			191: "/",
			192: "`",
			219: "[",
			220: "\\",
			221: "]",
			222: "'",
		},
		MODIFIERS = {
			16: "shift",
			17: "ctrl",
			18: "alt",
			91: "meta",
			93: "meta",
		},
		MOUSE_BUTTONS = { 0: "", 1: "left", 2: "middle", 3: "right" },
		// Boolean attributes that can be set with equivalent class names in the LI tags
		// Note: v2.23: checkbox and hideCheckbox are *not* in this list
		CLASS_ATTRS = "active expanded focus folder lazy radiogroup selected unselectable unselectableIgnore".split(
			" "
		),
		CLASS_ATTR_MAP = {},
		// Top-level Fancytree attributes, that can be set by dict
		TREE_ATTRS = "columns types".split(" "),
		// TREE_ATTR_MAP = {},
		// Top-level FancytreeNode attributes, that can be set by dict
		NODE_ATTRS = "checkbox expanded extraClasses folder icon iconTooltip key lazy partsel radiogroup refKey selected statusNodeType title tooltip type unselectable unselectableIgnore unselectableStatus".split(
			" "
		),
		NODE_ATTR_MAP = {},
		// Mapping of lowercase -> real name (because HTML5 data-... attribute only supports lowercase)
		NODE_ATTR_LOWERCASE_MAP = {},
		// Attribute names that should NOT be added to node.data
		NONE_NODE_DATA_MAP = {
			active: true,
			children: true,
			data: true,
			focus: true,
		};

	for (i = 0; i < CLASS_ATTRS.length; i++) {
		CLASS_ATTR_MAP[CLASS_ATTRS[i]] = true;
	}
	for (i = 0; i < NODE_ATTRS.length; i++) {
		attr = NODE_ATTRS[i];
		NODE_ATTR_MAP[attr] = true;
		if (attr !== attr.toLowerCase()) {
			NODE_ATTR_LOWERCASE_MAP[attr.toLowerCase()] = attr;
		}
	}
	// for(i=0; i<TREE_ATTRS.length; i++) {
	// 	TREE_ATTR_MAP[TREE_ATTRS[i]] = true;
	// }

	function _assert(cond, msg) {
		// TODO: see qunit.js extractStacktrace()
		if (!cond) {
			msg = msg ? ": " + msg : "";
			// consoleApply("assert", [!!cond, msg]);
			$.error("Fancytree assertion failed" + msg);
		}
	}

	_assert($.ui, "Fancytree requires jQuery UI (http://jqueryui.com)");

	function consoleApply(method, args) {
		var i,
			s,
			fn = window.console ? window.console[method] : null;

		if (fn) {
			try {
				fn.apply(window.console, args);
			} catch (e) {
				// IE 8?
				s = "";
				for (i = 0; i < args.length; i++) {
					s += args[i];
				}
				fn(s);
			}
		}
	}

	/* support: IE8 Polyfil for Date.now() */
	if (!Date.now) {
		Date.now = function now() {
			return new Date().getTime();
		};
	}

	/*Return true if x is a FancytreeNode.*/
	function _isNode(x) {
		return !!(x.tree && x.statusNodeType !== undefined);
	}

	/** Return true if dotted version string is equal or higher than requested version.
	 *
	 * See http://jsfiddle.net/mar10/FjSAN/
	 */
	function isVersionAtLeast(dottedVersion, major, minor, patch) {
		var i,
			v,
			t,
			verParts = $.map($.trim(dottedVersion).split("."), function(e) {
				return parseInt(e, 10);
			}),
			testParts = $.map(
				Array.prototype.slice.call(arguments, 1),
				function(e) {
					return parseInt(e, 10);
				}
			);

		for (i = 0; i < testParts.length; i++) {
			v = verParts[i] || 0;
			t = testParts[i] || 0;
			if (v !== t) {
				return v > t;
			}
		}
		return true;
	}

	/**
	 * Deep-merge a list of objects (but replace array-type options).
	 *
	 * jQuery's $.extend(true, ...) method does a deep merge, that also merges Arrays.
	 * This variant is used to merge extension defaults with user options, and should
	 * merge objects, but override arrays (for example the `triggerStart: [...]` option
	 * of ext-edit). Also `null` values are copied over and not skipped.
	 *
	 * See issue #876
	 *
	 * Example:
	 * _simpleDeepMerge({}, o1, o2);
	 */
	function _simpleDeepMerge() {
		var options,
			name,
			src,
			copy,
			clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length;

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !$.isFunction(target)) {
			target = {};
		}
		if (i === length) {
			throw "need at least two args";
		}
		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];
					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}
					// Recurse if we're merging plain objects
					// (NOTE: unlike $.extend, we don't merge arrays, but relace them)
					if (copy && $.isPlainObject(copy)) {
						clone = src && $.isPlainObject(src) ? src : {};
						// Never move original objects, clone them
						target[name] = _simpleDeepMerge(clone, copy);
						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}
		// Return the modified object
		return target;
	}

	/** Return a wrapper that calls sub.methodName() and exposes
	 *  this             : tree
	 *  this._local      : tree.ext.EXTNAME
	 *  this._super      : base.methodName.call()
	 *  this._superApply : base.methodName.apply()
	 */
	function _makeVirtualFunction(methodName, tree, base, extension, extName) {
		// $.ui.fancytree.debug("_makeVirtualFunction", methodName, tree, base, extension, extName);
		// if(rexTestSuper && !rexTestSuper.test(func)){
		//     // extension.methodName() doesn't call _super(), so no wrapper required
		//     return func;
		// }
		// Use an immediate function as closure
		var proxy = (function() {
			var prevFunc = tree[methodName], // org. tree method or prev. proxy
				baseFunc = extension[methodName], //
				_local = tree.ext[extName],
				_super = function() {
					return prevFunc.apply(tree, arguments);
				},
				_superApply = function(args) {
					return prevFunc.apply(tree, args);
				};

			// Return the wrapper function
			return function() {
				var prevLocal = tree._local,
					prevSuper = tree._super,
					prevSuperApply = tree._superApply;

				try {
					tree._local = _local;
					tree._super = _super;
					tree._superApply = _superApply;
					return baseFunc.apply(tree, arguments);
				} finally {
					tree._local = prevLocal;
					tree._super = prevSuper;
					tree._superApply = prevSuperApply;
				}
			};
		})(); // end of Immediate Function
		return proxy;
	}

	/**
	 * Subclass `base` by creating proxy functions
	 */
	function _subclassObject(tree, base, extension, extName) {
		// $.ui.fancytree.debug("_subclassObject", tree, base, extension, extName);
		for (var attrName in extension) {
			if (typeof extension[attrName] === "function") {
				if (typeof tree[attrName] === "function") {
					// override existing method
					tree[attrName] = _makeVirtualFunction(
						attrName,
						tree,
						base,
						extension,
						extName
					);
				} else if (attrName.charAt(0) === "_") {
					// Create private methods in tree.ext.EXTENSION namespace
					tree.ext[extName][attrName] = _makeVirtualFunction(
						attrName,
						tree,
						base,
						extension,
						extName
					);
				} else {
					$.error(
						"Could not override tree." +
							attrName +
							". Use prefix '_' to create tree." +
							extName +
							"._" +
							attrName
					);
				}
			} else {
				// Create member variables in tree.ext.EXTENSION namespace
				if (attrName !== "options") {
					tree.ext[extName][attrName] = extension[attrName];
				}
			}
		}
	}

	function _getResolvedPromise(context, argArray) {
		if (context === undefined) {
			return $.Deferred(function() {
				this.resolve();
			}).promise();
		} else {
			return $.Deferred(function() {
				this.resolveWith(context, argArray);
			}).promise();
		}
	}

	function _getRejectedPromise(context, argArray) {
		if (context === undefined) {
			return $.Deferred(function() {
				this.reject();
			}).promise();
		} else {
			return $.Deferred(function() {
				this.rejectWith(context, argArray);
			}).promise();
		}
	}

	function _makeResolveFunc(deferred, context) {
		return function() {
			deferred.resolveWith(context);
		};
	}

	function _getElementDataAsDict($el) {
		// Evaluate 'data-NAME' attributes with special treatment for 'data-json'.
		var d = $.extend({}, $el.data()),
			json = d.json;

		delete d.fancytree; // added to container by widget factory (old jQuery UI)
		delete d.uiFancytree; // added to container by widget factory

		if (json) {
			delete d.json;
			// <li data-json='...'> is already returned as object (http://api.jquery.com/data/#data-html5)
			d = $.extend(d, json);
		}
		return d;
	}

	function _escapeTooltip(s) {
		return ("" + s).replace(REX_TOOLTIP, function(s) {
			return ENTITY_MAP[s];
		});
	}

	// TODO: use currying
	function _makeNodeTitleMatcher(s) {
		s = s.toLowerCase();
		return function(node) {
			return node.title.toLowerCase().indexOf(s) >= 0;
		};
	}

	function _makeNodeTitleStartMatcher(s) {
		var reMatch = new RegExp("^" + s, "i");
		return function(node) {
			return reMatch.test(node.title);
		};
	}

	/******************************************************************************
	 * FancytreeNode
	 */

	/**
	 * Creates a new FancytreeNode
	 *
	 * @class FancytreeNode
	 * @classdesc A FancytreeNode represents the hierarchical data model and operations.
	 *
	 * @param {FancytreeNode} parent
	 * @param {NodeData} obj
	 *
	 * @property {Fancytree} tree The tree instance
	 * @property {FancytreeNode} parent The parent node
	 * @property {string} key Node id (must be unique inside the tree)
	 * @property {string} title Display name (may contain HTML)
	 * @property {object} data Contains all extra data that was passed on node creation
	 * @property {FancytreeNode[] | null | undefined} children Array of child nodes.<br>
	 *     For lazy nodes, null or undefined means 'not yet loaded'. Use an empty array
	 *     to define a node that has no children.
	 * @property {boolean} expanded Use isExpanded(), setExpanded() to access this property.
	 * @property {string} extraClasses Additional CSS classes, added to the node's `&lt;span>`.<br>
	 *     Note: use `node.add/remove/toggleClass()` to modify.
	 * @property {boolean} folder Folder nodes have different default icons and click behavior.<br>
	 *     Note: Also non-folders may have children.
	 * @property {string} statusNodeType null for standard nodes. Otherwise type of special system node: 'error', 'loading', 'nodata', or 'paging'.
	 * @property {boolean} lazy True if this node is loaded on demand, i.e. on first expansion.
	 * @property {boolean} selected Use isSelected(), setSelected() to access this property.
	 * @property {string} tooltip Alternative description used as hover popup
	 * @property {string} iconTooltip Description used as hover popup for icon. @since 2.27
	 * @property {string} type Node type, used with tree.types map. @since 2.27
	 */
	function FancytreeNode(parent, obj) {
		var i, l, name, cl;

		this.parent = parent;
		this.tree = parent.tree;
		this.ul = null;
		this.li = null; // <li id='key' ftnode=this> tag
		this.statusNodeType = null; // if this is a temp. node to display the status of its parent
		this._isLoading = false; // if this node itself is loading
		this._error = null; // {message: '...'} if a load error occurred
		this.data = {};

		// TODO: merge this code with node.toDict()
		// copy attributes from obj object
		for (i = 0, l = NODE_ATTRS.length; i < l; i++) {
			name = NODE_ATTRS[i];
			this[name] = obj[name];
		}
		// unselectableIgnore and unselectableStatus imply unselectable
		if (
			this.unselectableIgnore != null ||
			this.unselectableStatus != null
		) {
			this.unselectable = true;
		}
		if (obj.hideCheckbox) {
			$.error(
				"'hideCheckbox' node option was removed in v2.23.0: use 'checkbox: false'"
			);
		}
		// node.data += obj.data
		if (obj.data) {
			$.extend(this.data, obj.data);
		}
		// Copy all other attributes to this.data.NAME
		for (name in obj) {
			if (
				!NODE_ATTR_MAP[name] &&
				!$.isFunction(obj[name]) &&
				!NONE_NODE_DATA_MAP[name]
			) {
				// node.data.NAME = obj.NAME
				this.data[name] = obj[name];
			}
		}

		// Fix missing key
		if (this.key == null) {
			// test for null OR undefined
			if (this.tree.options.defaultKey) {
				this.key = this.tree.options.defaultKey(this);
				_assert(this.key, "defaultKey() must return a unique key");
			} else {
				this.key = "_" + FT._nextNodeKey++;
			}
		} else {
			this.key = "" + this.key; // Convert to string (#217)
		}

		// Fix tree.activeNode
		// TODO: not elegant: we use obj.active as marker to set tree.activeNode
		// when loading from a dictionary.
		if (obj.active) {
			_assert(
				this.tree.activeNode === null,
				"only one active node allowed"
			);
			this.tree.activeNode = this;
		}
		if (obj.selected) {
			// #186
			this.tree.lastSelectedNode = this;
		}
		// TODO: handle obj.focus = true

		// Create child nodes
		cl = obj.children;
		if (cl) {
			if (cl.length) {
				this._setChildren(cl);
			} else {
				// if an empty array was passed for a lazy node, keep it, in order to mark it 'loaded'
				this.children = this.lazy ? [] : null;
			}
		} else {
			this.children = null;
		}
		// Add to key/ref map (except for root node)
		//	if( parent ) {
		this.tree._callHook("treeRegisterNode", this.tree, true, this);
		//	}
	}

	FancytreeNode.prototype = /** @lends FancytreeNode# */ {
		/* Return the direct child FancytreeNode with a given key, index. */
		_findDirectChild: function(ptr) {
			var i,
				l,
				cl = this.children;

			if (cl) {
				if (typeof ptr === "string") {
					for (i = 0, l = cl.length; i < l; i++) {
						if (cl[i].key === ptr) {
							return cl[i];
						}
					}
				} else if (typeof ptr === "number") {
					return this.children[ptr];
				} else if (ptr.parent === this) {
					return ptr;
				}
			}
			return null;
		},
		// TODO: activate()
		// TODO: activateSilently()
		/* Internal helper called in recursive addChildren sequence.*/
		_setChildren: function(children) {
			_assert(
				children && (!this.children || this.children.length === 0),
				"only init supported"
			);
			this.children = [];
			for (var i = 0, l = children.length; i < l; i++) {
				this.children.push(new FancytreeNode(this, children[i]));
			}
		},
		/**
		 * Append (or insert) a list of child nodes.
		 *
		 * @param {NodeData[]} children array of child node definitions (also single child accepted)
		 * @param {FancytreeNode | string | Integer} [insertBefore] child node (or key or index of such).
		 *     If omitted, the new children are appended.
		 * @returns {FancytreeNode} first child added
		 *
		 * @see FancytreeNode#applyPatch
		 */
		addChildren: function(children, insertBefore) {
			var i,
				l,
				pos,
				origFirstChild = this.getFirstChild(),
				origLastChild = this.getLastChild(),
				firstNode = null,
				nodeList = [];

			if ($.isPlainObject(children)) {
				children = [children];
			}
			if (!this.children) {
				this.children = [];
			}
			for (i = 0, l = children.length; i < l; i++) {
				nodeList.push(new FancytreeNode(this, children[i]));
			}
			firstNode = nodeList[0];
			if (insertBefore == null) {
				this.children = this.children.concat(nodeList);
			} else {
				// Returns null if insertBefore is not a direct child:
				insertBefore = this._findDirectChild(insertBefore);
				pos = $.inArray(insertBefore, this.children);
				_assert(pos >= 0, "insertBefore must be an existing child");
				// insert nodeList after children[pos]
				this.children.splice.apply(
					this.children,
					[pos, 0].concat(nodeList)
				);
			}
			if (origFirstChild && !insertBefore) {
				// #708: Fast path -- don't render every child of root, just the new ones!
				// #723, #729: but only if it's appended to an existing child list
				for (i = 0, l = nodeList.length; i < l; i++) {
					nodeList[i].render(); // New nodes were never rendered before
				}
				// Adjust classes where status may have changed
				// Has a first child
				if (origFirstChild !== this.getFirstChild()) {
					// Different first child -- recompute classes
					origFirstChild.renderStatus();
				}
				if (origLastChild !== this.getLastChild()) {
					// Different last child -- recompute classes
					origLastChild.renderStatus();
				}
			} else if (!this.parent || this.parent.ul || this.tr) {
				// render if the parent was rendered (or this is a root node)
				this.render();
			}
			if (this.tree.options.selectMode === 3) {
				this.fixSelection3FromEndNodes();
			}
			this.triggerModifyChild(
				"add",
				nodeList.length === 1 ? nodeList[0] : null
			);
			return firstNode;
		},
		/**
		 * Add class to node's span tag and to .extraClasses.
		 *
		 * @param {string} className class name
		 *
		 * @since 2.17
		 */
		addClass: function(className) {
			return this.toggleClass(className, true);
		},
		/**
		 * Append or prepend a node, or append a child node.
		 *
		 * This a convenience function that calls addChildren()
		 *
		 * @param {NodeData} node node definition
		 * @param {string} [mode=child] 'before', 'after', 'firstChild', or 'child' ('over' is a synonym for 'child')
		 * @returns {FancytreeNode} new node
		 */
		addNode: function(node, mode) {
			if (mode === undefined || mode === "over") {
				mode = "child";
			}
			switch (mode) {
				case "after":
					return this.getParent().addChildren(
						node,
						this.getNextSibling()
					);
				case "before":
					return this.getParent().addChildren(node, this);
				case "firstChild":
					// Insert before the first child if any
					var insertBefore = this.children ? this.children[0] : null;
					return this.addChildren(node, insertBefore);
				case "child":
				case "over":
					return this.addChildren(node);
			}
			_assert(false, "Invalid mode: " + mode);
		},
		/**Add child status nodes that indicate 'More...', etc.
		 *
		 * This also maintains the node's `partload` property.
		 * @param {boolean|object} node optional node definition. Pass `false` to remove all paging nodes.
		 * @param {string} [mode='child'] 'child'|firstChild'
		 * @since 2.15
		 */
		addPagingNode: function(node, mode) {
			var i, n;

			mode = mode || "child";
			if (node === false) {
				for (i = this.children.length - 1; i >= 0; i--) {
					n = this.children[i];
					if (n.statusNodeType === "paging") {
						this.removeChild(n);
					}
				}
				this.partload = false;
				return;
			}
			node = $.extend(
				{
					title: this.tree.options.strings.moreData,
					statusNodeType: "paging",
					icon: false,
				},
				node
			);
			this.partload = true;
			return this.addNode(node, mode);
		},
		/**
		 * Append new node after this.
		 *
		 * This a convenience function that calls addNode(node, 'after')
		 *
		 * @param {NodeData} node node definition
		 * @returns {FancytreeNode} new node
		 */
		appendSibling: function(node) {
			return this.addNode(node, "after");
		},
		/**
		 * Modify existing child nodes.
		 *
		 * @param {NodePatch} patch
		 * @returns {$.Promise}
		 * @see FancytreeNode#addChildren
		 */
		applyPatch: function(patch) {
			// patch [key, null] means 'remove'
			if (patch === null) {
				this.remove();
				return _getResolvedPromise(this);
			}
			// TODO: make sure that root node is not collapsed or modified
			// copy (most) attributes to node.ATTR or node.data.ATTR
			var name,
				promise,
				v,
				IGNORE_MAP = { children: true, expanded: true, parent: true }; // TODO: should be global

			for (name in patch) {
				v = patch[name];
				if (!IGNORE_MAP[name] && !$.isFunction(v)) {
					if (NODE_ATTR_MAP[name]) {
						this[name] = v;
					} else {
						this.data[name] = v;
					}
				}
			}
			// Remove and/or create children
			if (patch.hasOwnProperty("children")) {
				this.removeChildren();
				if (patch.children) {
					// only if not null and not empty list
					// TODO: addChildren instead?
					this._setChildren(patch.children);
				}
				// TODO: how can we APPEND or INSERT child nodes?
			}
			if (this.isVisible()) {
				this.renderTitle();
				this.renderStatus();
			}
			// Expand collapse (final step, since this may be async)
			if (patch.hasOwnProperty("expanded")) {
				promise = this.setExpanded(patch.expanded);
			} else {
				promise = _getResolvedPromise(this);
			}
			return promise;
		},
		/** Collapse all sibling nodes.
		 * @returns {$.Promise}
		 */
		collapseSiblings: function() {
			return this.tree._callHook("nodeCollapseSiblings", this);
		},
		/** Copy this node as sibling or child of `node`.
		 *
		 * @param {FancytreeNode} node source node
		 * @param {string} [mode=child] 'before' | 'after' | 'child'
		 * @param {Function} [map] callback function(NodeData) that could modify the new node
		 * @returns {FancytreeNode} new
		 */
		copyTo: function(node, mode, map) {
			return node.addNode(this.toDict(true, map), mode);
		},
		/** Count direct and indirect children.
		 *
		 * @param {boolean} [deep=true] pass 'false' to only count direct children
		 * @returns {int} number of child nodes
		 */
		countChildren: function(deep) {
			var cl = this.children,
				i,
				l,
				n;
			if (!cl) {
				return 0;
			}
			n = cl.length;
			if (deep !== false) {
				for (i = 0, l = n; i < l; i++) {
					n += cl[i].countChildren();
				}
			}
			return n;
		},
		// TODO: deactivate()
		/** Write to browser console if debugLevel >= 4 (prepending node info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		debug: function(msg) {
			if (this.tree.options.debugLevel >= 4) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("log", arguments);
			}
		},
		/** Deprecated.
		 * @deprecated since 2014-02-16. Use resetLazy() instead.
		 */
		discard: function() {
			this.warn(
				"FancytreeNode.discard() is deprecated since 2014-02-16. Use .resetLazy() instead."
			);
			return this.resetLazy();
		},
		/** Remove DOM elements for all descendents. May be called on .collapse event
		 * to keep the DOM small.
		 * @param {boolean} [includeSelf=false]
		 */
		discardMarkup: function(includeSelf) {
			var fn = includeSelf ? "nodeRemoveMarkup" : "nodeRemoveChildMarkup";
			this.tree._callHook(fn, this);
		},
		/** Write error to browser console if debugLevel >= 1 (prepending tree info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		error: function(msg) {
			if (this.options.debugLevel >= 1) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("error", arguments);
			}
		},
		/**Find all nodes that match condition (excluding self).
		 *
		 * @param {string | function(node)} match title string to search for, or a
		 *     callback function that returns `true` if a node is matched.
		 * @returns {FancytreeNode[]} array of nodes (may be empty)
		 */
		findAll: function(match) {
			match = $.isFunction(match) ? match : _makeNodeTitleMatcher(match);
			var res = [];
			this.visit(function(n) {
				if (match(n)) {
					res.push(n);
				}
			});
			return res;
		},
		/**Find first node that matches condition (excluding self).
		 *
		 * @param {string | function(node)} match title string to search for, or a
		 *     callback function that returns `true` if a node is matched.
		 * @returns {FancytreeNode} matching node or null
		 * @see FancytreeNode#findAll
		 */
		findFirst: function(match) {
			match = $.isFunction(match) ? match : _makeNodeTitleMatcher(match);
			var res = null;
			this.visit(function(n) {
				if (match(n)) {
					res = n;
					return false;
				}
			});
			return res;
		},
		/* Apply selection state (internal use only) */
		_changeSelectStatusAttrs: function(state) {
			var changed = false,
				opts = this.tree.options,
				unselectable = FT.evalOption(
					"unselectable",
					this,
					this,
					opts,
					false
				),
				unselectableStatus = FT.evalOption(
					"unselectableStatus",
					this,
					this,
					opts,
					undefined
				);

			if (unselectable && unselectableStatus != null) {
				state = unselectableStatus;
			}
			switch (state) {
				case false:
					changed = this.selected || this.partsel;
					this.selected = false;
					this.partsel = false;
					break;
				case true:
					changed = !this.selected || !this.partsel;
					this.selected = true;
					this.partsel = true;
					break;
				case undefined:
					changed = this.selected || !this.partsel;
					this.selected = false;
					this.partsel = true;
					break;
				default:
					_assert(false, "invalid state: " + state);
			}
			// this.debug("fixSelection3AfterLoad() _changeSelectStatusAttrs()", state, changed);
			if (changed) {
				this.renderStatus();
			}
			return changed;
		},
		/**
		 * Fix selection status, after this node was (de)selected in multi-hier mode.
		 * This includes (de)selecting all children.
		 */
		fixSelection3AfterClick: function(callOpts) {
			var flag = this.isSelected();

			//		this.debug("fixSelection3AfterClick()");

			this.visit(function(node) {
				node._changeSelectStatusAttrs(flag);
			});
			this.fixSelection3FromEndNodes(callOpts);
		},
		/**
		 * Fix selection status for multi-hier mode.
		 * Only end-nodes are considered to update the descendants branch and parents.
		 * Should be called after this node has loaded new children or after
		 * children have been modified using the API.
		 */
		fixSelection3FromEndNodes: function(callOpts) {
			var opts = this.tree.options;

			//		this.debug("fixSelection3FromEndNodes()");
			_assert(opts.selectMode === 3, "expected selectMode 3");

			// Visit all end nodes and adjust their parent's `selected` and `partsel`
			// attributes. Return selection state true, false, or undefined.
			function _walk(node) {
				var i,
					l,
					child,
					s,
					state,
					allSelected,
					someSelected,
					unselIgnore,
					unselState,
					children = node.children;

				if (children && children.length) {
					// check all children recursively
					allSelected = true;
					someSelected = false;

					for (i = 0, l = children.length; i < l; i++) {
						child = children[i];
						// the selection state of a node is not relevant; we need the end-nodes
						s = _walk(child);
						// if( !child.unselectableIgnore ) {
						unselIgnore = FT.evalOption(
							"unselectableIgnore",
							child,
							child,
							opts,
							false
						);
						if (!unselIgnore) {
							if (s !== false) {
								someSelected = true;
							}
							if (s !== true) {
								allSelected = false;
							}
						}
					}
					state = allSelected
						? true
						: someSelected
							? undefined
							: false;
				} else {
					// This is an end-node: simply report the status
					unselState = FT.evalOption(
						"unselectableStatus",
						node,
						node,
						opts,
						undefined
					);
					state = unselState == null ? !!node.selected : !!unselState;
				}
				node._changeSelectStatusAttrs(state);
				return state;
			}
			_walk(this);

			// Update parent's state
			this.visitParents(function(node) {
				var i,
					l,
					child,
					state,
					unselIgnore,
					unselState,
					children = node.children,
					allSelected = true,
					someSelected = false;

				for (i = 0, l = children.length; i < l; i++) {
					child = children[i];
					unselIgnore = FT.evalOption(
						"unselectableIgnore",
						child,
						child,
						opts,
						false
					);
					if (!unselIgnore) {
						unselState = FT.evalOption(
							"unselectableStatus",
							child,
							child,
							opts,
							undefined
						);
						state =
							unselState == null
								? !!child.selected
								: !!unselState;
						// When fixing the parents, we trust the sibling status (i.e.
						// we don't recurse)
						if (state || child.partsel) {
							someSelected = true;
						}
						if (!state) {
							allSelected = false;
						}
					}
				}
				state = allSelected ? true : someSelected ? undefined : false;
				node._changeSelectStatusAttrs(state);
			});
		},
		// TODO: focus()
		/**
		 * Update node data. If dict contains 'children', then also replace
		 * the hole sub tree.
		 * @param {NodeData} dict
		 *
		 * @see FancytreeNode#addChildren
		 * @see FancytreeNode#applyPatch
		 */
		fromDict: function(dict) {
			// copy all other attributes to this.data.xxx
			for (var name in dict) {
				if (NODE_ATTR_MAP[name]) {
					// node.NAME = dict.NAME
					this[name] = dict[name];
				} else if (name === "data") {
					// node.data += dict.data
					$.extend(this.data, dict.data);
				} else if (
					!$.isFunction(dict[name]) &&
					!NONE_NODE_DATA_MAP[name]
				) {
					// node.data.NAME = dict.NAME
					this.data[name] = dict[name];
				}
			}
			if (dict.children) {
				// recursively set children and render
				this.removeChildren();
				this.addChildren(dict.children);
			}
			this.renderTitle();
			/*
			var children = dict.children;
			if(children === undefined){
				this.data = $.extend(this.data, dict);
				this.render();
				return;
			}
			dict = $.extend({}, dict);
			dict.children = undefined;
			this.data = $.extend(this.data, dict);
			this.removeChildren();
			this.addChild(children);
			*/
		},
		/** Return the list of child nodes (undefined for unexpanded lazy nodes).
		 * @returns {FancytreeNode[] | undefined}
		 */
		getChildren: function() {
			if (this.hasChildren() === undefined) {
				// TODO: only required for lazy nodes?
				return undefined; // Lazy node: unloaded, currently loading, or load error
			}
			return this.children;
		},
		/** Return the first child node or null.
		 * @returns {FancytreeNode | null}
		 */
		getFirstChild: function() {
			return this.children ? this.children[0] : null;
		},
		/** Return the 0-based child index.
		 * @returns {int}
		 */
		getIndex: function() {
			//		return this.parent.children.indexOf(this);
			return $.inArray(this, this.parent.children); // indexOf doesn't work in IE7
		},
		/** Return the hierarchical child index (1-based, e.g. '3.2.4').
		 * @param {string} [separator="."]
		 * @param {int} [digits=1]
		 * @returns {string}
		 */
		getIndexHier: function(separator, digits) {
			separator = separator || ".";
			var s,
				res = [];
			$.each(this.getParentList(false, true), function(i, o) {
				s = "" + (o.getIndex() + 1);
				if (digits) {
					// prepend leading zeroes
					s = ("0000000" + s).substr(-digits);
				}
				res.push(s);
			});
			return res.join(separator);
		},
		/** Return the parent keys separated by options.keyPathSeparator, e.g. "id_1/id_17/id_32".
		 * @param {boolean} [excludeSelf=false]
		 * @returns {string}
		 */
		getKeyPath: function(excludeSelf) {
			var path = [],
				sep = this.tree.options.keyPathSeparator;
			this.visitParents(function(n) {
				if (n.parent) {
					path.unshift(n.key);
				}
			}, !excludeSelf);
			return sep + path.join(sep);
		},
		/** Return the last child of this node or null.
		 * @returns {FancytreeNode | null}
		 */
		getLastChild: function() {
			return this.children
				? this.children[this.children.length - 1]
				: null;
		},
		/** Return node depth. 0: System root node, 1: visible top-level node, 2: first sub-level, ... .
		 * @returns {int}
		 */
		getLevel: function() {
			var level = 0,
				dtn = this.parent;
			while (dtn) {
				level++;
				dtn = dtn.parent;
			}
			return level;
		},
		/** Return the successor node (under the same parent) or null.
		 * @returns {FancytreeNode | null}
		 */
		getNextSibling: function() {
			// TODO: use indexOf, if available: (not in IE6)
			if (this.parent) {
				var i,
					l,
					ac = this.parent.children;

				for (i = 0, l = ac.length - 1; i < l; i++) {
					// up to length-2, so next(last) = null
					if (ac[i] === this) {
						return ac[i + 1];
					}
				}
			}
			return null;
		},
		/** Return the parent node (null for the system root node).
		 * @returns {FancytreeNode | null}
		 */
		getParent: function() {
			// TODO: return null for top-level nodes?
			return this.parent;
		},
		/** Return an array of all parent nodes (top-down).
		 * @param {boolean} [includeRoot=false] Include the invisible system root node.
		 * @param {boolean} [includeSelf=false] Include the node itself.
		 * @returns {FancytreeNode[]}
		 */
		getParentList: function(includeRoot, includeSelf) {
			var l = [],
				dtn = includeSelf ? this : this.parent;
			while (dtn) {
				if (includeRoot || dtn.parent) {
					l.unshift(dtn);
				}
				dtn = dtn.parent;
			}
			return l;
		},
		/** Return the predecessor node (under the same parent) or null.
		 * @returns {FancytreeNode | null}
		 */
		getPrevSibling: function() {
			if (this.parent) {
				var i,
					l,
					ac = this.parent.children;

				for (i = 1, l = ac.length; i < l; i++) {
					// start with 1, so prev(first) = null
					if (ac[i] === this) {
						return ac[i - 1];
					}
				}
			}
			return null;
		},
		/**
		 * Return an array of selected descendant nodes.
		 * @param {boolean} [stopOnParents=false] only return the topmost selected
		 *     node (useful with selectMode 3)
		 * @returns {FancytreeNode[]}
		 */
		getSelectedNodes: function(stopOnParents) {
			var nodeList = [];
			this.visit(function(node) {
				if (node.selected) {
					nodeList.push(node);
					if (stopOnParents === true) {
						return "skip"; // stop processing this branch
					}
				}
			});
			return nodeList;
		},
		/** Return true if node has children. Return undefined if not sure, i.e. the node is lazy and not yet loaded).
		 * @returns {boolean | undefined}
		 */
		hasChildren: function() {
			if (this.lazy) {
				if (this.children == null) {
					// null or undefined: Not yet loaded
					return undefined;
				} else if (this.children.length === 0) {
					// Loaded, but response was empty
					return false;
				} else if (
					this.children.length === 1 &&
					this.children[0].isStatusNode()
				) {
					// Currently loading or load error
					return undefined;
				}
				return true;
			}
			return !!(this.children && this.children.length);
		},
		/** Return true if node has keyboard focus.
		 * @returns {boolean}
		 */
		hasFocus: function() {
			return this.tree.hasFocus() && this.tree.focusNode === this;
		},
		/** Write to browser console if debugLevel >= 3 (prepending node info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		info: function(msg) {
			if (this.tree.options.debugLevel >= 3) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("info", arguments);
			}
		},
		/** Return true if node is active (see also FancytreeNode#isSelected).
		 * @returns {boolean}
		 */
		isActive: function() {
			return this.tree.activeNode === this;
		},
		/** Return true if node is vertically below `otherNode`, i.e. rendered in a subsequent row.
		 * @param {FancytreeNode} otherNode
		 * @returns {boolean}
		 * @since 2.28
		 */
		isBelowOf: function(otherNode) {
			return this.getIndexHier(".", 5) > otherNode.getIndexHier(".", 5);
		},
		/** Return true if node is a direct child of otherNode.
		 * @param {FancytreeNode} otherNode
		 * @returns {boolean}
		 */
		isChildOf: function(otherNode) {
			return this.parent && this.parent === otherNode;
		},
		/** Return true, if node is a direct or indirect sub node of otherNode.
		 * @param {FancytreeNode} otherNode
		 * @returns {boolean}
		 */
		isDescendantOf: function(otherNode) {
			if (!otherNode || otherNode.tree !== this.tree) {
				return false;
			}
			var p = this.parent;
			while (p) {
				if (p === otherNode) {
					return true;
				}
				if (p === p.parent) {
					$.error("Recursive parent link: " + p);
				}
				p = p.parent;
			}
			return false;
		},
		/** Return true if node is expanded.
		 * @returns {boolean}
		 */
		isExpanded: function() {
			return !!this.expanded;
		},
		/** Return true if node is the first node of its parent's children.
		 * @returns {boolean}
		 */
		isFirstSibling: function() {
			var p = this.parent;
			return !p || p.children[0] === this;
		},
		/** Return true if node is a folder, i.e. has the node.folder attribute set.
		 * @returns {boolean}
		 */
		isFolder: function() {
			return !!this.folder;
		},
		/** Return true if node is the last node of its parent's children.
		 * @returns {boolean}
		 */
		isLastSibling: function() {
			var p = this.parent;
			return !p || p.children[p.children.length - 1] === this;
		},
		/** Return true if node is lazy (even if data was already loaded)
		 * @returns {boolean}
		 */
		isLazy: function() {
			return !!this.lazy;
		},
		/** Return true if node is lazy and loaded. For non-lazy nodes always return true.
		 * @returns {boolean}
		 */
		isLoaded: function() {
			return !this.lazy || this.hasChildren() !== undefined; // Also checks if the only child is a status node
		},
		/** Return true if children are currently beeing loaded, i.e. a Ajax request is pending.
		 * @returns {boolean}
		 */
		isLoading: function() {
			return !!this._isLoading;
		},
		/*
		 * @deprecated since v2.4.0:  Use isRootNode() instead
		 */
		isRoot: function() {
			return this.isRootNode();
		},
		/** Return true if node is partially selected (tri-state).
		 * @returns {boolean}
		 * @since 2.23
		 */
		isPartsel: function() {
			return !this.selected && !!this.partsel;
		},
		/** (experimental) Return true if this is partially loaded.
		 * @returns {boolean}
		 * @since 2.15
		 */
		isPartload: function() {
			return !!this.partload;
		},
		/** Return true if this is the (invisible) system root node.
		 * @returns {boolean}
		 * @since 2.4
		 */
		isRootNode: function() {
			return this.tree.rootNode === this;
		},
		/** Return true if node is selected, i.e. has a checkmark set (see also FancytreeNode#isActive).
		 * @returns {boolean}
		 */
		isSelected: function() {
			return !!this.selected;
		},
		/** Return true if this node is a temporarily generated system node like
		 * 'loading', 'paging', or 'error' (node.statusNodeType contains the type).
		 * @returns {boolean}
		 */
		isStatusNode: function() {
			return !!this.statusNodeType;
		},
		/** Return true if this node is a status node of type 'paging'.
		 * @returns {boolean}
		 * @since 2.15
		 */
		isPagingNode: function() {
			return this.statusNodeType === "paging";
		},
		/** Return true if this a top level node, i.e. a direct child of the (invisible) system root node.
		 * @returns {boolean}
		 * @since 2.4
		 */
		isTopLevel: function() {
			return this.tree.rootNode === this.parent;
		},
		/** Return true if node is lazy and not yet loaded. For non-lazy nodes always return false.
		 * @returns {boolean}
		 */
		isUndefined: function() {
			return this.hasChildren() === undefined; // also checks if the only child is a status node
		},
		/** Return true if all parent nodes are expanded. Note: this does not check
		 * whether the node is scrolled into the visible part of the screen.
		 * @returns {boolean}
		 */
		isVisible: function() {
			var i,
				l,
				parents = this.getParentList(false, false);

			for (i = 0, l = parents.length; i < l; i++) {
				if (!parents[i].expanded) {
					return false;
				}
			}
			return true;
		},
		/** Deprecated.
		 * @deprecated since 2014-02-16: use load() instead.
		 */
		lazyLoad: function(discard) {
			this.warn(
				"FancytreeNode.lazyLoad() is deprecated since 2014-02-16. Use .load() instead."
			);
			return this.load(discard);
		},
		/**
		 * Load all children of a lazy node if neccessary. The <i>expanded</i> state is maintained.
		 * @param {boolean} [forceReload=false] Pass true to discard any existing nodes before. Otherwise this method does nothing if the node was already loaded.
		 * @returns {$.Promise}
		 */
		load: function(forceReload) {
			var res,
				source,
				that = this,
				wasExpanded = this.isExpanded();

			_assert(this.isLazy(), "load() requires a lazy node");
			// _assert( forceReload || this.isUndefined(), "Pass forceReload=true to re-load a lazy node" );
			if (!forceReload && !this.isUndefined()) {
				return _getResolvedPromise(this);
			}
			if (this.isLoaded()) {
				this.resetLazy(); // also collapses
			}
			// This method is also called by setExpanded() and loadKeyPath(), so we
			// have to avoid recursion.
			source = this.tree._triggerNodeEvent("lazyLoad", this);
			if (source === false) {
				// #69
				return _getResolvedPromise(this);
			}
			_assert(
				typeof source !== "boolean",
				"lazyLoad event must return source in data.result"
			);
			res = this.tree._callHook("nodeLoadChildren", this, source);
			if (wasExpanded) {
				this.expanded = true;
				res.always(function() {
					that.render();
				});
			} else {
				res.always(function() {
					that.renderStatus(); // fix expander icon to 'loaded'
				});
			}
			return res;
		},
		/** Expand all parents and optionally scroll into visible area as neccessary.
		 * Promise is resolved, when lazy loading and animations are done.
		 * @param {object} [opts] passed to `setExpanded()`.
		 *     Defaults to {noAnimation: false, noEvents: false, scrollIntoView: true}
		 * @returns {$.Promise}
		 */
		makeVisible: function(opts) {
			var i,
				that = this,
				deferreds = [],
				dfd = new $.Deferred(),
				parents = this.getParentList(false, false),
				len = parents.length,
				effects = !(opts && opts.noAnimation === true),
				scroll = !(opts && opts.scrollIntoView === false);

			// Expand bottom-up, so only the top node is animated
			for (i = len - 1; i >= 0; i--) {
				// that.debug("pushexpand" + parents[i]);
				deferreds.push(parents[i].setExpanded(true, opts));
			}
			$.when.apply($, deferreds).done(function() {
				// All expands have finished
				// that.debug("expand DONE", scroll);
				if (scroll) {
					that.scrollIntoView(effects).done(function() {
						// that.debug("scroll DONE");
						dfd.resolve();
					});
				} else {
					dfd.resolve();
				}
			});
			return dfd.promise();
		},
		/** Move this node to targetNode.
		 *  @param {FancytreeNode} targetNode
		 *  @param {string} mode <pre>
		 *      'child': append this node as last child of targetNode.
		 *               This is the default. To be compatble with the D'n'd
		 *               hitMode, we also accept 'over'.
		 *      'firstChild': add this node as first child of targetNode.
		 *      'before': add this node as sibling before targetNode.
		 *      'after': add this node as sibling after targetNode.</pre>
		 *  @param {function} [map] optional callback(FancytreeNode) to allow modifcations
		 */
		moveTo: function(targetNode, mode, map) {
			if (mode === undefined || mode === "over") {
				mode = "child";
			} else if (mode === "firstChild") {
				if (targetNode.children && targetNode.children.length) {
					mode = "before";
					targetNode = targetNode.children[0];
				} else {
					mode = "child";
				}
			}
			var pos,
				prevParent = this.parent,
				targetParent =
					mode === "child" ? targetNode : targetNode.parent;

			if (this === targetNode) {
				return;
			} else if (!this.parent) {
				$.error("Cannot move system root");
			} else if (targetParent.isDescendantOf(this)) {
				$.error("Cannot move a node to its own descendant");
			}
			if (targetParent !== prevParent) {
				prevParent.triggerModifyChild("remove", this);
			}
			// Unlink this node from current parent
			if (this.parent.children.length === 1) {
				if (this.parent === targetParent) {
					return; // #258
				}
				this.parent.children = this.parent.lazy ? [] : null;
				this.parent.expanded = false;
			} else {
				pos = $.inArray(this, this.parent.children);
				_assert(pos >= 0, "invalid source parent");
				this.parent.children.splice(pos, 1);
			}
			// Remove from source DOM parent
			// if(this.parent.ul){
			// 	this.parent.ul.removeChild(this.li);
			// }

			// Insert this node to target parent's child list
			this.parent = targetParent;
			if (targetParent.hasChildren()) {
				switch (mode) {
					case "child":
						// Append to existing target children
						targetParent.children.push(this);
						break;
					case "before":
						// Insert this node before target node
						pos = $.inArray(targetNode, targetParent.children);
						_assert(pos >= 0, "invalid target parent");
						targetParent.children.splice(pos, 0, this);
						break;
					case "after":
						// Insert this node after target node
						pos = $.inArray(targetNode, targetParent.children);
						_assert(pos >= 0, "invalid target parent");
						targetParent.children.splice(pos + 1, 0, this);
						break;
					default:
						$.error("Invalid mode " + mode);
				}
			} else {
				targetParent.children = [this];
			}
			// Parent has no <ul> tag yet:
			// if( !targetParent.ul ) {
			// 	// This is the parent's first child: create UL tag
			// 	// (Hidden, because it will be
			// 	targetParent.ul = document.createElement("ul");
			// 	targetParent.ul.style.display = "none";
			// 	targetParent.li.appendChild(targetParent.ul);
			// }
			// // Issue 319: Add to target DOM parent (only if node was already rendered(expanded))
			// if(this.li){
			// 	targetParent.ul.appendChild(this.li);
			// }

			// Let caller modify the nodes
			if (map) {
				targetNode.visit(map, true);
			}
			if (targetParent === prevParent) {
				targetParent.triggerModifyChild("move", this);
			} else {
				// prevParent.triggerModifyChild("remove", this);
				targetParent.triggerModifyChild("add", this);
			}
			// Handle cross-tree moves
			if (this.tree !== targetNode.tree) {
				// Fix node.tree for all source nodes
				//			_assert(false, "Cross-tree move is not yet implemented.");
				this.warn("Cross-tree moveTo is experimantal!");
				this.visit(function(n) {
					// TODO: fix selection state and activation, ...
					n.tree = targetNode.tree;
				}, true);
			}

			// A collaposed node won't re-render children, so we have to remove it manually
			// if( !targetParent.expanded ){
			//   prevParent.ul.removeChild(this.li);
			// }

			// Update HTML markup
			if (!prevParent.isDescendantOf(targetParent)) {
				prevParent.render();
			}
			if (
				!targetParent.isDescendantOf(prevParent) &&
				targetParent !== prevParent
			) {
				targetParent.render();
			}
			// TODO: fix selection state
			// TODO: fix active state

			/*
			var tree = this.tree;
			var opts = tree.options;
			var pers = tree.persistence;

			// Always expand, if it's below minExpandLevel
			// tree.logDebug ("%s._addChildNode(%o), l=%o", this, ftnode, ftnode.getLevel());
			if ( opts.minExpandLevel >= ftnode.getLevel() ) {
				// tree.logDebug ("Force expand for %o", ftnode);
				this.bExpanded = true;
			}

			// In multi-hier mode, update the parents selection state
			// DT issue #82: only if not initializing, because the children may not exist yet
			// if( !ftnode.data.isStatusNode() && opts.selectMode==3 && !isInitializing )
			// 	ftnode._fixSelectionState();

			// In multi-hier mode, update the parents selection state
			if( ftnode.bSelected && opts.selectMode==3 ) {
				var p = this;
				while( p ) {
					if( !p.hasSubSel )
						p._setSubSel(true);
					p = p.parent;
				}
			}
			// render this node and the new child
			if ( tree.bEnableUpdate )
				this.render();
			return ftnode;
			*/
		},
		/** Set focus relative to this node and optionally activate.
		 *
		 * @param {number} where The keyCode that would normally trigger this move,
		 *		e.g. `$.ui.keyCode.LEFT` would collapse the node if it
		 *      is expanded or move to the parent oterwise.
		 * @param {boolean} [activate=true]
		 * @returns {$.Promise}
		 */
		navigate: function(where, activate) {
			var i,
				parents,
				res,
				handled = true,
				KC = $.ui.keyCode,
				sib = null;

			// Navigate to node
			function _goto(n) {
				if (n) {
					// setFocus/setActive will scroll later (if autoScroll is specified)
					try {
						n.makeVisible({ scrollIntoView: false });
					} catch (e) {} // #272
					// Node may still be hidden by a filter
					if (!$(n.span).is(":visible")) {
						n.debug("Navigate: skipping hidden node");
						n.navigate(where, activate);
						return;
					}
					return activate === false ? n.setFocus() : n.setActive();
				}
			}

			switch (where) {
				case KC.BACKSPACE:
					if (this.parent && this.parent.parent) {
						res = _goto(this.parent);
					}
					break;
				case KC.HOME:
					this.tree.visit(function(n) {
						// goto first visible node
						if ($(n.span).is(":visible")) {
							res = _goto(n);
							return false;
						}
					});
					break;
				case KC.END:
					this.tree.visit(function(n) {
						// goto last visible node
						if ($(n.span).is(":visible")) {
							res = n;
						}
					});
					if (res) {
						res = _goto(res);
					}
					break;
				case KC.LEFT:
					if (this.expanded) {
						this.setExpanded(false);
						res = _goto(this);
					} else if (this.parent && this.parent.parent) {
						res = _goto(this.parent);
					}
					break;
				case KC.RIGHT:
					if (!this.expanded && (this.children || this.lazy)) {
						this.setExpanded();
						res = _goto(this);
					} else if (this.children && this.children.length) {
						res = _goto(this.children[0]);
					}
					break;
				case KC.UP:
					sib = this.getPrevSibling();
					// #359: skip hidden sibling nodes, preventing a _goto() recursion
					while (sib && !$(sib.span).is(":visible")) {
						sib = sib.getPrevSibling();
					}
					while (
						sib &&
						sib.expanded &&
						sib.children &&
						sib.children.length
					) {
						sib = sib.children[sib.children.length - 1];
					}
					if (!sib && this.parent && this.parent.parent) {
						sib = this.parent;
					}
					res = _goto(sib);
					break;
				case KC.DOWN:
					if (
						this.expanded &&
						this.children &&
						this.children.length
					) {
						sib = this.children[0];
					} else {
						parents = this.getParentList(false, true);
						for (i = parents.length - 1; i >= 0; i--) {
							sib = parents[i].getNextSibling();
							// #359: skip hidden sibling nodes, preventing a _goto() recursion
							while (sib && !$(sib.span).is(":visible")) {
								sib = sib.getNextSibling();
							}
							if (sib) {
								break;
							}
						}
					}
					res = _goto(sib);
					break;
				default:
					handled = false;
			}
			return res || _getResolvedPromise();
		},
		/**
		 * Remove this node (not allowed for system root).
		 */
		remove: function() {
			return this.parent.removeChild(this);
		},
		/**
		 * Remove childNode from list of direct children.
		 * @param {FancytreeNode} childNode
		 */
		removeChild: function(childNode) {
			return this.tree._callHook("nodeRemoveChild", this, childNode);
		},
		/**
		 * Remove all child nodes and descendents. This converts the node into a leaf.<br>
		 * If this was a lazy node, it is still considered 'loaded'; call node.resetLazy()
		 * in order to trigger lazyLoad on next expand.
		 */
		removeChildren: function() {
			return this.tree._callHook("nodeRemoveChildren", this);
		},
		/**
		 * Remove class from node's span tag and .extraClasses.
		 *
		 * @param {string} className class name
		 *
		 * @since 2.17
		 */
		removeClass: function(className) {
			return this.toggleClass(className, false);
		},
		/**
		 * This method renders and updates all HTML markup that is required
		 * to display this node in its current state.<br>
		 * Note:
		 * <ul>
		 * <li>It should only be neccessary to call this method after the node object
		 *     was modified by direct access to its properties, because the common
		 *     API methods (node.setTitle(), moveTo(), addChildren(), remove(), ...)
		 *     already handle this.
		 * <li> {@link FancytreeNode#renderTitle} and {@link FancytreeNode#renderStatus}
		 *     are implied. If changes are more local, calling only renderTitle() or
		 *     renderStatus() may be sufficient and faster.
		 * </ul>
		 *
		 * @param {boolean} [force=false] re-render, even if html markup was already created
		 * @param {boolean} [deep=false] also render all descendants, even if parent is collapsed
		 */
		render: function(force, deep) {
			return this.tree._callHook("nodeRender", this, force, deep);
		},
		/** Create HTML markup for the node's outer &lt;span> (expander, checkbox, icon, and title).
		 * Implies {@link FancytreeNode#renderStatus}.
		 * @see Fancytree_Hooks#nodeRenderTitle
		 */
		renderTitle: function() {
			return this.tree._callHook("nodeRenderTitle", this);
		},
		/** Update element's CSS classes according to node state.
		 * @see Fancytree_Hooks#nodeRenderStatus
		 */
		renderStatus: function() {
			return this.tree._callHook("nodeRenderStatus", this);
		},
		/**
		 * (experimental) Replace this node with `source`.
		 * (Currently only available for paging nodes.)
		 * @param {NodeData[]} source List of child node definitions
		 * @since 2.15
		 */
		replaceWith: function(source) {
			var res,
				parent = this.parent,
				pos = $.inArray(this, parent.children),
				that = this;

			_assert(
				this.isPagingNode(),
				"replaceWith() currently requires a paging status node"
			);

			res = this.tree._callHook("nodeLoadChildren", this, source);
			res.done(function(data) {
				// New nodes are currently children of `this`.
				var children = that.children;
				// Prepend newly loaded child nodes to `this`
				// Move new children after self
				for (i = 0; i < children.length; i++) {
					children[i].parent = parent;
				}
				parent.children.splice.apply(
					parent.children,
					[pos + 1, 0].concat(children)
				);

				// Remove self
				that.children = null;
				that.remove();
				// Redraw new nodes
				parent.render();
				// TODO: set node.partload = false if this was tha last paging node?
				// parent.addPagingNode(false);
			}).fail(function() {
				that.setExpanded();
			});
			return res;
			// $.error("Not implemented: replaceWith()");
		},
		/**
		 * Remove all children, collapse, and set the lazy-flag, so that the lazyLoad
		 * event is triggered on next expand.
		 */
		resetLazy: function() {
			this.removeChildren();
			this.expanded = false;
			this.lazy = true;
			this.children = undefined;
			this.renderStatus();
		},
		/** Schedule activity for delayed execution (cancel any pending request).
		 *  scheduleAction('cancel') will only cancel a pending request (if any).
		 * @param {string} mode
		 * @param {number} ms
		 */
		scheduleAction: function(mode, ms) {
			if (this.tree.timer) {
				clearTimeout(this.tree.timer);
				this.tree.debug("clearTimeout(%o)", this.tree.timer);
			}
			this.tree.timer = null;
			var self = this; // required for closures
			switch (mode) {
				case "cancel":
					// Simply made sure that timer was cleared
					break;
				case "expand":
					this.tree.timer = setTimeout(function() {
						self.tree.debug("setTimeout: trigger expand");
						self.setExpanded(true);
					}, ms);
					break;
				case "activate":
					this.tree.timer = setTimeout(function() {
						self.tree.debug("setTimeout: trigger activate");
						self.setActive(true);
					}, ms);
					break;
				default:
					$.error("Invalid mode " + mode);
			}
			// this.tree.debug("setTimeout(%s, %s): %s", mode, ms, this.tree.timer);
		},
		/**
		 *
		 * @param {boolean | PlainObject} [effects=false] animation options.
		 * @param {object} [options=null] {topNode: null, effects: ..., parent: ...} this node will remain visible in
		 *     any case, even if `this` is outside the scroll pane.
		 * @returns {$.Promise}
		 */
		scrollIntoView: function(effects, options) {
			if (options !== undefined && _isNode(options)) {
				throw "scrollIntoView() with 'topNode' option is deprecated since 2014-05-08. Use 'options.topNode' instead.";
			}
			// The scroll parent is typically the plain tree's <UL> container.
			// For ext-table, we choose the nearest parent that has `position: relative`
			// and `overflow` set.
			// (This default can be overridden by the local or global `scrollParent` option.)
			var opts = $.extend(
					{
						effects:
							effects === true
								? { duration: 200, queue: false }
								: effects,
						scrollOfs: this.tree.options.scrollOfs,
						scrollParent: this.tree.options.scrollParent,
						topNode: null,
					},
					options
				),
				$scrollParent = opts.scrollParent,
				$container = this.tree.$container,
				overflowY = $container.css("overflow-y");

			if (!$scrollParent) {
				if (this.tree.tbody) {
					$scrollParent = $container.scrollParent();
				} else if (overflowY === "scroll" || overflowY === "auto") {
					$scrollParent = $container;
				} else {
					// [OT] Support perfect scrolling container
					$scrollParent = $container.closest('.csui-perfect-scrolling');
					if ($scrollParent.length === 0) {
						// #922 plain tree in a non-fixed-sized UL scrolls inside its parent
						$scrollParent = $container.scrollParent();
					}
				}
			} else if (!$scrollParent.jquery) {
				// Make sure we have a jQuery object
				$scrollParent = $($scrollParent);
			}
			if (
				$scrollParent[0] === document ||
				$scrollParent[0] === document.body
			) {
				// `document` may returned by $().scrollParent(), if nothing is found,
				// but would not work: (see #894)
				this.debug(
					"scrollIntoView(): normalizing scrollParent to 'window':",
					$scrollParent[0]
				);
				$scrollParent = $(window);
			}

			var topNodeY,
				nodeY,
				horzScrollbarHeight,
				containerOffsetTop,
				dfd = new $.Deferred(),
				that = this,
				nodeHeight = $(this.span).height(),
				topOfs = opts.scrollOfs.top || 0,
				bottomOfs = opts.scrollOfs.bottom || 0,
				containerHeight = $scrollParent.height(),
				scrollTop = $scrollParent.scrollTop(),
				$animateTarget = $scrollParent,
				isParentWindow = $scrollParent[0] === window,
				topNode = opts.topNode || null,
				newScrollTop = null;

			// this.debug("scrollIntoView(), scrollTop=" + scrollTop, opts.scrollOfs);
			//		_assert($(this.span).is(":visible"), "scrollIntoView node is invisible"); // otherwise we cannot calc offsets
			if (!$(this.span).is(":visible")) {
				// We cannot calc offsets for hidden elements
				this.warn("scrollIntoView(): node is invisible.");
				return _getResolvedPromise();
			}
			if (isParentWindow) {
				nodeY = $(this.span).offset().top;
				topNodeY =
					topNode && topNode.span ? $(topNode.span).offset().top : 0;
				$animateTarget = $("html,body");
			} else {
				_assert(
					$scrollParent[0] !== document &&
						$scrollParent[0] !== document.body,
					"scrollParent should be a simple element or `window`, not document or body."
				);

				(containerOffsetTop = $scrollParent.offset().top),
					(nodeY =
						$(this.span).offset().top -
						containerOffsetTop +
						scrollTop); // relative to scroll parent
				topNodeY = topNode
					? $(topNode.span).offset().top -
					  containerOffsetTop +
					  scrollTop
					: 0;
				horzScrollbarHeight = Math.max(
					0,
					$scrollParent.innerHeight() - $scrollParent[0].clientHeight
				);
				containerHeight -= horzScrollbarHeight;
			}

			// this.debug("    scrollIntoView(), nodeY=" + nodeY + ", containerHeight=" + containerHeight);
			if (nodeY < scrollTop + topOfs) {
				// Node is above visible container area
				newScrollTop = nodeY - topOfs;
				// this.debug("    scrollIntoView(), UPPER newScrollTop=" + newScrollTop);
			} else if (
				nodeY + nodeHeight >
				scrollTop + containerHeight - bottomOfs
			) {
				newScrollTop = nodeY + nodeHeight - containerHeight + bottomOfs;
				// this.debug("    scrollIntoView(), LOWER newScrollTop=" + newScrollTop);
				// If a topNode was passed, make sure that it is never scrolled
				// outside the upper border
				if (topNode) {
					_assert(
						topNode.isRootNode() || $(topNode.span).is(":visible"),
						"topNode must be visible"
					);
					if (topNodeY < newScrollTop) {
						newScrollTop = topNodeY - topOfs;
						// this.debug("    scrollIntoView(), TOP newScrollTop=" + newScrollTop);
					}
				}
			}

			if (newScrollTop !== null) {
				// this.debug("    scrollIntoView(), SET newScrollTop=" + newScrollTop);
				if (opts.effects) {
					opts.effects.complete = function() {
						dfd.resolveWith(that);
					};
					$animateTarget.stop(true).animate(
						{
							scrollTop: newScrollTop,
						},
						opts.effects
					);
				} else {
					$animateTarget[0].scrollTop = newScrollTop;
					dfd.resolveWith(this);
				}
			} else {
				dfd.resolveWith(this);
			}
			return dfd.promise();
		},

		/**Activate this node.
		 *
		 * The `cell` option requires the ext-table and ext-ariagrid extensions.
		 *
		 * @param {boolean} [flag=true] pass false to deactivate
		 * @param {object} [opts] additional options. Defaults to {noEvents: false, noFocus: false, cell: null}
		 * @returns {$.Promise}
		 */
		setActive: function(flag, opts) {
			return this.tree._callHook("nodeSetActive", this, flag, opts);
		},
		/**Expand or collapse this node. Promise is resolved, when lazy loading and animations are done.
		 * @param {boolean} [flag=true] pass false to collapse
		 * @param {object} [opts] additional options. Defaults to {noAnimation: false, noEvents: false}
		 * @returns {$.Promise}
		 */
		setExpanded: function(flag, opts) {
			return this.tree._callHook("nodeSetExpanded", this, flag, opts);
		},
		/**Set keyboard focus to this node.
		 * @param {boolean} [flag=true] pass false to blur
		 * @see Fancytree#setFocus
		 */
		setFocus: function(flag) {
			return this.tree._callHook("nodeSetFocus", this, flag);
		},
		/**Select this node, i.e. check the checkbox.
		 * @param {boolean} [flag=true] pass false to deselect
		 * @param {object} [opts] additional options. Defaults to {noEvents: false, p
		 *     propagateDown: null, propagateUp: null, callback: null }
		 */
		setSelected: function(flag, opts) {
			return this.tree._callHook("nodeSetSelected", this, flag, opts);
		},
		/**Mark a lazy node as 'error', 'loading', 'nodata', or 'ok'.
		 * @param {string} status 'error'|'empty'|'ok'
		 * @param {string} [message]
		 * @param {string} [details]
		 */
		setStatus: function(status, message, details) {
			return this.tree._callHook(
				"nodeSetStatus",
				this,
				status,
				message,
				details
			);
		},
		/**Rename this node.
		 * @param {string} title
		 */
		setTitle: function(title) {
			this.title = title;
			this.renderTitle();
			this.triggerModify("rename");
		},
		/**Sort child list by title.
		 * @param {function} [cmp] custom compare function(a, b) that returns -1, 0, or 1 (defaults to sort by title).
		 * @param {boolean} [deep=false] pass true to sort all descendant nodes
		 */
		sortChildren: function(cmp, deep) {
			var i,
				l,
				cl = this.children;

			if (!cl) {
				return;
			}
			cmp =
				cmp ||
				function(a, b) {
					var x = a.title.toLowerCase(),
						y = b.title.toLowerCase();
					return x === y ? 0 : x > y ? 1 : -1;
				};
			cl.sort(cmp);
			if (deep) {
				for (i = 0, l = cl.length; i < l; i++) {
					if (cl[i].children) {
						cl[i].sortChildren(cmp, "$norender$");
					}
				}
			}
			if (deep !== "$norender$") {
				this.render();
			}
			this.triggerModifyChild("sort");
		},
		/** Convert node (or whole branch) into a plain object.
		 *
		 * The result is compatible with node.addChildren().
		 *
		 * @param {boolean} [recursive=false] include child nodes
		 * @param {function} [callback] callback(dict, node) is called for every node, in order to allow modifications
		 * @returns {NodeData}
		 */
		toDict: function(recursive, callback) {
			var i,
				l,
				node,
				dict = {},
				self = this;

			$.each(NODE_ATTRS, function(i, a) {
				if (self[a] || self[a] === false) {
					dict[a] = self[a];
				}
			});
			if (!$.isEmptyObject(this.data)) {
				dict.data = $.extend({}, this.data);
				if ($.isEmptyObject(dict.data)) {
					delete dict.data;
				}
			}
			if (callback) {
				callback(dict, self);
			}
			if (recursive) {
				if (this.hasChildren()) {
					dict.children = [];
					for (i = 0, l = this.children.length; i < l; i++) {
						node = this.children[i];
						if (!node.isStatusNode()) {
							dict.children.push(node.toDict(true, callback));
						}
					}
				} else {
					// dict.children = null;
				}
			}
			return dict;
		},
		/**
		 * Set, clear, or toggle class of node's span tag and .extraClasses.
		 *
		 * @param {string} className class name (separate multiple classes by space)
		 * @param {boolean} [flag] true/false to add/remove class. If omitted, class is toggled.
		 * @returns {boolean} true if a class was added
		 *
		 * @since 2.17
		 */
		toggleClass: function(value, flag) {
			var className,
				hasClass,
				rnotwhite = /\S+/g,
				classNames = value.match(rnotwhite) || [],
				i = 0,
				wasAdded = false,
				statusElem = this[this.tree.statusClassPropName],
				curClasses = " " + (this.extraClasses || "") + " ";

			// this.info("toggleClass('" + value + "', " + flag + ")", curClasses);
			// Modify DOM element directly if it already exists
			if (statusElem) {
				$(statusElem).toggleClass(value, flag);
			}
			// Modify node.extraClasses to make this change persistent
			// Toggle if flag was not passed
			while ((className = classNames[i++])) {
				hasClass = curClasses.indexOf(" " + className + " ") >= 0;
				flag = flag === undefined ? !hasClass : !!flag;
				if (flag) {
					if (!hasClass) {
						curClasses += className + " ";
						wasAdded = true;
					}
				} else {
					while (curClasses.indexOf(" " + className + " ") > -1) {
						curClasses = curClasses.replace(
							" " + className + " ",
							" "
						);
					}
				}
			}
			this.extraClasses = $.trim(curClasses);
			// this.info("-> toggleClass('" + value + "', " + flag + "): '" + this.extraClasses + "'");
			return wasAdded;
		},
		/** Flip expanded status. */
		toggleExpanded: function() {
			return this.tree._callHook("nodeToggleExpanded", this);
		},
		/** Flip selection status. */
		toggleSelected: function() {
			return this.tree._callHook("nodeToggleSelected", this);
		},
		toString: function() {
			return "FancytreeNode@" + this.key + "[title='" + this.title + "']";
			// return "<FancytreeNode(#" + this.key + ", '" + this.title + "')>";
		},
		/**
		 * Trigger `modifyChild` event on a parent to signal that a child was modified.
		 * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...
		 * @param {FancytreeNode} [childNode]
		 * @param {object} [extra]
		 */
		triggerModifyChild: function(operation, childNode, extra) {
			var data,
				modifyChild = this.tree.options.modifyChild;

			if (modifyChild) {
				if (childNode && childNode.parent !== this) {
					$.error(
						"childNode " + childNode + " is not a child of " + this
					);
				}
				data = {
					node: this,
					tree: this.tree,
					operation: operation,
					childNode: childNode || null,
				};
				if (extra) {
					$.extend(data, extra);
				}
				modifyChild({ type: "modifyChild" }, data);
			}
		},
		/**
		 * Trigger `modifyChild` event on node.parent(!).
		 * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...
		 * @param {object} [extra]
		 */
		triggerModify: function(operation, extra) {
			this.parent.triggerModifyChild(operation, this, extra);
		},
		/** Call fn(node) for all child nodes in hierarchical order (depth-first).<br>
		 * Stop iteration, if fn() returns false. Skip current branch, if fn() returns "skip".<br>
		 * Return false if iteration was stopped.
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and
		 *     its children only.
		 * @param {boolean} [includeSelf=false]
		 * @returns {boolean}
		 */
		visit: function(fn, includeSelf) {
			var i,
				l,
				res = true,
				children = this.children;

			if (includeSelf === true) {
				res = fn(this);
				if (res === false || res === "skip") {
					return res;
				}
			}
			if (children) {
				for (i = 0, l = children.length; i < l; i++) {
					res = children[i].visit(fn, true);
					if (res === false) {
						break;
					}
				}
			}
			return res;
		},
		/** Call fn(node) for all child nodes and recursively load lazy children.<br>
		 * <b>Note:</b> If you need this method, you probably should consider to review
		 * your architecture! Recursivley loading nodes is a perfect way for lazy
		 * programmers to flood the server with requests ;-)
		 *
		 * @param {function} [fn] optional callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and
		 *     its children only.
		 * @param {boolean} [includeSelf=false]
		 * @returns {$.Promise}
		 * @since 2.4
		 */
		visitAndLoad: function(fn, includeSelf, _recursion) {
			var dfd,
				res,
				loaders,
				node = this;

			// node.debug("visitAndLoad");
			if (fn && includeSelf === true) {
				res = fn(node);
				if (res === false || res === "skip") {
					return _recursion ? res : _getResolvedPromise();
				}
			}
			if (!node.children && !node.lazy) {
				return _getResolvedPromise();
			}
			dfd = new $.Deferred();
			loaders = [];
			// node.debug("load()...");
			node.load().done(function() {
				// node.debug("load()... done.");
				for (var i = 0, l = node.children.length; i < l; i++) {
					res = node.children[i].visitAndLoad(fn, true, true);
					if (res === false) {
						dfd.reject();
						break;
					} else if (res !== "skip") {
						loaders.push(res); // Add promise to the list
					}
				}
				$.when.apply(this, loaders).then(function() {
					dfd.resolve();
				});
			});
			return dfd.promise();
		},
		/** Call fn(node) for all parent nodes, bottom-up, including invisible system root.<br>
		 * Stop iteration, if fn() returns false.<br>
		 * Return false if iteration was stopped.
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and children only.
		 * @param {boolean} [includeSelf=false]
		 * @returns {boolean}
		 */
		visitParents: function(fn, includeSelf) {
			// Visit parent nodes (bottom up)
			if (includeSelf && fn(this) === false) {
				return false;
			}
			var p = this.parent;
			while (p) {
				if (fn(p) === false) {
					return false;
				}
				p = p.parent;
			}
			return true;
		},
		/** Call fn(node) for all sibling nodes.<br>
		 * Stop iteration, if fn() returns false.<br>
		 * Return false if iteration was stopped.
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration.
		 * @param {boolean} [includeSelf=false]
		 * @returns {boolean}
		 */
		visitSiblings: function(fn, includeSelf) {
			var i,
				l,
				n,
				ac = this.parent.children;

			for (i = 0, l = ac.length; i < l; i++) {
				n = ac[i];
				if (includeSelf || n !== this) {
					if (fn(n) === false) {
						return false;
					}
				}
			}
			return true;
		},
		/** Write warning to browser console if debugLevel >= 2 (prepending node info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		warn: function(msg) {
			if (this.tree.options.debugLevel >= 2) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("warn", arguments);
			}
		},
	};

	/******************************************************************************
	 * Fancytree
	 */
	/**
	 * Construct a new tree object.
	 *
	 * @class Fancytree
	 * @classdesc The controller behind a fancytree.
	 * This class also contains 'hook methods': see {@link Fancytree_Hooks}.
	 *
	 * @param {Widget} widget
	 *
	 * @property {string} _id Automatically generated unique tree instance ID, e.g. "1".
	 * @property {string} _ns Automatically generated unique tree namespace, e.g. ".fancytree-1".
	 * @property {FancytreeNode} activeNode Currently active node or null.
	 * @property {string} ariaPropName Property name of FancytreeNode that contains the element which will receive the aria attributes.
	 *     Typically "li", but "tr" for table extension.
	 * @property {jQueryObject} $container Outer &lt;ul> element (or &lt;table> element for ext-table).
	 * @property {jQueryObject} $div A jQuery object containing the element used to instantiate the tree widget (`widget.element`)
	 * @property {object|array} columns Recommended place to store shared column meta data. @since 2.27
	 * @property {object} data Metadata, i.e. properties that may be passed to `source` in addition to a children array.
	 * @property {object} ext Hash of all active plugin instances.
	 * @property {FancytreeNode} focusNode Currently focused node or null.
	 * @property {FancytreeNode} lastSelectedNode Used to implement selectMode 1 (single select)
	 * @property {string} nodeContainerAttrName Property name of FancytreeNode that contains the outer element of single nodes.
	 *     Typically "li", but "tr" for table extension.
	 * @property {FancytreeOptions} options Current options, i.e. default options + options passed to constructor.
	 * @property {FancytreeNode} rootNode Invisible system root node.
	 * @property {string} statusClassPropName Property name of FancytreeNode that contains the element which will receive the status classes.
	 *     Typically "span", but "tr" for table extension.
	 * @property {object} types Map for shared type specific meta data, used with node.type attribute. @since 2.27
	 * @property {object} widget Base widget instance.
	 */
	function Fancytree(widget) {
		this.widget = widget;
		this.$div = widget.element;
		this.options = widget.options;
		if (this.options) {
			if (
				$.isFunction(this.options.lazyload) &&
				!$.isFunction(this.options.lazyLoad)
			) {
				this.options.lazyLoad = function() {
					FT.warn(
						"The 'lazyload' event is deprecated since 2014-02-25. Use 'lazyLoad' (with uppercase L) instead."
					);
					return widget.options.lazyload.apply(this, arguments);
				};
			}
			if ($.isFunction(this.options.loaderror)) {
				$.error(
					"The 'loaderror' event was renamed since 2014-07-03. Use 'loadError' (with uppercase E) instead."
				);
			}
			if (this.options.fx !== undefined) {
				FT.warn(
					"The 'fx' option was replaced by 'toggleEffect' since 2014-11-30."
				);
			}
			if (this.options.removeNode !== undefined) {
				$.error(
					"The 'removeNode' event was replaced by 'modifyChild' since 2.20 (2016-09-10)."
				);
			}
		}
		this.ext = {}; // Active extension instances
		this.types = {};
		this.columns = {};
		// allow to init tree.data.foo from <div data-foo=''>
		this.data = _getElementDataAsDict(this.$div);
		// TODO: use widget.uuid instead?
		this._id = $.ui.fancytree._nextId++;
		// TODO: use widget.eventNamespace instead?
		this._ns = ".fancytree-" + this._id; // append for namespaced events
		this.activeNode = null;
		this.focusNode = null;
		this._hasFocus = null;
		this._tempCache = {};
		this._lastMousedownNode = null;
		this._enableUpdate = true;
		this.lastSelectedNode = null;
		this.systemFocusElement = null;
		this.lastQuicksearchTerm = "";
		this.lastQuicksearchTime = 0;

		this.statusClassPropName = "span";
		this.ariaPropName = "li";
		this.nodeContainerAttrName = "li";

		// Remove previous markup if any
		this.$div.find(">ul.fancytree-container").remove();

		// Create a node without parent.
		var fakeParent = { tree: this },
			$ul;
		this.rootNode = new FancytreeNode(fakeParent, {
			title: "root",
			key: "root_" + this._id,
			children: null,
			expanded: true,
		});
		this.rootNode.parent = null;

		// Create root markup
		$ul = $("<ul>", {
			class: "ui-fancytree fancytree-container fancytree-plain",
		}).appendTo(this.$div);
		this.$container = $ul;
		this.rootNode.ul = $ul[0];

		if (this.options.debugLevel == null) {
			this.options.debugLevel = FT.debugLevel;
		}
		// // Add container to the TAB chain
		// // See http://www.w3.org/TR/wai-aria-practices/#focus_activedescendant
		// // #577: Allow to set tabindex to "0", "-1" and ""
		// this.$container.attr("tabindex", this.options.tabindex);

		// if( this.options.rtl ) {
		// 	this.$container.attr("DIR", "RTL").addClass("fancytree-rtl");
		// // }else{
		// //	this.$container.attr("DIR", null).removeClass("fancytree-rtl");
		// }
		// if(this.options.aria){
		// 	this.$container.attr("role", "tree");
		// 	if( this.options.selectMode !== 1 ) {
		// 		this.$container.attr("aria-multiselectable", true);
		// 	}
		// }
	}

	Fancytree.prototype = /** @lends Fancytree# */ {
		/* Return a context object that can be re-used for _callHook().
		 * @param {Fancytree | FancytreeNode | EventData} obj
		 * @param {Event} originalEvent
		 * @param {Object} extra
		 * @returns {EventData}
		 */
		_makeHookContext: function(obj, originalEvent, extra) {
			var ctx, tree;
			if (obj.node !== undefined) {
				// obj is already a context object
				if (originalEvent && obj.originalEvent !== originalEvent) {
					$.error("invalid args");
				}
				ctx = obj;
			} else if (obj.tree) {
				// obj is a FancytreeNode
				tree = obj.tree;
				ctx = {
					node: obj,
					tree: tree,
					widget: tree.widget,
					options: tree.widget.options,
					originalEvent: originalEvent,
					typeInfo: tree.types[obj.type] || {},
				};
			} else if (obj.widget) {
				// obj is a Fancytree
				ctx = {
					node: null,
					tree: obj,
					widget: obj.widget,
					options: obj.widget.options,
					originalEvent: originalEvent,
				};
			} else {
				$.error("invalid args");
			}
			if (extra) {
				$.extend(ctx, extra);
			}
			return ctx;
		},
		/* Trigger a hook function: funcName(ctx, [...]).
		 *
		 * @param {string} funcName
		 * @param {Fancytree|FancytreeNode|EventData} contextObject
		 * @param {any}  [_extraArgs] optional additional arguments
		 * @returns {any}
		 */
		_callHook: function(funcName, contextObject, _extraArgs) {
			var ctx = this._makeHookContext(contextObject),
				fn = this[funcName],
				args = Array.prototype.slice.call(arguments, 2);
			if (!$.isFunction(fn)) {
				$.error("_callHook('" + funcName + "') is not a function");
			}
			args.unshift(ctx);
			// this.debug("_hook", funcName, ctx.node && ctx.node.toString() || ctx.tree.toString(), args);
			return fn.apply(this, args);
		},
		_setExpiringValue: function(key, value, ms) {
			this._tempCache[key] = {
				value: value,
				expire: Date.now() + (+ms || 50),
			};
		},
		_getExpiringValue: function(key) {
			var entry = this._tempCache[key];
			if (entry && entry.expire > Date.now()) {
				return entry.value;
			}
			delete this._tempCache[key];
			return null;
		},
		/* Check if current extensions dependencies are met and throw an error if not.
		 *
		 * This method may be called inside the `treeInit` hook for custom extensions.
		 *
		 * @param {string} extension name of the required extension
		 * @param {boolean} [required=true] pass `false` if the extension is optional, but we want to check for order if it is present
		 * @param {boolean} [before] `true` if `name` must be included before this, `false` otherwise (use `null` if order doesn't matter)
		 * @param {string} [message] optional error message (defaults to a descriptve error message)
		 */
		_requireExtension: function(name, required, before, message) {
			if (before != null) {
				before = !!before;
			}
			var thisName = this._local.name,
				extList = this.options.extensions,
				isBefore =
					$.inArray(name, extList) < $.inArray(thisName, extList),
				isMissing = required && this.ext[name] == null,
				badOrder = !isMissing && before != null && before !== isBefore;

			_assert(thisName && thisName !== name, "invalid or same name");

			if (isMissing || badOrder) {
				if (!message) {
					if (isMissing || required) {
						message =
							"'" +
							thisName +
							"' extension requires '" +
							name +
							"'";
						if (badOrder) {
							message +=
								" to be registered " +
								(before ? "before" : "after") +
								" itself";
						}
					} else {
						message =
							"If used together, `" +
							name +
							"` must be registered " +
							(before ? "before" : "after") +
							" `" +
							thisName +
							"`";
					}
				}
				$.error(message);
				return false;
			}
			return true;
		},
		/** Activate node with a given key and fire focus and activate events.
		 *
		 * A previously activated node will be deactivated.
		 * If activeVisible option is set, all parents will be expanded as necessary.
		 * Pass key = false, to deactivate the current node only.
		 * @param {string} key
		 * @param {object} [opts] additional options. Defaults to {noEvents: false, noFocus: false}
		 * @returns {FancytreeNode} activated node (null, if not found)
		 */
		activateKey: function(key, opts) {
			var node = this.getNodeByKey(key);
			if (node) {
				node.setActive(true, opts);
			} else if (this.activeNode) {
				this.activeNode.setActive(false, opts);
			}
			return node;
		},
		/** (experimental) Add child status nodes that indicate 'More...', ....
		 * @param {boolean|object} node optional node definition. Pass `false` to remove all paging nodes.
		 * @param {string} [mode='append'] 'child'|firstChild'
		 * @since 2.15
		 */
		addPagingNode: function(node, mode) {
			return this.rootNode.addPagingNode(node, mode);
		},
		/** (experimental) Modify existing data model.
		 *
		 * @param {Array} patchList array of [key, NodePatch] arrays
		 * @returns {$.Promise} resolved, when all patches have been applied
		 * @see TreePatch
		 */
		applyPatch: function(patchList) {
			var dfd,
				i,
				p2,
				key,
				patch,
				node,
				patchCount = patchList.length,
				deferredList = [];

			for (i = 0; i < patchCount; i++) {
				p2 = patchList[i];
				_assert(
					p2.length === 2,
					"patchList must be an array of length-2-arrays"
				);
				key = p2[0];
				patch = p2[1];
				node = key === null ? this.rootNode : this.getNodeByKey(key);
				if (node) {
					dfd = new $.Deferred();
					deferredList.push(dfd);
					node.applyPatch(patch).always(_makeResolveFunc(dfd, node));
				} else {
					this.warn("could not find node with key '" + key + "'");
				}
			}
			// Return a promise that is resolved, when ALL patches were applied
			return $.when.apply($, deferredList).promise();
		},
		/* TODO: implement in dnd extension
		cancelDrag: function() {
				var dd = $.ui.ddmanager.current;
				if(dd){
					dd.cancel();
				}
			},
		*/
		/** Remove all nodes.
		 * @since 2.14
		 */
		clear: function(source) {
			this._callHook("treeClear", this);
		},
		/** Return the number of nodes.
		 * @returns {integer}
		 */
		count: function() {
			return this.rootNode.countChildren();
		},
		/** Write to browser console if debugLevel >= 4 (prepending tree name)
		 *
		 * @param {*} msg string or object or array of such
		 */
		debug: function(msg) {
			if (this.options.debugLevel >= 4) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("log", arguments);
			}
		},
		/** Enable (or disable) the tree control.
		 *
		 * @param {boolean} [flag=true] pass false to disable
		 * @since 2.30
		 */
		enable: function(flag) {
			if (flag === false) {
				this.widget.disable();
			} else {
				this.widget.enable();
			}
		},
		/** Temporarily suppress rendering to improve performance on bulk-updates.
		 *
		 * @param {boolean} flag
		 * @returns {boolean} previous status
		 * @since 2.19
		 */
		enableUpdate: function(flag) {
			flag = flag !== false; // Confusing use of '!'
			/*jshint -W018 */ if (!!this._enableUpdate === !!flag) {
				return flag;
			}
			/*jshint +W018 */
			this._enableUpdate = flag;
			if (flag) {
				this.debug("enableUpdate(true): redraw "); //, this._dirtyRoots);
				this.render();
			} else {
				// 	this._dirtyRoots = null;
				this.debug("enableUpdate(false)...");
			}
			return !flag; // return previous value
		},
		/** Expand (or collapse) all parent nodes.
		 *
		 * This convenience method uses `tree.visit()` and `tree.setExpanded()`
		 * internally.
		 *
		 * @param {boolean} [flag=true] pass false to collapse
		 * @param {object} [opts] passed to setExpanded()
		 * @since 2.30
		 */
		expandAll: function(flag, opts) {
			flag = flag !== false;
			this.visit(function(node) {
				if (
					node.hasChildren() !== false &&
					node.isExpanded() !== flag
				) {
					node.setExpanded(flag, opts);
				}
			});
		},
		/**Find all nodes that matches condition.
		 *
		 * @param {string | function(node)} match title string to search for, or a
		 *     callback function that returns `true` if a node is matched.
		 * @returns {FancytreeNode[]} array of nodes (may be empty)
		 * @see FancytreeNode#findAll
		 * @since 2.12
		 */
		findAll: function(match) {
			return this.rootNode.findAll(match);
		},
		/**Find first node that matches condition.
		 *
		 * @param {string | function(node)} match title string to search for, or a
		 *     callback function that returns `true` if a node is matched.
		 * @returns {FancytreeNode} matching node or null
		 * @see FancytreeNode#findFirst
		 * @since 2.12
		 */
		findFirst: function(match) {
			return this.rootNode.findFirst(match);
		},
		/** Find the next visible node that starts with `match`, starting at `startNode`
		 * and wrap-around at the end.
		 *
		 * @param {string|function} match
		 * @param {FancytreeNode} [startNode] defaults to first node
		 * @returns {FancytreeNode} matching node or null
		 */
		findNextNode: function(match, startNode, visibleOnly) {
			match =
				typeof match === "string"
					? _makeNodeTitleStartMatcher(match)
					: match;
			startNode = startNode || this.getFirstChild();

			var stopNode = null,
				parentChildren = startNode.parent.children,
				matchingNode = null,
				walkVisible = function(parent, idx, fn) {
					var i,
						grandParent,
						parentChildren = parent.children,
						siblingCount = parentChildren.length,
						node = parentChildren[idx];
					// visit node itself
					if (node && fn(node) === false) {
						return false;
					}
					// visit descendants
					if (node && node.children && node.expanded) {
						if (walkVisible(node, 0, fn) === false) {
							return false;
						}
					}
					// visit subsequent siblings
					for (i = idx + 1; i < siblingCount; i++) {
						if (walkVisible(parent, i, fn) === false) {
							return false;
						}
					}
					// visit parent's subsequent siblings
					grandParent = parent.parent;
					if (grandParent) {
						return walkVisible(
							grandParent,
							grandParent.children.indexOf(parent) + 1,
							fn
						);
					} else {
						// wrap-around: restart with first node
						return walkVisible(parent, 0, fn);
					}
				};

			walkVisible(
				startNode.parent,
				parentChildren.indexOf(startNode),
				function(node) {
					// Stop iteration if we see the start node a second time
					if (node === stopNode) {
						return false;
					}
					stopNode = stopNode || node;
					// Ignore nodes hidden by a filter
					if (!$(node.span).is(":visible")) {
						node.debug("quicksearch: skipping hidden node");
						return;
					}
					// Test if we found a match, but search for a second match if this
					// was the currently active node
					if (match(node)) {
						// node.debug("quicksearch match " + node.title, startNode);
						matchingNode = node;
						if (matchingNode !== startNode) {
							return false;
						}
					}
				}
			);
			return matchingNode;
		},
		// TODO: fromDict
		/**
		 * Generate INPUT elements that can be submitted with html forms.
		 *
		 * In selectMode 3 only the topmost selected nodes are considered, unless
		 * `opts.stopOnParents: false` is passed.
		 *
		 * @example
		 * // Generate input elements for active and selected nodes
		 * tree.generateFormElements();
		 * // Generate input elements selected nodes, using a custom `name` attribute
		 * tree.generateFormElements("cust_sel", false);
		 * // Generate input elements using a custom filter
		 * tree.generateFormElements(true, true, { filter: function(node) {
		 *     return node.isSelected() && node.data.yes;
		 * }});
		 *
		 * @param {boolean | string} [selected=true] Pass false to disable, pass a string to override the field name (default: 'ft_ID[]')
		 * @param {boolean | string} [active=true] Pass false to disable, pass a string to override the field name (default: 'ft_ID_active')
		 * @param {object} [opts] default { filter: null, stopOnParents: true }
		 */
		generateFormElements: function(selected, active, opts) {
			opts = opts || {};

			var nodeList,
				selectedName =
					typeof selected === "string"
						? selected
						: "ft_" + this._id + "[]",
				activeName =
					typeof active === "string"
						? active
						: "ft_" + this._id + "_active",
				id = "fancytree_result_" + this._id,
				$result = $("#" + id),
				stopOnParents =
					this.options.selectMode === 3 &&
					opts.stopOnParents !== false;

			if ($result.length) {
				$result.empty();
			} else {
				$result = $("<div>", {
					id: id,
				})
					.hide()
					.insertAfter(this.$container);
			}
			if (active !== false && this.activeNode) {
				$result.append(
					$("<input>", {
						type: "radio",
						name: activeName,
						value: this.activeNode.key,
						checked: true,
					})
				);
			}
			function _appender(node) {
				$result.append(
					$("<input>", {
						type: "checkbox",
						name: selectedName,
						value: node.key,
						checked: true,
					})
				);
			}
			if (opts.filter) {
				this.visit(function(node) {
					var res = opts.filter(node);
					if (res === "skip") {
						return res;
					}
					if (res !== false) {
						_appender(node);
					}
				});
			} else if (selected !== false) {
				nodeList = this.getSelectedNodes(stopOnParents);
				$.each(nodeList, function(idx, node) {
					_appender(node);
				});
			}
		},
		/**
		 * Return the currently active node or null.
		 * @returns {FancytreeNode}
		 */
		getActiveNode: function() {
			return this.activeNode;
		},
		/** Return the first top level node if any (not the invisible root node).
		 * @returns {FancytreeNode | null}
		 */
		getFirstChild: function() {
			return this.rootNode.getFirstChild();
		},
		/**
		 * Return node that has keyboard focus or null.
		 * @returns {FancytreeNode}
		 */
		getFocusNode: function() {
			return this.focusNode;
		},
		/**
		 * Return current option value.
		 * (Note: this is the preferred variant of `$().fancytree("option", "KEY")`)
		 *
		 * @param {string} name option name (may contain '.')
		 * @returns {any}
		 */
		getOption: function(optionName) {
			return this.widget.option(optionName);
		},
		/**
		 * Return node with a given key or null if not found.
		 *
		 * @param {string} key
		 * @param {FancytreeNode} [searchRoot] only search below this node
		 * @returns {FancytreeNode | null}
		 */
		getNodeByKey: function(key, searchRoot) {
			// Search the DOM by element ID (assuming this is faster than traversing all nodes).
			var el, match;
			// TODO: use tree.keyMap if available
			// TODO: check opts.generateIds === true
			if (!searchRoot) {
				el = document.getElementById(this.options.idPrefix + key);
				if (el) {
					return el.ftnode ? el.ftnode : null;
				}
			}
			// Not found in the DOM, but still may be in an unrendered part of tree
			searchRoot = searchRoot || this.rootNode;
			match = null;
			searchRoot.visit(function(node) {
				if (node.key === key) {
					match = node;
					return false; // Stop iteration
				}
			}, true);
			return match;
		},
		/** Return the invisible system root node.
		 * @returns {FancytreeNode}
		 */
		getRootNode: function() {
			return this.rootNode;
		},
		/**
		 * Return an array of selected nodes.
		 * @param {boolean} [stopOnParents=false] only return the topmost selected
		 *     node (useful with selectMode 3)
		 * @returns {FancytreeNode[]}
		 */
		getSelectedNodes: function(stopOnParents) {
			return this.rootNode.getSelectedNodes(stopOnParents);
		},
		/** Return true if the tree control has keyboard focus
		 * @returns {boolean}
		 */
		hasFocus: function() {
			return !!this._hasFocus;
		},
		/** Write to browser console if debugLevel >= 3 (prepending tree name)
		 * @param {*} msg string or object or array of such
		 */
		info: function(msg) {
			if (this.options.debugLevel >= 3) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("info", arguments);
			}
		},
		/*
		TODO: isInitializing: function() {
			return ( this.phase=="init" || this.phase=="postInit" );
		},
		TODO: isReloading: function() {
			return ( this.phase=="init" || this.phase=="postInit" ) && this.options.persist && this.persistence.cookiesFound;
		},
		TODO: isUserEvent: function() {
			return ( this.phase=="userEvent" );
		},
		*/

		/**
		 * Make sure that a node with a given ID is loaded, by traversing - and
		 * loading - its parents. This method is meant for lazy hierarchies.
		 * A callback is executed for every node as we go.
		 * @example
		 * // Resolve using node.key:
		 * tree.loadKeyPath("/_3/_23/_26/_27", function(node, status){
		 *   if(status === "loaded") {
		 *     console.log("loaded intermediate node " + node);
		 *   }else if(status === "ok") {
		 *     node.activate();
		 *   }
		 * });
		 * // Use deferred promise:
		 * tree.loadKeyPath("/_3/_23/_26/_27").progress(function(data){
		 *   if(data.status === "loaded") {
		 *     console.log("loaded intermediate node " + data.node);
		 *   }else if(data.status === "ok") {
		 *     node.activate();
		 *   }
		 * }).done(function(){
		 *    ...
		 * });
		 * // Custom path segment resolver:
		 * tree.loadKeyPath("/321/431/21/2", {
		 *   matchKey: function(node, key){
		 *     return node.data.refKey === key;
		 *   },
		 *   callback: function(node, status){
		 *     if(status === "loaded") {
		 *       console.log("loaded intermediate node " + node);
		 *     }else if(status === "ok") {
		 *       node.activate();
		 *     }
		 *   }
		 * });
		 * @param {string | string[]} keyPathList one or more key paths (e.g. '/3/2_1/7')
		 * @param {function | object} optsOrCallback callback(node, status) is called for every visited node ('loading', 'loaded', 'ok', 'error').
		 *     Pass an object to define custom key matchers for the path segments: {callback: function, matchKey: function}.
		 * @returns {$.Promise}
		 */
		loadKeyPath: function(keyPathList, optsOrCallback) {
			var callback,
				i,
				path,
				self = this,
				dfd = new $.Deferred(),
				parent = this.getRootNode(),
				sep = this.options.keyPathSeparator,
				pathSegList = [],
				opts = $.extend({}, optsOrCallback);

			// Prepare options
			if (typeof optsOrCallback === "function") {
				callback = optsOrCallback;
			} else if (optsOrCallback && optsOrCallback.callback) {
				callback = optsOrCallback.callback;
			}
			opts.callback = function(ctx, node, status) {
				if (callback) {
					callback.call(ctx, node, status);
				}
				dfd.notifyWith(ctx, [{ node: node, status: status }]);
			};
			if (opts.matchKey == null) {
				opts.matchKey = function(node, key) {
					return node.key === key;
				};
			}
			// Convert array of path strings to array of segment arrays
			if (!$.isArray(keyPathList)) {
				keyPathList = [keyPathList];
			}
			for (i = 0; i < keyPathList.length; i++) {
				path = keyPathList[i];
				// strip leading slash
				if (path.charAt(0) === sep) {
					path = path.substr(1);
				}
				// segListMap[path] = { parent: parent, segList: path.split(sep) };
				pathSegList.push(path.split(sep));
				// targetList.push({ parent: parent, segList: path.split(sep)/* , path: path*/});
			}
			// The timeout forces async behavior always (even if nodes are all loaded)
			// This way a potential progress() event will fire.
			setTimeout(function() {
				self._loadKeyPathImpl(dfd, opts, parent, pathSegList).done(
					function() {
						dfd.resolve();
					}
				);
			}, 0);
			return dfd.promise();
		},
		/*
		 * Resolve a list of paths, relative to one parent node.
		 */
		_loadKeyPathImpl: function(dfd, opts, parent, pathSegList) {
			var deferredList,
				i,
				key,
				node,
				remainMap,
				tmpParent,
				segList,
				subDfd,
				self = this;

			function __findChild(parent, key) {
				// console.log("__findChild", key, parent);
				var i,
					l,
					cl = parent.children;

				if (cl) {
					for (i = 0, l = cl.length; i < l; i++) {
						if (opts.matchKey(cl[i], key)) {
							return cl[i];
						}
					}
				}
				return null;
			}

			// console.log("_loadKeyPathImpl, parent=", parent, ", pathSegList=", pathSegList);

			// Pass 1:
			// Handle all path segments for nodes that are already loaded.
			// Collect distinct top-most lazy nodes in a map.
			// Note that we can use node.key to de-dupe entries, even if a custom matcher would
			// look for other node attributes.
			// map[node.key] => {node: node, pathList: [list of remaining rest-paths]}
			remainMap = {};

			for (i = 0; i < pathSegList.length; i++) {
				segList = pathSegList[i];
				// target = targetList[i];

				// Traverse and pop path segments (i.e. keys), until we hit a lazy, unloaded node
				tmpParent = parent;
				while (segList.length) {
					key = segList.shift();
					node = __findChild(tmpParent, key);
					if (!node) {
						this.warn(
							"loadKeyPath: key not found: " +
								key +
								" (parent: " +
								tmpParent +
								")"
						);
						opts.callback(this, key, "error");
						break;
					} else if (segList.length === 0) {
						opts.callback(this, node, "ok");
						break;
					} else if (!node.lazy || node.hasChildren() !== undefined) {
						opts.callback(this, node, "loaded");
						tmpParent = node;
					} else {
						opts.callback(this, node, "loaded");
						key = node.key; //target.segList.join(sep);
						if (remainMap[key]) {
							remainMap[key].pathSegList.push(segList);
						} else {
							remainMap[key] = {
								parent: node,
								pathSegList: [segList],
							};
						}
						break;
					}
				}
			}
			// console.log("_loadKeyPathImpl AFTER pass 1, remainMap=", remainMap);

			// Now load all lazy nodes and continue iteration for remaining paths
			deferredList = [];

			// Avoid jshint warning 'Don't make functions within a loop.':
			function __lazyload(dfd, parent, pathSegList) {
				// console.log("__lazyload", parent, "pathSegList=", pathSegList);
				opts.callback(self, parent, "loading");
				parent
					.load()
					.done(function() {
						self._loadKeyPathImpl
							.call(self, dfd, opts, parent, pathSegList)
							.always(_makeResolveFunc(dfd, self));
					})
					.fail(function(errMsg) {
						self.warn("loadKeyPath: error loading lazy " + parent);
						opts.callback(self, node, "error");
						dfd.rejectWith(self);
					});
			}
			// remainMap contains parent nodes, each with a list of relative sub-paths.
			// We start loading all of them now, and pass the the list to each loader.
			for (var nodeKey in remainMap) {
				var remain = remainMap[nodeKey];
				// console.log("for(): remain=", remain, "remainMap=", remainMap);
				// key = remain.segList.shift();
				// node = __findChild(remain.parent, key);
				// if (node == null) {  // #576
				// 	// Issue #576, refactored for v2.27:
				// 	// The root cause was, that sometimes the wrong parent was used here
				// 	// to find the next segment.
				// 	// Falling back to getNodeByKey() was a hack that no longer works if a custom
				// 	// matcher is used, because we cannot assume that a single segment-key is unique
				// 	// throughout the tree.
				// 	self.error("loadKeyPath: error loading child by key '" + key + "' (parent: " + target.parent + ")", target);
				// 	// 	node = self.getNodeByKey(key);
				// 	continue;
				// }
				subDfd = new $.Deferred();
				deferredList.push(subDfd);
				__lazyload(subDfd, remain.parent, remain.pathSegList);
			}
			// Return a promise that is resolved, when ALL paths were loaded
			return $.when.apply($, deferredList).promise();
		},
		/** Re-fire beforeActivate, activate, and (optional) focus events.
		 * Calling this method in the `init` event, will activate the node that
		 * was marked 'active' in the source data, and optionally set the keyboard
		 * focus.
		 * @param [setFocus=false]
		 */
		reactivate: function(setFocus) {
			var res,
				node = this.activeNode;

			if (!node) {
				return _getResolvedPromise();
			}
			this.activeNode = null; // Force re-activating
			res = node.setActive(true, { noFocus: true });
			if (setFocus) {
				node.setFocus();
			}
			return res;
		},
		/** Reload tree from source and return a promise.
		 * @param [source] optional new source (defaults to initial source data)
		 * @returns {$.Promise}
		 */
		reload: function(source) {
			this._callHook("treeClear", this);
			return this._callHook("treeLoad", this, source);
		},
		/**Render tree (i.e. create DOM elements for all top-level nodes).
		 * @param {boolean} [force=false] create DOM elemnts, even if parent is collapsed
		 * @param {boolean} [deep=false]
		 */
		render: function(force, deep) {
			return this.rootNode.render(force, deep);
		},
		/**(De)select all nodes.
		 * @param {boolean} [flag=true]
		 * @since 2.28
		 */
		selectAll: function(flag) {
			this.visit(function(node) {
				node.setSelected(flag);
			});
		},
		// TODO: selectKey: function(key, select)
		// TODO: serializeArray: function(stopOnParents)
		/**
		 * @param {boolean} [flag=true]
		 */
		setFocus: function(flag) {
			return this._callHook("treeSetFocus", this, flag);
		},
		/**
		 * Set current option value.
		 * (Note: this is the preferred variant of `$().fancytree("option", "KEY", VALUE)`)
		 * @param {string} name option name (may contain '.')
		 * @param {any} new value
		 */
		setOption: function(optionName, value) {
			return this.widget.option(optionName, value);
		},
		/**
		 * Return all nodes as nested list of {@link NodeData}.
		 *
		 * @param {boolean} [includeRoot=false] Returns the hidden system root node (and its children)
		 * @param {function} [callback] callback(dict, node) is called for every node, in order to allow modifications
		 * @returns {Array | object}
		 * @see FancytreeNode#toDict
		 */
		toDict: function(includeRoot, callback) {
			var res = this.rootNode.toDict(true, callback);
			return includeRoot ? res : res.children;
		},
		/* Implicitly called for string conversions.
		 * @returns {string}
		 */
		toString: function() {
			return "Fancytree@" + this._id;
			// return "<Fancytree(#" + this._id + ")>";
		},
		/* _trigger a widget event with additional node ctx.
		 * @see EventData
		 */
		_triggerNodeEvent: function(type, node, originalEvent, extra) {
			//		this.debug("_trigger(" + type + "): '" + ctx.node.title + "'", ctx);
			var ctx = this._makeHookContext(node, originalEvent, extra),
				res = this.widget._trigger(type, originalEvent, ctx);
			if (res !== false && ctx.result !== undefined) {
				return ctx.result;
			}
			return res;
		},
		/* _trigger a widget event with additional tree data. */
		_triggerTreeEvent: function(type, originalEvent, extra) {
			//		this.debug("_trigger(" + type + ")", ctx);
			var ctx = this._makeHookContext(this, originalEvent, extra),
				res = this.widget._trigger(type, originalEvent, ctx);

			if (res !== false && ctx.result !== undefined) {
				return ctx.result;
			}
			return res;
		},
		/** Call fn(node) for all nodes in hierarchical order (depth-first).
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and children only.
		 * @returns {boolean} false, if the iterator was stopped.
		 */
		visit: function(fn) {
			return this.rootNode.visit(fn, false);
		},
		/** Call fn(node) for all nodes in vertical order, top down (or bottom up).<br>
		 * Stop iteration, if fn() returns false.<br>
		 * Return false if iteration was stopped.
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and children only.
		 * @param {object} [options]
		 *     Defaults:
		 *     {start: First top node, reverse: false, includeSelf: true, includeHidden: false}
		 * @returns {boolean}
		 * @since 2.28
		 */
		visitRows: function(fn, opts) {
			if (opts && opts.reverse) {
				delete opts.reverse;
				return this._visitRowsUp(fn, opts);
			}
			var i,
				nextIdx,
				parent,
				res,
				siblings,
				siblingOfs = 0,
				skipFirstNode = opts.includeSelf === false,
				includeHidden = !!opts.includeHidden,
				node = opts.start || this.rootNode.children[0];

			parent = node.parent;
			while (parent) {
				// visit siblings
				siblings = parent.children;
				nextIdx = siblings.indexOf(node) + siblingOfs;

				for (i = nextIdx; i < siblings.length; i++) {
					node = siblings[i];
					if (!skipFirstNode && fn(node) === false) {
						return false;
					}
					skipFirstNode = false;
					// Dive into node's child nodes
					if (
						node.children &&
						node.children.length &&
						(includeHidden || node.expanded)
					) {
						// Disable warning: Functions declared within loops referencing an outer
						// scoped variable may lead to confusing semantics:
						/*jshint -W083 */
						res = node.visit(function(n) {
							if (fn(n) === false) {
								return false;
							}
							if (!includeHidden && n.children && !n.expanded) {
								return "skip";
							}
						}, false);
						/*jshint +W083 */
						if (res === false) {
							return false;
						}
					}
				}
				// Visit parent nodes (bottom up)
				node = parent;
				parent = parent.parent;
				siblingOfs = 1; //
			}
			return true;
		},
		/* Call fn(node) for all nodes in vertical order, bottom up.
		 */
		_visitRowsUp: function(fn, opts) {
			var children,
				idx,
				parent,
				includeHidden = !!opts.includeHidden,
				node = opts.start || this.rootNode.children[0];

			while (true) {
				parent = node.parent;
				children = parent.children;

				if (children[0] === node) {
					// If this is already the first sibling, goto parent
					node = parent;
					children = parent.children;
				} else {
					// Otherwise, goto prev. sibling
					idx = children.indexOf(node);
					node = children[idx - 1];
					// If the prev. sibling has children, follow down to last descendant
					while (
						(includeHidden || node.expanded) &&
						node.children &&
						node.children.length
					) {
						children = node.children;
						parent = node;
						node = children[children.length - 1];
					}
				}
				// Skip invisible
				if (!includeHidden && !$(node.span).is(":visible")) {
					continue;
				}
				if (fn(node) === false) {
					return false;
				}
			}
		},
		/** Write warning to browser console if debugLevel >= 2 (prepending tree info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		warn: function(msg) {
			if (this.options.debugLevel >= 2) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("warn", arguments);
			}
		},
	};

	/**
	 * These additional methods of the {@link Fancytree} class are 'hook functions'
	 * that can be used and overloaded by extensions.
	 * (See <a href="https://github.com/mar10/fancytree/wiki/TutorialExtensions">writing extensions</a>.)
	 * @mixin Fancytree_Hooks
	 */
	$.extend(
		Fancytree.prototype,
		/** @lends Fancytree_Hooks# */
		{
			/** Default handling for mouse click events.
			 *
			 * @param {EventData} ctx
			 */
			nodeClick: function(ctx) {
				var activate,
					expand,
					// event = ctx.originalEvent,
					targetType = ctx.targetType,
					node = ctx.node;

				// this.debug("ftnode.onClick(" + event.type + "): ftnode:" + this + ", button:" + event.button + ", which: " + event.which, ctx);
				// TODO: use switch
				// TODO: make sure clicks on embedded <input> doesn't steal focus (see table sample)
				if (targetType === "expander") {
					if (node.isLoading()) {
						// #495: we probably got a click event while a lazy load is pending.
						// The 'expanded' state is not yet set, so 'toggle' would expand
						// and trigger lazyLoad again.
						// It would be better to allow to collapse/expand the status node
						// while loading (instead of ignoring), but that would require some
						// more work.
						node.debug("Got 2nd click while loading: ignored");
						return;
					}
					// Clicking the expander icon always expands/collapses
					this._callHook("nodeToggleExpanded", ctx);
				} else if (targetType === "checkbox") {
					// Clicking the checkbox always (de)selects
					this._callHook("nodeToggleSelected", ctx);
					if (ctx.options.focusOnSelect) {
						// #358
						this._callHook("nodeSetFocus", ctx, true);
					}
				} else {
					// Honor `clickFolderMode` for
					expand = false;
					activate = true;
					if (node.folder) {
						switch (ctx.options.clickFolderMode) {
							case 2: // expand only
								expand = true;
								activate = false;
								break;
							case 3: // expand and activate
								activate = true;
								expand = true; //!node.isExpanded();
								break;
							// else 1 or 4: just activate
						}
					}
					if (activate) {
						this.nodeSetFocus(ctx);
						this._callHook("nodeSetActive", ctx, true);
					}
					if (expand) {
						if (!activate) {
							// this._callHook("nodeSetFocus", ctx);
						}
						// this._callHook("nodeSetExpanded", ctx, true);
						this._callHook("nodeToggleExpanded", ctx);
					}
				}
				// Make sure that clicks stop, otherwise <a href='#'> jumps to the top
				// if(event.target.localName === "a" && event.target.className === "fancytree-title"){
				// 	event.preventDefault();
				// }
				// TODO: return promise?
			},
			/** Collapse all other  children of same parent.
			 *
			 * @param {EventData} ctx
			 * @param {object} callOpts
			 */
			nodeCollapseSiblings: function(ctx, callOpts) {
				// TODO: return promise?
				var ac,
					i,
					l,
					node = ctx.node;

				if (node.parent) {
					ac = node.parent.children;
					for (i = 0, l = ac.length; i < l; i++) {
						if (ac[i] !== node && ac[i].expanded) {
							this._callHook(
								"nodeSetExpanded",
								ac[i],
								false,
								callOpts
							);
						}
					}
				}
			},
			/** Default handling for mouse douleclick events.
			 * @param {EventData} ctx
			 */
			nodeDblclick: function(ctx) {
				// TODO: return promise?
				if (
					ctx.targetType === "title" &&
					ctx.options.clickFolderMode === 4
				) {
					// this.nodeSetFocus(ctx);
					// this._callHook("nodeSetActive", ctx, true);
					this._callHook("nodeToggleExpanded", ctx);
				}
				// TODO: prevent text selection on dblclicks
				if (ctx.targetType === "title") {
					ctx.originalEvent.preventDefault();
				}
			},
			/** Default handling for mouse keydown events.
			 *
			 * NOTE: this may be called with node == null if tree (but no node) has focus.
			 * @param {EventData} ctx
			 */
			nodeKeydown: function(ctx) {
				// TODO: return promise?
				var matchNode,
					stamp,
					res,
					focusNode,
					event = ctx.originalEvent,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					which = event.which,
					// #909: Use event.key, to get unicode characters.
					// We can't use `/\w/.test(key)`, because that would
					// only detect plain ascii alpha-numerics. But we still need
					// to ignore modifier-only, whitespace, cursor-keys, etc.
					key = event.key || String.fromCharCode(which),
					specialModifiers = !!(
						event.altKey ||
						event.ctrlKey ||
						event.metaKey
					),
					isAlnum =
						!MODIFIERS[which] &&
						!SPECIAL_KEYCODES[which] &&
						!specialModifiers,
					$target = $(event.target),
					handled = true,
					activate = !(event.ctrlKey || !opts.autoActivate);

				// (node || FT).debug("ftnode.nodeKeydown(" + event.type + "): ftnode:" + this + ", charCode:" + event.charCode + ", keyCode: " + event.keyCode + ", which: " + event.which);
				// FT.debug( "eventToString(): " + FT.eventToString(event) + ", key='" + key + "', isAlnum: " + isAlnum );

				// Set focus to active (or first node) if no other node has the focus yet
				if (!node) {
					focusNode = this.getActiveNode() || this.getFirstChild();
					if (focusNode) {
						focusNode.setFocus();
						node = ctx.node = this.focusNode;
						node.debug("Keydown force focus on active node");
					}
				}

				if (
					opts.quicksearch &&
					isAlnum &&
					!$target.is(":input:enabled")
				) {
					// Allow to search for longer streaks if typed in quickly
					stamp = Date.now();
					if (stamp - tree.lastQuicksearchTime > 500) {
						tree.lastQuicksearchTerm = "";
					}
					tree.lastQuicksearchTime = stamp;
					tree.lastQuicksearchTerm += key;
					// tree.debug("quicksearch find", tree.lastQuicksearchTerm);
					matchNode = tree.findNextNode(
						tree.lastQuicksearchTerm,
						tree.getActiveNode()
					);
					if (matchNode) {
						matchNode.setActive();
					}
					event.preventDefault();
					return;
				}
				switch (FT.eventToString(event)) {
					case "+":
					case "=": // 187: '+' @ Chrome, Safari
						tree.nodeSetExpanded(ctx, true);
						break;
					case "-":
						tree.nodeSetExpanded(ctx, false);
						break;
					case "space":
						if (node.isPagingNode()) {
							tree._triggerNodeEvent("clickPaging", ctx, event);
						} else if (
							FT.evalOption("checkbox", node, node, opts, false)
						) {
							// #768
							tree.nodeToggleSelected(ctx);
						} else {
							tree.nodeSetActive(ctx, true);
						}
						break;
					case "return":
						tree.nodeSetActive(ctx, true);
						break;
					case "home":
					case "end":
					case "backspace":
					case "left":
					case "right":
					case "up":
					case "down":
						res = node.navigate(event.which, activate);
						break;
					default:
						handled = false;
				}
				if (handled) {
					event.preventDefault();
				}
			},

			// /** Default handling for mouse keypress events. */
			// nodeKeypress: function(ctx) {
			//     var event = ctx.originalEvent;
			// },

			// /** Trigger lazyLoad event (async). */
			// nodeLazyLoad: function(ctx) {
			//     var node = ctx.node;
			//     if(this._triggerNodeEvent())
			// },
			/** Load child nodes (async).
			 *
			 * @param {EventData} ctx
			 * @param {object[]|object|string|$.Promise|function} source
			 * @returns {$.Promise} The deferred will be resolved as soon as the (ajax)
			 *     data was rendered.
			 */
			nodeLoadChildren: function(ctx, source) {
				var ajax,
					delay,
					dfd,
					tree = ctx.tree,
					node = ctx.node,
					requestId = Date.now();

				if ($.isFunction(source)) {
					source = source.call(tree, { type: "source" }, ctx);
					_assert(
						!$.isFunction(source),
						"source callback must not return another function"
					);
				}
				if (source.url) {
					if (node._requestId) {
						node.warn(
							"Recursive load request #" +
								requestId +
								" while #" +
								node._requestId +
								" is pending."
						);
						// } else {
						// 	node.debug("Send load request #" + requestId);
					}
					// `source` is an Ajax options object
					ajax = $.extend({}, ctx.options.ajax, source);
					node._requestId = requestId;
					if (ajax.debugDelay) {
						// simulate a slow server
						delay = ajax.debugDelay;
						delete ajax.debugDelay; // remove debug option
						if ($.isArray(delay)) {
							// random delay range [min..max]
							delay =
								delay[0] +
								Math.random() * (delay[1] - delay[0]);
						}
						node.warn(
							"nodeLoadChildren waiting debugDelay " +
								Math.round(delay) +
								" ms ..."
						);
						dfd = $.Deferred(function(dfd) {
							setTimeout(function() {
								$.ajax(ajax)
									.done(function() {
										dfd.resolveWith(this, arguments);
									})
									.fail(function() {
										dfd.rejectWith(this, arguments);
									});
							}, delay);
						});
					} else {
						dfd = $.ajax(ajax);
					}

					// Defer the deferred: we want to be able to reject, even if ajax
					// resolved ok.
					source = new $.Deferred();
					dfd.done(function(data, textStatus, jqXHR) {
						var errorObj, res;

						if (
							(this.dataType === "json" ||
								this.dataType === "jsonp") &&
							typeof data === "string"
						) {
							$.error(
								"Ajax request returned a string (did you get the JSON dataType wrong?)."
							);
						}
						if (node._requestId && node._requestId > requestId) {
							// The expected request time stamp is later than `requestId`
							// (which was kept as as closure variable to this handler function)
							// node.warn("Ignored load response for obsolete request #" + requestId + " (expected #" + node._requestId + ")");
							source.rejectWith(this, [RECURSIVE_REQUEST_ERROR]);
							return;
							// } else {
							// 	node.debug("Response returned for load request #" + requestId);
						}
						// postProcess is similar to the standard ajax dataFilter hook,
						// but it is also called for JSONP
						if (ctx.options.postProcess) {
							try {
								// The handler may either
								//   - modify `ctx.response` in-place (and leave `ctx.result` undefined)
								//     => res = undefined
								//   - return a replacement in `ctx.result`
								//     => res = <new data>
								// If res contains an `error` property, an error status is displayed
								res = tree._triggerNodeEvent(
									"postProcess",
									ctx,
									ctx.originalEvent,
									{
										response: data,
										error: null,
										dataType: this.dataType,
									}
								);
							} catch (e) {
								res = {
									error: e,
									message: "" + e,
									details: "postProcess failed",
								};
							}
							if (res.error) {
								errorObj = $.isPlainObject(res.error)
									? res.error
									: { message: res.error };
								errorObj = tree._makeHookContext(
									node,
									null,
									errorObj
								);
								source.rejectWith(this, [errorObj]);
								return;
							}
							if (
								$.isArray(res) ||
								($.isPlainObject(res) &&
									$.isArray(res.children))
							) {
								// Use `ctx.result` if valid
								// (otherwise use existing data, which may have been modified in-place)
								data = res;
							}
						} else if (
							data &&
							data.hasOwnProperty("d") &&
							ctx.options.enableAspx
						) {
							// Process ASPX WebMethod JSON object inside "d" property
							data =
								typeof data.d === "string"
									? $.parseJSON(data.d)
									: data.d;
						}
						source.resolveWith(this, [data]);
					}).fail(function(jqXHR, textStatus, errorThrown) {
						var errorObj = tree._makeHookContext(node, null, {
							error: jqXHR,
							args: Array.prototype.slice.call(arguments),
							message: errorThrown,
							details: jqXHR.status + ": " + errorThrown,
						});
						source.rejectWith(this, [errorObj]);
					});
				}
				// #383: accept and convert ECMAScript 6 Promise
				if (
					$.isFunction(source.then) &&
					$.isFunction(source["catch"])
				) {
					dfd = source;
					source = new $.Deferred();
					dfd.then(
						function(value) {
							source.resolve(value);
						},
						function(reason) {
							source.reject(reason);
						}
					);
				}
				if ($.isFunction(source.promise)) {
					// `source` is a deferred, i.e. ajax request
					// _assert(!node.isLoading(), "recursive load");
					tree.nodeSetStatus(ctx, "loading");

					source
						.done(function(children) {
							tree.nodeSetStatus(ctx, "ok");
							node._requestId = null;
						})
						.fail(function(error) {
							var ctxErr;

							if (error === RECURSIVE_REQUEST_ERROR) {
								node.warn(
									"Ignored response for obsolete load request #" +
										requestId +
										" (expected #" +
										node._requestId +
										")"
								);
								return;
							} else if (
								error.node &&
								error.error &&
								error.message
							) {
								// error is already a context object
								ctxErr = error;
							} else {
								ctxErr = tree._makeHookContext(node, null, {
									error: error, // it can be jqXHR or any custom error
									args: Array.prototype.slice.call(arguments),
									message: error
										? error.message || error.toString()
										: "",
								});
								if (ctxErr.message === "[object Object]") {
									ctxErr.message = "";
								}
							}
							node.warn(
								"Load children failed (" + ctxErr.message + ")",
								ctxErr
							);
							if (
								tree._triggerNodeEvent(
									"loadError",
									ctxErr,
									null
								) !== false
							) {
								tree.nodeSetStatus(
									ctx,
									"error",
									ctxErr.message,
									ctxErr.details
								);
							}
						});
				} else {
					if (ctx.options.postProcess) {
						// #792: Call postProcess for non-deferred source
						var res = tree._triggerNodeEvent(
							"postProcess",
							ctx,
							ctx.originalEvent,
							{
								response: source,
								error: null,
								dataType: typeof source,
							}
						);

						if (
							$.isArray(res) ||
							($.isPlainObject(res) && $.isArray(res.children))
						) {
							// Use `ctx.result` if valid
							// (otherwise use existing data, which may have been modified in-place)
							source = res;
						}
					}
				}
				// $.when(source) resolves also for non-deferreds
				return $.when(source).done(function(children) {
					var metaData, noDataRes;

					if ($.isPlainObject(children)) {
						// We got {foo: 'abc', children: [...]}
						// Copy extra properties to tree.data.foo
						_assert(
							node.isRootNode(),
							"source may only be an object for root nodes (expecting an array of child objects otherwise)"
						);
						_assert(
							$.isArray(children.children),
							"if an object is passed as source, it must contain a 'children' array (all other properties are added to 'tree.data')"
						);
						metaData = children;
						children = children.children;
						delete metaData.children;
						// Copy some attributes to tree.data
						$.each(TREE_ATTRS, function(i, attr) {
							if (metaData[attr] !== undefined) {
								tree[attr] = metaData[attr];
								delete metaData[attr];
							}
						});
						// Copy all other attributes to tree.data.NAME
						$.extend(tree.data, metaData);
					}
					_assert($.isArray(children), "expected array of children");
					node._setChildren(children);

					if (tree.options.nodata && children.length === 0) {
						if ($.isFunction(tree.options.nodata)) {
							noDataRes = tree.options.nodata.call(
								tree,
								{ type: "nodata" },
								ctx
							);
						} else if (
							tree.options.nodata === true &&
							node.isRootNode()
						) {
							noDataRes = tree.options.strings.nodata;
						} else if (
							typeof tree.options.nodata === "string" &&
							node.isRootNode()
						) {
							noDataRes = tree.options.nodata;
						}
						if (noDataRes) {
							node.setStatus("nodata", noDataRes);
						}
					}
					// trigger fancytreeloadchildren
					tree._triggerNodeEvent("loadChildren", node);
				});
			},
			/** [Not Implemented]  */
			nodeLoadKeyPath: function(ctx, keyPathList) {
				// TODO: implement and improve
				// http://code.google.com/p/dynatree/issues/detail?id=222
			},
			/**
			 * Remove a single direct child of ctx.node.
			 * @param {EventData} ctx
			 * @param {FancytreeNode} childNode dircect child of ctx.node
			 */
			nodeRemoveChild: function(ctx, childNode) {
				var idx,
					node = ctx.node,
					// opts = ctx.options,
					subCtx = $.extend({}, ctx, { node: childNode }),
					children = node.children;

				// FT.debug("nodeRemoveChild()", node.toString(), childNode.toString());

				if (children.length === 1) {
					_assert(childNode === children[0], "invalid single child");
					return this.nodeRemoveChildren(ctx);
				}
				if (
					this.activeNode &&
					(childNode === this.activeNode ||
						this.activeNode.isDescendantOf(childNode))
				) {
					this.activeNode.setActive(false); // TODO: don't fire events
				}
				if (
					this.focusNode &&
					(childNode === this.focusNode ||
						this.focusNode.isDescendantOf(childNode))
				) {
					this.focusNode = null;
				}
				// TODO: persist must take care to clear select and expand cookies
				this.nodeRemoveMarkup(subCtx);
				this.nodeRemoveChildren(subCtx);
				idx = $.inArray(childNode, children);
				_assert(idx >= 0, "invalid child");
				// Notify listeners
				node.triggerModifyChild("remove", childNode);
				// Unlink to support GC
				childNode.visit(function(n) {
					n.parent = null;
				}, true);
				this._callHook("treeRegisterNode", this, false, childNode);
				// remove from child list
				children.splice(idx, 1);
			},
			/**Remove HTML markup for all descendents of ctx.node.
			 * @param {EventData} ctx
			 */
			nodeRemoveChildMarkup: function(ctx) {
				var node = ctx.node;

				// FT.debug("nodeRemoveChildMarkup()", node.toString());
				// TODO: Unlink attr.ftnode to support GC
				if (node.ul) {
					if (node.isRootNode()) {
						$(node.ul).empty();
					} else {
						$(node.ul).remove();
						node.ul = null;
					}
					node.visit(function(n) {
						n.li = n.ul = null;
					});
				}
			},
			/**Remove all descendants of ctx.node.
			 * @param {EventData} ctx
			 */
			nodeRemoveChildren: function(ctx) {
				var subCtx,
					tree = ctx.tree,
					node = ctx.node,
					children = node.children;
				// opts = ctx.options;

				// FT.debug("nodeRemoveChildren()", node.toString());
				if (!children) {
					return;
				}
				if (this.activeNode && this.activeNode.isDescendantOf(node)) {
					this.activeNode.setActive(false); // TODO: don't fire events
				}
				if (this.focusNode && this.focusNode.isDescendantOf(node)) {
					this.focusNode = null;
				}
				// TODO: persist must take care to clear select and expand cookies
				this.nodeRemoveChildMarkup(ctx);
				// Unlink children to support GC
				// TODO: also delete this.children (not possible using visit())
				subCtx = $.extend({}, ctx);
				node.triggerModifyChild("remove", null);
				node.visit(function(n) {
					n.parent = null;
					tree._callHook("treeRegisterNode", tree, false, n);
				});
				if (node.lazy) {
					// 'undefined' would be interpreted as 'not yet loaded' for lazy nodes
					node.children = [];
				} else {
					node.children = null;
				}
				if (!node.isRootNode()) {
					node.expanded = false; // #449, #459
				}
				this.nodeRenderStatus(ctx);
			},
			/**Remove HTML markup for ctx.node and all its descendents.
			 * @param {EventData} ctx
			 */
			nodeRemoveMarkup: function(ctx) {
				var node = ctx.node;
				// FT.debug("nodeRemoveMarkup()", node.toString());
				// TODO: Unlink attr.ftnode to support GC
				if (node.li) {
					$(node.li).remove();
					node.li = null;
				}
				this.nodeRemoveChildMarkup(ctx);
			},
			/**
			 * Create `&lt;li>&lt;span>..&lt;/span> .. &lt;/li>` tags for this node.
			 *
			 * This method takes care that all HTML markup is created that is required
			 * to display this node in its current state.
			 *
			 * Call this method to create new nodes, or after the strucuture
			 * was changed (e.g. after moving this node or adding/removing children)
			 * nodeRenderTitle() and nodeRenderStatus() are implied.
			 *
			 * &lt;code>
			 * &lt;li id='KEY' ftnode=NODE>
			 *     &lt;span class='fancytree-node fancytree-expanded fancytree-has-children fancytree-lastsib fancytree-exp-el fancytree-ico-e'>
			 *         &lt;span class="fancytree-expander">&lt;/span>
			 *         &lt;span class="fancytree-checkbox">&lt;/span> // only present in checkbox mode
			 *         &lt;span class="fancytree-icon">&lt;/span>
			 *         &lt;a href="#" class="fancytree-title"> Node 1 &lt;/a>
			 *     &lt;/span>
			 *     &lt;ul> // only present if node has children
			 *         &lt;li id='KEY' ftnode=NODE> child1 ... &lt;/li>
			 *         &lt;li id='KEY' ftnode=NODE> child2 ... &lt;/li>
			 *     &lt;/ul>
			 * &lt;/li>
			 * &lt;/code>
			 *
			 * @param {EventData} ctx
			 * @param {boolean} [force=false] re-render, even if html markup was already created
			 * @param {boolean} [deep=false] also render all descendants, even if parent is collapsed
			 * @param {boolean} [collapsed=false] force root node to be collapsed, so we can apply animated expand later
			 */
			nodeRender: function(ctx, force, deep, collapsed, _recursive) {
				/* This method must take care of all cases where the current data mode
				 * (i.e. node hierarchy) does not match the current markup.
				 *
				 * - node was not yet rendered:
				 *   create markup
				 * - node was rendered: exit fast
				 * - children have been added
				 * - children have been removed
				 */
				var childLI,
					childNode1,
					childNode2,
					i,
					l,
					next,
					subCtx,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					aria = opts.aria,
					firstTime = false,
					parent = node.parent,
					isRootNode = !parent,
					children = node.children,
					successorLi = null;
				// FT.debug("nodeRender(" + !!force + ", " + !!deep + ")", node.toString());

				if (tree._enableUpdate === false) {
					// tree.debug("no render", tree._enableUpdate);
					return;
				}
				if (!isRootNode && !parent.ul) {
					// Calling node.collapse on a deep, unrendered node
					return;
				}
				_assert(isRootNode || parent.ul, "parent UL must exist");

				// Render the node
				if (!isRootNode) {
					// Discard markup on force-mode, or if it is not linked to parent <ul>
					if (
						node.li &&
						(force || node.li.parentNode !== node.parent.ul)
					) {
						if (node.li.parentNode === node.parent.ul) {
							// #486: store following node, so we can insert the new markup there later
							successorLi = node.li.nextSibling;
						} else {
							// May happen, when a top-level node was dropped over another
							this.debug(
								"Unlinking " +
									node +
									" (must be child of " +
									node.parent +
									")"
							);
						}
						//	            this.debug("nodeRemoveMarkup...");
						this.nodeRemoveMarkup(ctx);
					}
					// Create <li><span /> </li>
					// node.debug("render...");
					if (!node.li) {
						//	            node.debug("render... really");
						firstTime = true;
						node.li = document.createElement("li");
						node.li.ftnode = node;

						if (node.key && opts.generateIds) {
							node.li.id = opts.idPrefix + node.key;
						}
						node.span = document.createElement("span");
						node.span.className = "fancytree-node";
						if (aria && !node.tr) {
							$(node.li).attr("role", "treeitem");
						}
						node.li.appendChild(node.span);

						// Create inner HTML for the <span> (expander, checkbox, icon, and title)
						this.nodeRenderTitle(ctx);

						// Allow tweaking and binding, after node was created for the first time
						if (opts.createNode) {
							opts.createNode.call(
								tree,
								{ type: "createNode" },
								ctx
							);
						}
					} else {
						// this.nodeRenderTitle(ctx);
						this.nodeRenderStatus(ctx);
					}
					// Allow tweaking after node state was rendered
					if (opts.renderNode) {
						opts.renderNode.call(tree, { type: "renderNode" }, ctx);
					}
				}

				// Visit child nodes
				if (children) {
					if (isRootNode || node.expanded || deep === true) {
						// Create a UL to hold the children
						if (!node.ul) {
							node.ul = document.createElement("ul");
							if (
								(collapsed === true && !_recursive) ||
								!node.expanded
							) {
								// hide top UL, so we can use an animation to show it later
								node.ul.style.display = "none";
							}
							if (aria) {
								$(node.ul).attr("role", "group");
							}
							if (node.li) {
								// issue #67
								node.li.appendChild(node.ul);
							} else {
								node.tree.$div.append(node.ul);
							}
						}
						// Add child markup
						for (i = 0, l = children.length; i < l; i++) {
							subCtx = $.extend({}, ctx, { node: children[i] });
							this.nodeRender(subCtx, force, deep, false, true);
						}
						// Remove <li> if nodes have moved to another parent
						childLI = node.ul.firstChild;
						while (childLI) {
							childNode2 = childLI.ftnode;
							if (childNode2 && childNode2.parent !== node) {
								node.debug(
									"_fixParent: remove missing " + childNode2,
									childLI
								);
								next = childLI.nextSibling;
								childLI.parentNode.removeChild(childLI);
								childLI = next;
							} else {
								childLI = childLI.nextSibling;
							}
						}
						// Make sure, that <li> order matches node.children order.
						childLI = node.ul.firstChild;
						for (i = 0, l = children.length - 1; i < l; i++) {
							childNode1 = children[i];
							childNode2 = childLI.ftnode;
							if (childNode1 !== childNode2) {
								// node.debug("_fixOrder: mismatch at index " + i + ": " + childNode1 + " != " + childNode2);
								node.ul.insertBefore(
									childNode1.li,
									childNode2.li
								);
							} else {
								childLI = childLI.nextSibling;
							}
						}
					}
				} else {
					// No children: remove markup if any
					if (node.ul) {
						// alert("remove child markup for " + node);
						this.warn("remove child markup for " + node);
						this.nodeRemoveChildMarkup(ctx);
					}
				}
				if (!isRootNode) {
					// Update element classes according to node state
					// this.nodeRenderStatus(ctx);
					// Finally add the whole structure to the DOM, so the browser can render
					if (firstTime) {
						// #486: successorLi is set, if we re-rendered (i.e. discarded)
						// existing markup, which  we want to insert at the same position.
						// (null is equivalent to append)
						//				parent.ul.appendChild(node.li);
						parent.ul.insertBefore(node.li, successorLi);
					}
				}
			},
			/** Create HTML inside the node's outer &lt;span> (i.e. expander, checkbox,
			 * icon, and title).
			 *
			 * nodeRenderStatus() is implied.
			 * @param {EventData} ctx
			 * @param {string} [title] optinal new title
			 */
			nodeRenderTitle: function(ctx, title) {
				// set node connector images, links and text
				var checkbox,
					className,
					icon,
					nodeTitle,
					role,
					tabindex,
					tooltip,
					iconTooltip,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					aria = opts.aria,
					level = node.getLevel(),
					ares = [];

				if (title !== undefined) {
					node.title = title;
				}
				if (!node.span || tree._enableUpdate === false) {
					// Silently bail out if node was not rendered yet, assuming
					// node.render() will be called as the node becomes visible
					return;
				}
				// Connector (expanded, expandable or simple)
				role =
					aria && node.hasChildren() !== false
						? " role='button'"
						: "";
				if (level < opts.minExpandLevel) {
					if (!node.lazy) {
						node.expanded = true;
					}
					if (level > 1) {
						ares.push(
							"<span " +
								role +
								" class='fancytree-expander fancytree-expander-fixed'></span>"
						);
					}
					// .. else (i.e. for root level) skip expander/connector alltogether
				} else {
					ares.push(
						"<span " + role + " class='fancytree-expander'></span>"
					);
				}
				// Checkbox mode
				checkbox = FT.evalOption("checkbox", node, node, opts, false);

				if (checkbox && !node.isStatusNode()) {
					role = aria ? " role='checkbox'" : "";
					className = "fancytree-checkbox";
					if (
						checkbox === "radio" ||
						(node.parent && node.parent.radiogroup)
					) {
						className += " fancytree-radio";
					}
					ares.push(
						"<span " + role + " class='" + className + "'></span>"
					);
				}
				// Folder or doctype icon
				if (node.data.iconClass !== undefined) {
					// 2015-11-16
					// Handle / warn about backward compatibility
					if (node.icon) {
						$.error(
							"'iconClass' node option is deprecated since v2.14.0: use 'icon' only instead"
						);
					} else {
						node.warn(
							"'iconClass' node option is deprecated since v2.14.0: use 'icon' instead"
						);
						node.icon = node.data.iconClass;
					}
				}
				// If opts.icon is a callback and returns something other than undefined, use that
				// else if node.icon is a boolean or string, use that
				// else if opts.icon is a boolean or string, use that
				// else show standard icon (which may be different for folders or documents)
				icon = FT.evalOption("icon", node, node, opts, true);
				// if( typeof icon !== "boolean" ) {
				// 	// icon is defined, but not true/false: must be a string
				// 	icon = "" + icon;
				// }
				if (icon !== false) {
					role = aria ? " role='presentation'" : "";

					iconTooltip = FT.evalOption(
						"iconTooltip",
						node,
						node,
						opts,
						null
					);
					iconTooltip = iconTooltip
						? " title='" + _escapeTooltip(iconTooltip) + "'"
						: "";

					if (typeof icon === "string") {
						if (TEST_IMG.test(icon)) {
							// node.icon is an image url. Prepend imagePath
							icon =
								icon.charAt(0) === "/"
									? icon
									: (opts.imagePath || "") + icon;
							ares.push(
								"<img src='" +
									icon +
									"' class='fancytree-icon'" +
									iconTooltip +
									" alt='' />"
							);
						} else {
							ares.push(
								"<span " +
									role +
									" class='fancytree-custom-icon " +
									icon +
									"'" +
									iconTooltip +
									"></span>"
							);
						}
					} else if (icon.text) {
						ares.push(
							"<span " +
								role +
								" class='fancytree-custom-icon " +
								(icon.addClass || "") +
								"'" +
								iconTooltip +
								">" +
								FT.escapeHtml(icon.text) +
								"</span>"
						);
					} else if (icon.html) {
						ares.push(
							"<span " +
								role +
								" class='fancytree-custom-icon " +
								(icon.addClass || "") +
								"'" +
								iconTooltip +
								">" +
								icon.html +
								"</span>"
						);
					} else {
						// standard icon: theme css will take care of this
						ares.push(
							"<span " +
								role +
								" class='fancytree-icon'" +
								iconTooltip +
								"></span>"
						);
					}
				}
				// Node title
				nodeTitle = "";
				if (opts.renderTitle) {
					nodeTitle =
						opts.renderTitle.call(
							tree,
							{ type: "renderTitle" },
							ctx
						) || "";
				}
				if (!nodeTitle) {
					tooltip = FT.evalOption("tooltip", node, node, opts, null);
					if (tooltip === true) {
						tooltip = node.title;
					}
					// if( node.tooltip ) {
					// 	tooltip = node.tooltip;
					// } else if ( opts.tooltip ) {
					// 	tooltip = opts.tooltip === true ? node.title : opts.tooltip.call(tree, node);
					// }
					tooltip = tooltip
						? " title='" + _escapeTooltip(tooltip) + "'"
						: "";
					tabindex = opts.titlesTabbable ? " tabindex='0'" : "";

					nodeTitle =
						"<span class='fancytree-title'" +
						tooltip +
						tabindex +
						">" +
						(opts.escapeTitles
							? FT.escapeHtml(node.title)
							: node.title) +
						"</span>";
				}
				ares.push(nodeTitle);
				// Note: this will trigger focusout, if node had the focus
				//$(node.span).html(ares.join("")); // it will cleanup the jQuery data currently associated with SPAN (if any), but it executes more slowly
				node.span.innerHTML = ares.join("");
				// Update CSS classes
				this.nodeRenderStatus(ctx);
				if (opts.enhanceTitle) {
					ctx.$title = $(">span.fancytree-title", node.span);
					nodeTitle =
						opts.enhanceTitle.call(
							tree,
							{ type: "enhanceTitle" },
							ctx
						) || "";
				}
			},
			/** Update element classes according to node state.
			 * @param {EventData} ctx
			 */
			nodeRenderStatus: function(ctx) {
				// Set classes for current status
				var $ariaElem,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					//			nodeContainer = node[tree.nodeContainerAttrName],
					hasChildren = node.hasChildren(),
					isLastSib = node.isLastSibling(),
					aria = opts.aria,
					cn = opts._classNames,
					cnList = [],
					statusElem = node[tree.statusClassPropName];

				if (!statusElem || tree._enableUpdate === false) {
					// if this function is called for an unrendered node, ignore it (will be updated on nect render anyway)
					return;
				}
				if (aria) {
					$ariaElem = $(node.tr || node.li);
				}
				// Build a list of class names that we will add to the node <span>
				cnList.push(cn.node);
				if (tree.activeNode === node) {
					cnList.push(cn.active);
					// 		$(">span.fancytree-title", statusElem).attr("tabindex", "0");
					// 		tree.$container.removeAttr("tabindex");
					// }else{
					// 		$(">span.fancytree-title", statusElem).removeAttr("tabindex");
					// 		tree.$container.attr("tabindex", "0");
				}
				if (tree.focusNode === node) {
					cnList.push(cn.focused);
				}
				if (node.expanded) {
					cnList.push(cn.expanded);
				}
				if (aria) {
					if (hasChildren !== false) {
						$ariaElem.attr("aria-expanded", Boolean(node.expanded));
					} else {
						$ariaElem.removeAttr("aria-expanded");
					}
				}
				if (node.folder) {
					cnList.push(cn.folder);
				}
				if (hasChildren !== false) {
					cnList.push(cn.hasChildren);
				}
				// TODO: required?
				if (isLastSib) {
					cnList.push(cn.lastsib);
				}
				if (node.lazy && node.children == null) {
					cnList.push(cn.lazy);
				}
				if (node.partload) {
					cnList.push(cn.partload);
				}
				if (node.partsel) {
					cnList.push(cn.partsel);
				}
				if (FT.evalOption("unselectable", node, node, opts, false)) {
					cnList.push(cn.unselectable);
				}
				if (node._isLoading) {
					cnList.push(cn.loading);
				}
				if (node._error) {
					cnList.push(cn.error);
				}
				if (node.statusNodeType) {
					cnList.push(cn.statusNodePrefix + node.statusNodeType);
				}
				if (node.selected) {
					cnList.push(cn.selected);
					if (aria) {
						$ariaElem.attr("aria-selected", true);
					}
				} else if (aria) {
					$ariaElem.attr("aria-selected", false);
				}
				if (node.extraClasses) {
					cnList.push(node.extraClasses);
				}
				// IE6 doesn't correctly evaluate multiple class names,
				// so we create combined class names that can be used in the CSS
				if (hasChildren === false) {
					cnList.push(
						cn.combinedExpanderPrefix + "n" + (isLastSib ? "l" : "")
					);
				} else {
					cnList.push(
						cn.combinedExpanderPrefix +
							(node.expanded ? "e" : "c") +
							(node.lazy && node.children == null ? "d" : "") +
							(isLastSib ? "l" : "")
					);
				}
				cnList.push(
					cn.combinedIconPrefix +
						(node.expanded ? "e" : "c") +
						(node.folder ? "f" : "")
				);
				// node.span.className = cnList.join(" ");
				statusElem.className = cnList.join(" ");

				// TODO: we should not set this in the <span> tag also, if we set it here:
				// Maybe most (all) of the classes should be set in LI instead of SPAN?
				if (node.li) {
					// #719: we have to consider that there may be already other classes:
					$(node.li).toggleClass(cn.lastsib, isLastSib);
				}
			},
			/** Activate node.
			 * flag defaults to true.
			 * If flag is true, the node is activated (must be a synchronous operation)
			 * If flag is false, the node is deactivated (must be a synchronous operation)
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 * @param {object} [opts] additional options. Defaults to {noEvents: false, noFocus: false}
			 * @returns {$.Promise}
			 */
			nodeSetActive: function(ctx, flag, callOpts) {
				// Handle user click / [space] / [enter], according to clickFolderMode.
				callOpts = callOpts || {};
				var subCtx,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					noEvents = callOpts.noEvents === true,
					noFocus = callOpts.noFocus === true,
					scroll = callOpts.scrollIntoView !== false,
					isActive = node === tree.activeNode;

				// flag defaults to true
				flag = flag !== false;
				// node.debug("nodeSetActive", flag);

				if (isActive === flag) {
					// Nothing to do
					return _getResolvedPromise(node);
				} else if (
					flag &&
					!noEvents &&
					this._triggerNodeEvent(
						"beforeActivate",
						node,
						ctx.originalEvent
					) === false
				) {
					// Callback returned false
					return _getRejectedPromise(node, ["rejected"]);
				}
				if (flag) {
					if (tree.activeNode) {
						_assert(
							tree.activeNode !== node,
							"node was active (inconsistency)"
						);
						subCtx = $.extend({}, ctx, { node: tree.activeNode });
						tree.nodeSetActive(subCtx, false);
						_assert(
							tree.activeNode === null,
							"deactivate was out of sync?"
						);
					}

					if (opts.activeVisible) {
						// If no focus is set (noFocus: true) and there is no focused node, this node is made visible.
						// scroll = noFocus && tree.focusNode == null;
						// #863: scroll by default (unless `scrollIntoView: false` was passed)
						node.makeVisible({ scrollIntoView: scroll });
					}
					tree.activeNode = node;
					tree.nodeRenderStatus(ctx);
					if (!noFocus) {
						tree.nodeSetFocus(ctx);
					}
					if (!noEvents) {
						tree._triggerNodeEvent(
							"activate",
							node,
							ctx.originalEvent
						);
					}
				} else {
					_assert(
						tree.activeNode === node,
						"node was not active (inconsistency)"
					);
					tree.activeNode = null;
					this.nodeRenderStatus(ctx);
					if (!noEvents) {
						ctx.tree._triggerNodeEvent(
							"deactivate",
							node,
							ctx.originalEvent
						);
					}
				}
				return _getResolvedPromise(node);
			},
			/** Expand or collapse node, return Deferred.promise.
			 *
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 * @param {object} [opts] additional options. Defaults to {noAnimation: false, noEvents: false}
			 * @returns {$.Promise} The deferred will be resolved as soon as the (lazy)
			 *     data was retrieved, rendered, and the expand animation finshed.
			 */
			nodeSetExpanded: function(ctx, flag, callOpts) {
				callOpts = callOpts || {};
				var _afterLoad,
					dfd,
					i,
					l,
					parents,
					prevAC,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					noAnimation = callOpts.noAnimation === true,
					noEvents = callOpts.noEvents === true;

				// flag defaults to true
				flag = flag !== false;

				// node.debug("nodeSetExpanded(" + flag + ")");

				if ((node.expanded && flag) || (!node.expanded && !flag)) {
					// Nothing to do
					// node.debug("nodeSetExpanded(" + flag + "): nothing to do");
					return _getResolvedPromise(node);
				} else if (flag && !node.lazy && !node.hasChildren()) {
					// Prevent expanding of empty nodes
					// return _getRejectedPromise(node, ["empty"]);
					return _getResolvedPromise(node);
				} else if (!flag && node.getLevel() < opts.minExpandLevel) {
					// Prevent collapsing locked levels
					return _getRejectedPromise(node, ["locked"]);
				} else if (
					!noEvents &&
					this._triggerNodeEvent(
						"beforeExpand",
						node,
						ctx.originalEvent
					) === false
				) {
					// Callback returned false
					return _getRejectedPromise(node, ["rejected"]);
				}
				// If this node inside a collpased node, no animation and scrolling is needed
				if (!noAnimation && !node.isVisible()) {
					noAnimation = callOpts.noAnimation = true;
				}

				dfd = new $.Deferred();

				// Auto-collapse mode: collapse all siblings
				if (flag && !node.expanded && opts.autoCollapse) {
					parents = node.getParentList(false, true);
					prevAC = opts.autoCollapse;
					try {
						opts.autoCollapse = false;
						for (i = 0, l = parents.length; i < l; i++) {
							// TODO: should return promise?
							this._callHook(
								"nodeCollapseSiblings",
								parents[i],
								callOpts
							);
						}
					} finally {
						opts.autoCollapse = prevAC;
					}
				}
				// Trigger expand/collapse after expanding
				dfd.done(function() {
					var lastChild = node.getLastChild();

					if (flag && opts.autoScroll && !noAnimation && lastChild) {
						// Scroll down to last child, but keep current node visible
						lastChild
							.scrollIntoView(true, { topNode: node })
							.always(function() {
								if (!noEvents) {
									ctx.tree._triggerNodeEvent(
										flag ? "expand" : "collapse",
										ctx
									);
								}
							});
					} else {
						if (!noEvents) {
							ctx.tree._triggerNodeEvent(
								flag ? "expand" : "collapse",
								ctx
							);
						}
					}
				});
				// vvv Code below is executed after loading finished:
				_afterLoad = function(callback) {
					var cn = opts._classNames,
						isVisible,
						isExpanded,
						effect = opts.toggleEffect;

					node.expanded = flag;
					// Create required markup, but make sure the top UL is hidden, so we
					// can animate later
					tree._callHook("nodeRender", ctx, false, false, true);

					// Hide children, if node is collapsed
					if (node.ul) {
						isVisible = node.ul.style.display !== "none";
						isExpanded = !!node.expanded;
						if (isVisible === isExpanded) {
							node.warn(
								"nodeSetExpanded: UL.style.display already set"
							);
						} else if (!effect || noAnimation) {
							node.ul.style.display =
								node.expanded || !parent ? "" : "none";
						} else {
							// The UI toggle() effect works with the ext-wide extension,
							// while jQuery.animate() has problems when the title span
							// has position: absolute.
							// Since jQuery UI 1.12, the blind effect requires the parent
							// element to have 'position: relative'.
							// See #716, #717
							$(node.li).addClass(cn.animating); // #717

							if (!$.isFunction($(node.ul)[effect.effect])) {
								// The UI toggle() effect works with the ext-wide extension,
								// while jQuery.animate() has problems when the title span
								// has positon: absolute.
								// Since jQuery UI 1.12, the blind effect requires the parent
								// element to have 'position: relative'.
								// See #716, #717
								// tree.debug("use specified effect (" + effect.effect + ") with the jqueryui.toggle method");

								// try to stop an animation that might be already in progress
								$(node.ul).stop(true, true); //< does not work after resetLazy has been called for a node whose animation wasn't complete and effect was "blind"

								// dirty fix to remove a defunct animation (effect: "blind") after resetLazy has been called
								$(node.ul)
									.parent()
									.find(".ui-effects-placeholder")
									.remove();

								$(node.ul).toggle(
									effect.effect,
									effect.options,
									effect.duration,
									function() {
										// node.debug("fancytree-animating end: " + node.li.className);
										$(this).removeClass(cn.animating); // #716
										$(node.li).removeClass(cn.animating); // #717
										callback();
									}
								);
							} else {
								tree.debug(
									"use jquery." + effect.effect + " method"
								);

								$(node.ul)[effect.effect]({
									duration: effect.duration,
									always: function() {
										// node.debug("fancytree-animating end: " + node.li.className);
										$(this).removeClass(cn.animating); // #716
										$(node.li).removeClass(cn.animating); // #717
										callback();
									},
								});
							}

							return;
						}
					}
					callback();
				};
				// ^^^ Code above is executed after loading finshed.

				// Load lazy nodes, if any. Then continue with _afterLoad()
				if (flag && node.lazy && node.hasChildren() === undefined) {
					// node.debug("nodeSetExpanded: load start...");
					node.load()
						.done(function() {
							// node.debug("nodeSetExpanded: load done");
							if (dfd.notifyWith) {
								// requires jQuery 1.6+
								dfd.notifyWith(node, ["loaded"]);
							}
							_afterLoad(function() {
								dfd.resolveWith(node);
							});
						})
						.fail(function(errMsg) {
							_afterLoad(function() {
								dfd.rejectWith(node, [
									"load failed (" + errMsg + ")",
								]);
							});
						});
					/*
					var source = tree._triggerNodeEvent("lazyLoad", node, ctx.originalEvent);
					_assert(typeof source !== "boolean", "lazyLoad event must return source in data.result");
					node.debug("nodeSetExpanded: load start...");
					this._callHook("nodeLoadChildren", ctx, source).done(function(){
						node.debug("nodeSetExpanded: load done");
						if(dfd.notifyWith){ // requires jQuery 1.6+
							dfd.notifyWith(node, ["loaded"]);
						}
						_afterLoad.call(tree);
					}).fail(function(errMsg){
						dfd.rejectWith(node, ["load failed (" + errMsg + ")"]);
					});
					*/
				} else {
					_afterLoad(function() {
						dfd.resolveWith(node);
					});
				}
				// node.debug("nodeSetExpanded: returns");
				return dfd.promise();
			},
			/** Focus or blur this node.
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 */
			nodeSetFocus: function(ctx, flag) {
				// ctx.node.debug("nodeSetFocus(" + flag + ")");
				var ctx2,
					tree = ctx.tree,
					node = ctx.node,
					opts = tree.options,
					// et = ctx.originalEvent && ctx.originalEvent.type,
					isInput = ctx.originalEvent
						? $(ctx.originalEvent.target).is(":input")
						: false;

				flag = flag !== false;

				// (node || tree).debug("nodeSetFocus(" + flag + "), event: " + et + ", isInput: "+ isInput);
				// Blur previous node if any
				if (tree.focusNode) {
					if (tree.focusNode === node && flag) {
						// node.debug("nodeSetFocus(" + flag + "): nothing to do");
						return;
					}
					ctx2 = $.extend({}, ctx, { node: tree.focusNode });
					tree.focusNode = null;
					this._triggerNodeEvent("blur", ctx2);
					this._callHook("nodeRenderStatus", ctx2);
				}
				// Set focus to container and node
				if (flag) {
					if (!this.hasFocus()) {
						node.debug("nodeSetFocus: forcing container focus");
						this._callHook("treeSetFocus", ctx, true, {
							calledByNode: true,
						});
					}
					node.makeVisible({ scrollIntoView: false });
					tree.focusNode = node;
					if (opts.titlesTabbable) {
						if (!isInput) {
							// #621
							$(node.span)
								.find(".fancytree-title")
								.trigger('focus');
						}
					} else {
						// We cannot set KB focus to a node, so use the tree container
						// #563, #570: IE scrolls on every call to .focus(), if the container
						// is partially outside the viewport. So do it only, when absolutely
						// neccessary:
						if (
							$(document.activeElement).closest(
								".fancytree-container"
							).length === 0
						) {
							$(tree.$container).trigger('focus');
						}
					}
					if (opts.aria) {
						// Set active descendant to node's span ID (create one, if needed)
						$(tree.$container).attr(
							"aria-activedescendant",
							$(node.tr || node.li)
								.uniqueId()
								.attr("id")
						);
						// "ftal_" + opts.idPrefix + node.key);
					}
					// $(node.span).find(".fancytree-title").focus();
					this._triggerNodeEvent("focus", ctx);
					// if( opts.autoActivate ){
					// 	tree.nodeSetActive(ctx, true);
					// }
					if (opts.autoScroll) {
						node.scrollIntoView();
					}
					this._callHook("nodeRenderStatus", ctx);
				}
			},
			/** (De)Select node, return new status (sync).
			 *
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 * @param {object} [opts] additional options. Defaults to {noEvents: false,
			 *     propagateDown: null, propagateUp: null,
			 *     callback: null,
			 *     }
			 * @returns {boolean} previous status
			 */
			nodeSetSelected: function(ctx, flag, callOpts) {
				callOpts = callOpts || {};
				var node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					noEvents = callOpts.noEvents === true,
					parent = node.parent;

				// flag defaults to true
				flag = flag !== false;

				// node.debug("nodeSetSelected(" + flag + ")", ctx);

				// Cannot (de)select unselectable nodes directly (only by propagation or
				// by setting the `.selected` property)
				if (FT.evalOption("unselectable", node, node, opts, false)) {
					return;
				}

				// Remember the user's intent, in case down -> up propagation prevents
				// applying it to node.selected
				node._lastSelectIntent = flag; // Confusing use of '!'

				// Nothing to do?
				/*jshint -W018 */ if (!!node.selected === flag) {
					if (opts.selectMode === 3 && node.partsel && !flag) {
						// If propagation prevented selecting this node last time, we still
						// want to allow to apply setSelected(false) now
					} else {
						return flag;
					}
				}
				/*jshint +W018 */

				if (
					!noEvents &&
					this._triggerNodeEvent(
						"beforeSelect",
						node,
						ctx.originalEvent
					) === false
				) {
					return !!node.selected;
				}
				if (flag && opts.selectMode === 1) {
					// single selection mode (we don't uncheck all tree nodes, for performance reasons)
					if (tree.lastSelectedNode) {
						tree.lastSelectedNode.setSelected(false);
					}
					node.selected = flag;
				} else if (
					opts.selectMode === 3 &&
					parent &&
					!parent.radiogroup &&
					!node.radiogroup
				) {
					// multi-hierarchical selection mode
					node.selected = flag;
					node.fixSelection3AfterClick(callOpts);
				} else if (parent && parent.radiogroup) {
					node.visitSiblings(function(n) {
						n._changeSelectStatusAttrs(flag && n === node);
					}, true);
				} else {
					// default: selectMode: 2, multi selection mode
					node.selected = flag;
				}
				this.nodeRenderStatus(ctx);
				tree.lastSelectedNode = flag ? node : null;
				if (!noEvents) {
					tree._triggerNodeEvent("select", ctx);
				}
			},
			/** Show node status (ok, loading, error, nodata) using styles and a dummy child node.
			 *
			 * @param {EventData} ctx
			 * @param status
			 * @param message
			 * @param details
			 * @since 2.3
			 */
			nodeSetStatus: function(ctx, status, message, details) {
				var node = ctx.node,
					tree = ctx.tree;

				function _clearStatusNode() {
					// Remove dedicated dummy node, if any
					var firstChild = node.children ? node.children[0] : null;
					if (firstChild && firstChild.isStatusNode()) {
						try {
							// I've seen exceptions here with loadKeyPath...
							if (node.ul) {
								node.ul.removeChild(firstChild.li);
								firstChild.li = null; // avoid leaks (DT issue 215)
							}
						} catch (e) {}
						if (node.children.length === 1) {
							node.children = [];
						} else {
							node.children.shift();
						}
					}
				}
				function _setStatusNode(data, type) {
					// Create/modify the dedicated dummy node for 'loading...' or
					// 'error!' status. (only called for direct child of the invisible
					// system root)
					var firstChild = node.children ? node.children[0] : null;
					if (firstChild && firstChild.isStatusNode()) {
						$.extend(firstChild, data);
						firstChild.statusNodeType = type;
						tree._callHook("nodeRenderTitle", firstChild);
					} else {
						node._setChildren([data]);
						node.children[0].statusNodeType = type;
						tree.render();
					}
					return node.children[0];
				}

				switch (status) {
					case "ok":
						_clearStatusNode();
						node._isLoading = false;
						node._error = null;
						node.renderStatus();
						break;
					case "loading":
						if (!node.parent) {
							_setStatusNode(
								{
									title:
										tree.options.strings.loading +
										(message ? " (" + message + ")" : ""),
									// icon: true,  // needed for 'loding' icon
									checkbox: false,
									tooltip: details,
								},
								status
							);
						}
						node._isLoading = true;
						node._error = null;
						node.renderStatus();
						break;
					case "error":
						_setStatusNode(
							{
								title:
									tree.options.strings.loadError +
									(message ? " (" + message + ")" : ""),
								// icon: false,
								checkbox: false,
								tooltip: details,
							},
							status
						);
						node._isLoading = false;
						node._error = { message: message, details: details };
						node.renderStatus();
						break;
					case "nodata":
						_setStatusNode(
							{
								title: message || tree.options.strings.noData,
								// icon: false,
								checkbox: false,
								tooltip: details,
							},
							status
						);
						node._isLoading = false;
						node._error = null;
						node.renderStatus();
						break;
					default:
						$.error("invalid node status " + status);
				}
			},
			/**
			 *
			 * @param {EventData} ctx
			 */
			nodeToggleExpanded: function(ctx) {
				return this.nodeSetExpanded(ctx, !ctx.node.expanded);
			},
			/**
			 * @param {EventData} ctx
			 */
			nodeToggleSelected: function(ctx) {
				var node = ctx.node,
					flag = !node.selected;

				// In selectMode: 3 this node may be unselected+partsel, even if
				// setSelected(true) was called before, due to `unselectable` children.
				// In this case, we now toggle as `setSelected(false)`
				if (
					node.partsel &&
					!node.selected &&
					node._lastSelectIntent === true
				) {
					flag = false;
					node.selected = true; // so it is not considered 'nothing to do'
				}
				node._lastSelectIntent = flag;
				return this.nodeSetSelected(ctx, flag);
			},
			/** Remove all nodes.
			 * @param {EventData} ctx
			 */
			treeClear: function(ctx) {
				var tree = ctx.tree;
				tree.activeNode = null;
				tree.focusNode = null;
				tree.$div.find(">ul.fancytree-container").empty();
				// TODO: call destructors and remove reference loops
				tree.rootNode.children = null;
			},
			/** Widget was created (called only once, even it re-initialized).
			 * @param {EventData} ctx
			 */
			treeCreate: function(ctx) {},
			/** Widget was destroyed.
			 * @param {EventData} ctx
			 */
			treeDestroy: function(ctx) {
				this.$div.find(">ul.fancytree-container").remove();
				this.$source &&
					this.$source.removeClass("fancytree-helper-hidden");
			},
			/** Widget was (re-)initialized.
			 * @param {EventData} ctx
			 */
			treeInit: function(ctx) {
				var tree = ctx.tree,
					opts = tree.options;

				//this.debug("Fancytree.treeInit()");
				// Add container to the TAB chain
				// See http://www.w3.org/TR/wai-aria-practices/#focus_activedescendant
				// #577: Allow to set tabindex to "0", "-1" and ""
				tree.$container.attr("tabindex", opts.tabindex);

				// Copy some attributes to tree.data
				$.each(TREE_ATTRS, function(i, attr) {
					if (opts[attr] !== undefined) {
						tree.info("Move option " + attr + " to tree");
						tree[attr] = opts[attr];
						delete opts[attr];
					}
				});

				if (opts.rtl) {
					tree.$container
						.attr("DIR", "RTL")
						.addClass("fancytree-rtl");
				} else {
					tree.$container
						.removeAttr("DIR")
						.removeClass("fancytree-rtl");
				}
				if (opts.aria) {
					tree.$container.attr("role", "tree");
					if (opts.selectMode !== 1) {
						tree.$container.attr("aria-multiselectable", true);
					}
				}
				this.treeLoad(ctx);
			},
			/** Parse Fancytree from source, as configured in the options.
			 * @param {EventData} ctx
			 * @param {object} [source] optional new source (use last data otherwise)
			 */
			treeLoad: function(ctx, source) {
				var metaData,
					type,
					$ul,
					tree = ctx.tree,
					$container = ctx.widget.element,
					dfd,
					// calling context for root node
					rootCtx = $.extend({}, ctx, { node: this.rootNode });

				if (tree.rootNode.children) {
					this.treeClear(ctx);
				}
				source = source || this.options.source;

				if (!source) {
					type = $container.data("type") || "html";
					switch (type) {
						case "html":
							$ul = $container.find(">ul:first");
							$ul.addClass(
								"ui-fancytree-source fancytree-helper-hidden"
							);
							source = $.ui.fancytree.parseHtml($ul);
							// allow to init tree.data.foo from <ul data-foo=''>
							this.data = $.extend(
								this.data,
								_getElementDataAsDict($ul)
							);
							break;
						case "json":
							source = $.parseJSON($container.text());
							// $container already contains the <ul>, but we remove the plain (json) text
							// $container.empty();
							$container
								.contents()
								.filter(function() {
									return this.nodeType === 3;
								})
								.remove();
							if ($.isPlainObject(source)) {
								// We got {foo: 'abc', children: [...]}
								_assert(
									$.isArray(source.children),
									"if an object is passed as source, it must contain a 'children' array (all other properties are added to 'tree.data')"
								);
								metaData = source;
								source = source.children;
								delete metaData.children;
								// Copy some attributes to tree.data
								$.each(TREE_ATTRS, function(i, attr) {
									if (metaData[attr] !== undefined) {
										tree[attr] = metaData[attr];
										delete metaData[attr];
									}
								});
								// Copy extra properties to tree.data.foo
								$.extend(tree.data, metaData);
							}
							break;
						default:
							$.error("Invalid data-type: " + type);
					}
				} else if (typeof source === "string") {
					// TODO: source is an element ID
					$.error("Not implemented");
				}

				// Trigger fancytreeinit after nodes have been loaded
				dfd = this.nodeLoadChildren(rootCtx, source)
					.done(function() {
						tree.render();
						if (ctx.options.selectMode === 3) {
							tree.rootNode.fixSelection3FromEndNodes();
						}
						if (tree.activeNode && tree.options.activeVisible) {
							tree.activeNode.makeVisible();
						}
						tree._triggerTreeEvent("init", null, { status: true });
					})
					.fail(function() {
						tree.render();
						tree._triggerTreeEvent("init", null, { status: false });
					});
				return dfd;
			},
			/** Node was inserted into or removed from the tree.
			 * @param {EventData} ctx
			 * @param {boolean} add
			 * @param {FancytreeNode} node
			 */
			treeRegisterNode: function(ctx, add, node) {},
			/** Widget got focus.
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 */
			treeSetFocus: function(ctx, flag, callOpts) {
				var targetNode;

				flag = flag !== false;

				// this.debug("treeSetFocus(" + flag + "), callOpts: ", callOpts, this.hasFocus());
				// this.debug("    focusNode: " + this.focusNode);
				// this.debug("    activeNode: " + this.activeNode);
				if (flag !== this.hasFocus()) {
					this._hasFocus = flag;
					if (!flag && this.focusNode) {
						// Node also looses focus if widget blurs
						this.focusNode.setFocus(false);
					} else if (flag && (!callOpts || !callOpts.calledByNode)) {
						$(this.$container).trigger('focus');
					}
					this.$container.toggleClass("fancytree-treefocus", flag);
					this._triggerTreeEvent(flag ? "focusTree" : "blurTree");
					if (flag && !this.activeNode) {
						// #712: Use last mousedowned node ('click' event fires after focusin)
						targetNode =
							this._lastMousedownNode || this.getFirstChild();
						targetNode && targetNode.setFocus();
					}
				}
			},
			/** Widget option was set using `$().fancytree("option", "KEY", VALUE)`.
			 *
			 * Note: `key` may reference a nested option, e.g. 'dnd5.scroll'.
			 * In this case `value`contains the complete, modified `dnd5` option hash.
			 * We can check for changed values like
			 *     if( value.scroll !== tree.options.dnd5.scroll ) {...}
			 *
			 * @param {EventData} ctx
			 * @param {string} key option name
			 * @param {any} value option value
			 */
			treeSetOption: function(ctx, key, value) {
				var tree = ctx.tree,
					callDefault = true,
					callCreate = false,
					callRender = false;

				switch (key) {
					case "aria":
					case "checkbox":
					case "icon":
					case "minExpandLevel":
					case "tabindex":
						// tree._callHook("treeCreate", tree);
						callCreate = true;
						callRender = true;
						break;
					case "escapeTitles":
					case "tooltip":
						callRender = true;
						break;
					case "rtl":
						if (value === false) {
							tree.$container
								.removeAttr("DIR")
								.removeClass("fancytree-rtl");
						} else {
							tree.$container
								.attr("DIR", "RTL")
								.addClass("fancytree-rtl");
						}
						callRender = true;
						break;
					case "source":
						callDefault = false;
						tree._callHook("treeLoad", tree, value);
						callRender = true;
						break;
				}
				tree.debug(
					"set option " +
						key +
						"=" +
						value +
						" <" +
						typeof value +
						">"
				);
				if (callDefault) {
					if (this.widget._super) {
						// jQuery UI 1.9+
						this.widget._super.call(this.widget, key, value);
					} else {
						// jQuery UI <= 1.8, we have to manually invoke the _setOption method from the base widget
						$.Widget.prototype._setOption.call(
							this.widget,
							key,
							value
						);
					}
				}
				if (callCreate) {
					tree._callHook("treeCreate", tree);
				}
				if (callRender) {
					tree.render(true, false); // force, not-deep
				}
			},
		}
	);

	/*******************************************************************************
	 * jQuery UI widget boilerplate
	 */

	/**
	 * The plugin (derrived from <a href=" http://api.jqueryui.com/jQuery.widget/">jQuery.Widget</a>).<br>
	 * This constructor is not called directly. Use `$(selector).fancytree({})`
	 * to initialize the plugin instead.<br>
	 * <pre class="sh_javascript sunlight-highlight-javascript">// Access widget methods and members:
	 * var tree = $("#tree").fancytree("getTree");
	 * var node = $("#tree").fancytree("getActiveNode", "1234");
	 * </pre>
	 *
	 * @mixin Fancytree_Widget
	 */

	$.widget(
		"ui.fancytree",
		/** @lends Fancytree_Widget# */
		{
			/**These options will be used as defaults
			 * @type {FancytreeOptions}
			 */
			options: {
				activeVisible: true,
				ajax: {
					type: "GET",
					cache: false, // false: Append random '_' argument to the request url to prevent caching.
					// timeout: 0, // >0: Make sure we get an ajax error if server is unreachable
					dataType: "json", // Expect json format and pass json object to callbacks.
				},
				aria: true,
				autoActivate: true,
				autoCollapse: false,
				autoScroll: false,
				checkbox: false,
				clickFolderMode: 4,
				debugLevel: null, // 0..4 (null: use global setting $.ui.fancytree.debugInfo)
				disabled: false, // TODO: required anymore?
				enableAspx: true,
				escapeTitles: false,
				extensions: [],
				// fx: { height: "toggle", duration: 200 },
				// toggleEffect: { effect: "drop", options: {direction: "left"}, duration: 200 },
				// toggleEffect: { effect: "slide", options: {direction: "up"}, duration: 200 },
				//toggleEffect: { effect: "blind", options: {direction: "vertical", scale: "box"}, duration: 200 },
				toggleEffect: { effect: "slideToggle", duration: 200 }, //< "toggle" or "slideToggle" to use jQuery instead of jQueryUI for toggleEffect animation
				generateIds: false,
				icon: true,
				idPrefix: "ft_",
				focusOnSelect: false,
				keyboard: true,
				keyPathSeparator: "/",
				minExpandLevel: 1,
				nodata: true, // (bool, string, or callback) display message, when no data available
				quicksearch: false,
				rtl: false,
				scrollOfs: { top: 0, bottom: 0 },
				scrollParent: null,
				selectMode: 2,
				strings: {
					loading: "Loading...", // &#8230; would be escaped when escapeTitles is true
					loadError: "Load error!",
					moreData: "More...",
					noData: "No data.",
				},
				tabindex: "0",
				titlesTabbable: false,
				tooltip: false,
				_classNames: {
					node: "fancytree-node",
					folder: "fancytree-folder",
					animating: "fancytree-animating",
					combinedExpanderPrefix: "fancytree-exp-",
					combinedIconPrefix: "fancytree-ico-",
					hasChildren: "fancytree-has-children",
					active: "fancytree-active",
					selected: "fancytree-selected",
					expanded: "fancytree-expanded",
					lazy: "fancytree-lazy",
					focused: "fancytree-focused",
					partload: "fancytree-partload",
					partsel: "fancytree-partsel",
					radio: "fancytree-radio",
					// radiogroup: "fancytree-radiogroup",
					unselectable: "fancytree-unselectable",
					lastsib: "fancytree-lastsib",
					loading: "fancytree-loading",
					error: "fancytree-error",
					statusNodePrefix: "fancytree-statusnode-",
				},
				// events
				lazyLoad: null,
				postProcess: null,
			},
			/* Set up the widget, Called on first $().fancytree() */
			_create: function() {
				this.tree = new Fancytree(this);

				this.$source =
					this.source || this.element.data("type") === "json"
						? this.element
						: this.element.find(">ul:first");
				// Subclass Fancytree instance with all enabled extensions
				var extension,
					extName,
					i,
					opts = this.options,
					extensions = opts.extensions,
					base = this.tree;

				for (i = 0; i < extensions.length; i++) {
					extName = extensions[i];
					extension = $.ui.fancytree._extensions[extName];
					if (!extension) {
						$.error(
							"Could not apply extension '" +
								extName +
								"' (it is not registered, did you forget to include it?)"
						);
					}
					// Add extension options as tree.options.EXTENSION
					//			_assert(!this.tree.options[extName], "Extension name must not exist as option name: " + extName);

					// console.info("extend " + extName, extension.options, this.tree.options[extName])
					// issue #876: we want to replace custom array-options, not merge them
					this.tree.options[extName] = _simpleDeepMerge(
						{},
						extension.options,
						this.tree.options[extName]
					);
					// this.tree.options[extName] = $.extend(true, {}, extension.options, this.tree.options[extName]);

					// console.info("extend " + extName + " =>", this.tree.options[extName])
					// console.info("extend " + extName + " org default =>", extension.options)

					// Add a namespace tree.ext.EXTENSION, to hold instance data
					_assert(
						this.tree.ext[extName] === undefined,
						"Extension name must not exist as Fancytree.ext attribute: '" +
							extName +
							"'"
					);
					// this.tree[extName] = extension;
					this.tree.ext[extName] = {};
					// Subclass Fancytree methods using proxies.
					_subclassObject(this.tree, base, extension, extName);
					// current extension becomes base for the next extension
					base = extension;
				}
				//
				if (opts.icons !== undefined) {
					// 2015-11-16
					if (opts.icon !== true) {
						$.error(
							"'icons' tree option is deprecated since v2.14.0: use 'icon' only instead"
						);
					} else {
						this.tree.warn(
							"'icons' tree option is deprecated since v2.14.0: use 'icon' instead"
						);
						opts.icon = opts.icons;
					}
				}
				if (opts.iconClass !== undefined) {
					// 2015-11-16
					if (opts.icon) {
						$.error(
							"'iconClass' tree option is deprecated since v2.14.0: use 'icon' only instead"
						);
					} else {
						this.tree.warn(
							"'iconClass' tree option is deprecated since v2.14.0: use 'icon' instead"
						);
						opts.icon = opts.iconClass;
					}
				}
				if (opts.tabbable !== undefined) {
					// 2016-04-04
					opts.tabindex = opts.tabbable ? "0" : "-1";
					this.tree.warn(
						"'tabbable' tree option is deprecated since v2.17.0: use 'tabindex='" +
							opts.tabindex +
							"' instead"
					);
				}
				//
				this.tree._callHook("treeCreate", this.tree);
				// Note: 'fancytreecreate' event is fired by widget base class
				//        this.tree._triggerTreeEvent("create");
			},

			/* Called on every $().fancytree() */
			_init: function() {
				this.tree._callHook("treeInit", this.tree);
				// TODO: currently we call bind after treeInit, because treeInit
				// might change tree.$container.
				// It would be better, to move event binding into hooks altogether
				this._bind();
			},

			/* Use the _setOption method to respond to changes to options. */
			_setOption: function(key, value) {
				return this.tree._callHook(
					"treeSetOption",
					this.tree,
					key,
					value
				);
			},

			/** Use the destroy method to clean up any modifications your widget has made to the DOM */
			destroy: function() {
				this._unbind();
				this.tree._callHook("treeDestroy", this.tree);
				// In jQuery UI 1.8, you must invoke the destroy method from the base widget
				$.Widget.prototype.destroy.call(this);
				// TODO: delete tree and nodes to make garbage collect easier?
				// TODO: In jQuery UI 1.9 and above, you would define _destroy instead of destroy and not call the base method
			},

			// -------------------------------------------------------------------------

			/* Remove all event handlers for our namespace */
			_unbind: function() {
				var ns = this.tree._ns;
				this.element.off(ns);
				this.tree.$container.off(ns);
				$(document).off(ns);
			},
			/* Add mouse and kyboard handlers to the container */
			_bind: function() {
				var that = this,
					opts = this.options,
					tree = this.tree,
					ns = tree._ns;
				// selstartEvent = ( $.support.selectstart ? "selectstart" : "mousedown" )

				// Remove all previuous handlers for this tree
				this._unbind();

				//alert("keydown" + ns + "foc=" + tree.hasFocus() + tree.$container);
				// tree.debug("bind events; container: ", tree.$container);
				tree.$container
					.on("focusin" + ns + " focusout" + ns, function(event) {
						var node = FT.getNode(event),
							flag = event.type === "focusin";

						if (!flag && node && $(event.target).is("a")) {
							// #764
							node.debug(
								"Ignored focusout on embedded <a> element."
							);
							return;
						}
						// tree.treeOnFocusInOut.call(tree, event);
						// tree.debug("Tree container got event " + event.type, node, event, FT.getEventTarget(event));
						if (flag) {
							if (tree._getExpiringValue("focusin")) {
								// #789: IE 11 may send duplicate focusin events
								tree.debug("Ignored double focusin.");
								return;
							}
							tree._setExpiringValue("focusin", true, 50);

							if (!node) {
								// #789: IE 11 may send focusin before mousdown(?)
								node = tree._getExpiringValue("mouseDownNode");
								if (node) {
									tree.debug(
										"Reconstruct mouse target for focusin from recent event."
									);
								}
							}
						}
						if (node) {
							// For example clicking into an <input> that is part of a node
							tree._callHook(
								"nodeSetFocus",
								tree._makeHookContext(node, event),
								flag
							);
						} else {
							if (
								tree.tbody &&
								$(event.target).parents(
									"table.fancytree-container > thead"
								).length
							) {
								// #767: ignore events in the table's header
								tree.debug(
									"Ignore focus event outside table body.",
									event
								);
							} else {
								tree._callHook("treeSetFocus", tree, flag);
							}
						}
					})
					.on("selectstart" + ns, "span.fancytree-title", function(
						event
					) {
						// prevent mouse-drags to select text ranges
						// tree.debug("<span title> got event " + event.type);
						event.preventDefault();
					})
					.on("keydown" + ns, function(event) {
						// TODO: also bind keyup and keypress
						// tree.debug("got event " + event.type + ", hasFocus:" + tree.hasFocus());
						// if(opts.disabled || opts.keyboard === false || !tree.hasFocus() ){
						if (opts.disabled || opts.keyboard === false) {
							return true;
						}
						var res,
							node = tree.focusNode, // node may be null
							ctx = tree._makeHookContext(node || tree, event),
							prevPhase = tree.phase;

						try {
							tree.phase = "userEvent";
							// If a 'fancytreekeydown' handler returns false, skip the default
							// handling (implemented by tree.nodeKeydown()).
							if (node) {
								res = tree._triggerNodeEvent(
									"keydown",
									node,
									event
								);
							} else {
								res = tree._triggerTreeEvent("keydown", event);
							}
							if (res === "preventNav") {
								res = true; // prevent keyboard navigation, but don't prevent default handling of embedded input controls
							} else if (res !== false) {
								res = tree._callHook("nodeKeydown", ctx);
							}
							return res;
						} finally {
							tree.phase = prevPhase;
						}
					})
					.on("mousedown" + ns, function(event) {
						var et = FT.getEventTarget(event);
						// that.tree.debug("event(" + event.type + "): node: ", et.node);
						// #712: Store the clicked node, so we can use it when we get a focusin event
						//       ('click' event fires after focusin)
						// tree.debug("event(" + event.type + "): node: ", et.node);
						tree._lastMousedownNode = et ? et.node : null;
						// #789: Store the node also for a short period, so we can use it
						// in a *resulting* focusin event
						tree._setExpiringValue(
							"mouseDownNode",
							tree._lastMousedownNode
						);
					})
					.on("click" + ns + " dblclick" + ns, function(event) {
						if (opts.disabled) {
							return true;
						}
						var ctx,
							et = FT.getEventTarget(event),
							node = et.node,
							tree = that.tree,
							prevPhase = tree.phase;

						// that.tree.debug("event(" + event.type + "): node: ", node);
						if (!node) {
							return true; // Allow bubbling of other events
						}
						ctx = tree._makeHookContext(node, event);
						// that.tree.debug("event(" + event.type + "): node: ", node);
						try {
							tree.phase = "userEvent";
							switch (event.type) {
								case "click":
									ctx.targetType = et.type;
									if (node.isPagingNode()) {
										return (
											tree._triggerNodeEvent(
												"clickPaging",
												ctx,
												event
											) === true
										);
									}
									return tree._triggerNodeEvent(
										"click",
										ctx,
										event
									) === false
										? false
										: tree._callHook("nodeClick", ctx);
								case "dblclick":
									ctx.targetType = et.type;
									return tree._triggerNodeEvent(
										"dblclick",
										ctx,
										event
									) === false
										? false
										: tree._callHook("nodeDblclick", ctx);
							}
						} finally {
							tree.phase = prevPhase;
						}
					});
			},
			/** Return the active node or null.
			 * @returns {FancytreeNode}
			 */
			getActiveNode: function() {
				return this.tree.activeNode;
			},
			/** Return the matching node or null.
			 * @param {string} key
			 * @returns {FancytreeNode}
			 */
			getNodeByKey: function(key) {
				return this.tree.getNodeByKey(key);
			},
			/** Return the invisible system root node.
			 * @returns {FancytreeNode}
			 */
			getRootNode: function() {
				return this.tree.rootNode;
			},
			/** Return the current tree instance.
			 * @returns {Fancytree}
			 */
			getTree: function() {
				return this.tree;
			},
		}
	);

	// $.ui.fancytree was created by the widget factory. Create a local shortcut:
	FT = $.ui.fancytree;

	/**
	 * Static members in the `$.ui.fancytree` namespace.<br>
	 * <br>
	 * <pre class="sh_javascript sunlight-highlight-javascript">// Access static members:
	 * var node = $.ui.fancytree.getNode(element);
	 * alert($.ui.fancytree.version);
	 * </pre>
	 *
	 * @mixin Fancytree_Static
	 */
	$.extend(
		$.ui.fancytree,
		/** @lends Fancytree_Static# */
		{
			/** @type {string} */
			version: "2.30.2", // Set to semver by 'grunt release'
			/** @type {string} */
			buildType: "production", // Set to 'production' by 'grunt build'
			/** @type {int} */
			debugLevel: 3, // Set to 3 by 'grunt build'
			// Used by $.ui.fancytree.debug() and as default for tree.options.debugLevel

			_nextId: 1,
			_nextNodeKey: 1,
			_extensions: {},
			// focusTree: null,

			/** Expose class object as $.ui.fancytree._FancytreeClass */
			_FancytreeClass: Fancytree,
			/** Expose class object as $.ui.fancytree._FancytreeNodeClass */
			_FancytreeNodeClass: FancytreeNode,
			/* Feature checks to provide backwards compatibility */
			jquerySupports: {
				// http://jqueryui.com/upgrade-guide/1.9/#deprecated-offset-option-merged-into-my-and-at
				positionMyOfs: isVersionAtLeast($.ui.version, 1, 9),
			},
			/** Throw an error if condition fails (debug method).
			 * @param {boolean} cond
			 * @param {string} msg
			 */
			assert: function(cond, msg) {
				return _assert(cond, msg);
			},
			/** Create a new Fancytree instance on a target element.
			 *
			 * @param {Element | jQueryObject | string} el Target DOM element or selector
			 * @param {FancytreeOptions} [opts] Fancytree options
			 * @returns {Fancytree} new tree instance
			 * @example
			 * var tree = $.ui.fancytree.createTree("#tree", {
			 *     source: {url: "my/webservice"}
			 * }); // Create tree for this matching element
			 *
			 * @since 2.25
			 */
			createTree: function(el, opts) {
				var tree = $(el)
					.fancytree(opts)
					.fancytree("getTree");
				return tree;
			},
			/** Return a function that executes *fn* at most every *timeout* ms.
			 * @param {integer} timeout
			 * @param {function} fn
			 * @param {boolean} [invokeAsap=false]
			 * @param {any} [ctx]
			 */
			debounce: function(timeout, fn, invokeAsap, ctx) {
				var timer;
				if (arguments.length === 3 && typeof invokeAsap !== "boolean") {
					ctx = invokeAsap;
					invokeAsap = false;
				}
				return function() {
					var args = arguments;
					ctx = ctx || this;
					invokeAsap && !timer && fn.apply(ctx, args);
					clearTimeout(timer);
					timer = setTimeout(function() {
						invokeAsap || fn.apply(ctx, args);
						timer = null;
					}, timeout);
				};
			},
			/** Write message to console if debugLevel >= 4
			 * @param {string} msg
			 */
			debug: function(msg) {
				/*jshint expr:true */
				$.ui.fancytree.debugLevel >= 4 &&
					consoleApply("log", arguments);
			},
			/** Write error message to console if debugLevel >= 1.
			 * @param {string} msg
			 */
			error: function(msg) {
				$.ui.fancytree.debugLevel >= 1 &&
					consoleApply("error", arguments);
			},
			/** Convert &lt;, &gt;, &amp;, &quot;, &#39;, &#x2F; to the equivalent entities.
			 *
			 * @param {string} s
			 * @returns {string}
			 */
			escapeHtml: function(s) {
				return ("" + s).replace(REX_HTML, function(s) {
					return ENTITY_MAP[s];
				});
			},
			/** Make jQuery.position() arguments backwards compatible, i.e. if
			 * jQuery UI version <= 1.8, convert
			 *   { my: "left+3 center", at: "left bottom", of: $target }
			 * to
			 *   { my: "left center", at: "left bottom", of: $target, offset: "3  0" }
			 *
			 * See http://jqueryui.com/upgrade-guide/1.9/#deprecated-offset-option-merged-into-my-and-at
			 * and http://jsfiddle.net/mar10/6xtu9a4e/
			 *
			 * @param {object} opts
			 * @returns {object} the (potentially modified) original opts hash object
			 */
			fixPositionOptions: function(opts) {
				if (opts.offset || ("" + opts.my + opts.at).indexOf("%") >= 0) {
					$.error(
						"expected new position syntax (but '%' is not supported)"
					);
				}
				if (!$.ui.fancytree.jquerySupports.positionMyOfs) {
					var // parse 'left+3 center' into ['left+3 center', 'left', '+3', 'center', undefined]
						myParts = /(\w+)([+-]?\d+)?\s+(\w+)([+-]?\d+)?/.exec(
							opts.my
						),
						atParts = /(\w+)([+-]?\d+)?\s+(\w+)([+-]?\d+)?/.exec(
							opts.at
						),
						// convert to numbers
						dx =
							(myParts[2] ? +myParts[2] : 0) +
							(atParts[2] ? +atParts[2] : 0),
						dy =
							(myParts[4] ? +myParts[4] : 0) +
							(atParts[4] ? +atParts[4] : 0);

					opts = $.extend({}, opts, {
						// make a copy and overwrite
						my: myParts[1] + " " + myParts[3],
						at: atParts[1] + " " + atParts[3],
					});
					if (dx || dy) {
						opts.offset = "" + dx + " " + dy;
					}
				}
				return opts;
			},
			/** Return a {node: FancytreeNode, type: TYPE} object for a mouse event.
			 *
			 * @param {Event} event Mouse event, e.g. click, ...
			 * @returns {object} Return a {node: FancytreeNode, type: TYPE} object
			 *     TYPE: 'title' | 'prefix' | 'expander' | 'checkbox' | 'icon' | undefined
			 */
			getEventTarget: function(event) {
				var $target,
					tree,
					tcn = event && event.target ? event.target.className : "",
					res = { node: this.getNode(event.target), type: undefined };
				// We use a fast version of $(res.node).hasClass()
				// See http://jsperf.com/test-for-classname/2
				if (/\bfancytree-title\b/.test(tcn)) {
					res.type = "title";
				} else if (/\bfancytree-expander\b/.test(tcn)) {
					res.type =
						res.node.hasChildren() === false
							? "prefix"
							: "expander";
					// }else if( /\bfancytree-checkbox\b/.test(tcn) || /\bfancytree-radio\b/.test(tcn) ){
				} else if (/\bfancytree-checkbox\b/.test(tcn)) {
					res.type = "checkbox";
				} else if (/\bfancytree(-custom)?-icon\b/.test(tcn)) {
					res.type = "icon";
				} else if (/\bfancytree-node\b/.test(tcn)) {
					// Somewhere near the title
					res.type = "title";
				} else if (event && event.target) {
					$target = $(event.target);
					if ($target.is("ul[role=group]")) {
						// #nnn: Clicking right to a node may hit the surrounding UL
						tree = res.node && res.node.tree;
						(tree || FT).debug("Ignoring click on outer UL.");
						res.node = null;
					} else if ($target.closest(".fancytree-title").length) {
						// #228: clicking an embedded element inside a title
						res.type = "title";
					} else if ($target.closest(".fancytree-checkbox").length) {
						// E.g. <svg> inside checkbox span
						res.type = "checkbox";
					} else if ($target.closest(".fancytree-expander").length) {
						res.type = "expander";
					}
				}
				return res;
			},
			/** Return a string describing the affected node region for a mouse event.
			 *
			 * @param {Event} event Mouse event, e.g. click, mousemove, ...
			 * @returns {string} 'title' | 'prefix' | 'expander' | 'checkbox' | 'icon' | undefined
			 */
			getEventTargetType: function(event) {
				return this.getEventTarget(event).type;
			},
			/** Return a FancytreeNode instance from element, event, or jQuery object.
			 *
			 * @param {Element | jQueryObject | Event} el
			 * @returns {FancytreeNode} matching node or null
			 */
			getNode: function(el) {
				if (el instanceof FancytreeNode) {
					return el; // el already was a FancytreeNode
				} else if (el instanceof $) {
					el = el[0]; // el was a jQuery object: use the DOM element
				} else if (el.originalEvent !== undefined) {
					el = el.target; // el was an Event
				}
				while (el) {
					if (el.ftnode) {
						return el.ftnode;
					}
					el = el.parentNode;
				}
				return null;
			},
			/** Return a Fancytree instance, from element, index, event, or jQueryObject.
			 *
			 * @param {Element | jQueryObject | Event | integer | string} [el]
			 * @returns {Fancytree} matching tree or null
			 * @example
			 * $.ui.fancytree.getTree();   // Get first Fancytree instance on page
			 * $.ui.fancytree.getTree(1);  // Get second Fancytree instance on page
			 * $.ui.fancytree.getTree("#tree"); // Get tree for this matching element
			 *
			 * @since 2.13
			 */
			getTree: function(el) {
				var widget;

				if (el instanceof Fancytree) {
					return el; // el already was a Fancytree
				}
				if (el === undefined) {
					el = 0; // get first tree
				}
				if (typeof el === "number") {
					el = $(".fancytree-container").eq(el); // el was an integer: return nth instance
				} else if (typeof el === "string") {
					el = $(el).eq(0); // el was a selector: use first match
				} else if (el instanceof $) {
					el = el.eq(0); // el was a jQuery object: use the first DOM element
				} else if (el.originalEvent !== undefined) {
					el = $(el.target); // el was an Event
				}
				el = el.closest(":ui-fancytree");
				widget = el.data("ui-fancytree") || el.data("fancytree"); // the latter is required by jQuery <= 1.8
				return widget ? widget.tree : null;
			},
			/** Return an option value that has a default, but may be overridden by a
			 * callback or a node instance attribute.
			 *
			 * Evaluation sequence:<br>
			 *
			 * If tree.options.<optionName> is a callback that returns something, use that.<br>
			 * Else if node.<optionName> is defined, use that.<br>
			 * Else if tree.options.<optionName> is a value, use that.<br>
			 * Else use `defaultValue`.
			 *
			 * @param {string} optionName name of the option property (on node and tree)
			 * @param {FancytreeNode} node passed to the callback
			 * @param {object} nodeObject where to look for the local option property, e.g. `node` or `node.data`
			 * @param {object} treeOption where to look for the tree option, e.g. `tree.options` or `tree.options.dnd5`
			 * @param {any} [defaultValue]
			 * @returns {any}
			 *
			 * @example
			 * // Check for node.foo, tree,options.foo(), and tree.options.foo:
			 * $.ui.fancytree.evalOption("foo", node, node, tree.options);
			 * // Check for node.data.bar, tree,options.qux.bar(), and tree.options.qux.bar:
			 * $.ui.fancytree.evalOption("bar", node, node.data, tree.options.qux);
			 *
			 * @since 2.22
			 */
			evalOption: function(
				optionName,
				node,
				nodeObject,
				treeOptions,
				defaultValue
			) {
				var ctx,
					res,
					tree = node.tree,
					treeOpt = treeOptions[optionName],
					nodeOpt = nodeObject[optionName];

				if ($.isFunction(treeOpt)) {
					ctx = {
						node: node,
						tree: tree,
						widget: tree.widget,
						options: tree.widget.options,
						typeInfo: tree.types[node.type] || {},
					};
					res = treeOpt.call(tree, { type: optionName }, ctx);
					if (res == null) {
						res = nodeOpt;
					}
				} else {
					res = nodeOpt != null ? nodeOpt : treeOpt;
				}
				if (res == null) {
					res = defaultValue; // no option set at all: return default
				}
				return res;
			},
			/** Set expander, checkbox, or node icon, supporting string and object format.
			 *
			 * @param {Element | jQueryObject} span
			 * @param {string} baseClass
			 * @param {string | object} icon
			 * @since 2.27
			 */
			setSpanIcon: function(span, baseClass, icon) {
				var $span = $(span);

				if (typeof icon === "string") {
					$span.attr("class", baseClass + " " + icon);
				} else {
					// support object syntax: { text: ligature, addClasse: classname }
					if (icon.text) {
						$span.text("" + icon.text);
					} else if (icon.html) {
						span.innerHTML = icon.html;
					}
					$span.attr(
						"class",
						baseClass + " " + (icon.addClass || "")
					);
				}
			},
			/** Convert a keydown or mouse event to a canonical string like 'ctrl+a',
			 * 'ctrl+shift+f2', 'shift+leftdblclick'.
			 *
			 * This is especially handy for switch-statements in event handlers.
			 *
			 * @param {event}
			 * @returns {string}
			 *
			 * @example

			switch( $.ui.fancytree.eventToString(event) ) {
				case "-":
					tree.nodeSetExpanded(ctx, false);
					break;
				case "shift+return":
					tree.nodeSetActive(ctx, true);
					break;
				case "down":
					res = node.navigate(event.which, activate);
					break;
				default:
					handled = false;
			}
			if( handled ){
				event.preventDefault();
			}
			*/
			eventToString: function(event) {
				// Poor-man's hotkeys. See here for a complete implementation:
				//   https://github.com/jeresig/jquery.hotkeys
				var which = event.which,
					et = event.type,
					s = [];

				if (event.altKey) {
					s.push("alt");
				}
				if (event.ctrlKey) {
					s.push("ctrl");
				}
				if (event.metaKey) {
					s.push("meta");
				}
				if (event.shiftKey) {
					s.push("shift");
				}

				if (et === "click" || et === "dblclick") {
					s.push(MOUSE_BUTTONS[event.button] + et);
				} else {
					if (!IGNORE_KEYCODES[which]) {
						s.push(
							SPECIAL_KEYCODES[which] ||
								String.fromCharCode(which).toLowerCase()
						);
					}
				}
				return s.join("+");
			},
			/** Write message to console if debugLevel >= 3
			 * @param {string} msg
			 */
			info: function(msg) {
				/*jshint expr:true */
				$.ui.fancytree.debugLevel >= 3 &&
					consoleApply("info", arguments);
			},
			/* @deprecated: use eventToString(event) instead.
			 */
			keyEventToString: function(event) {
				this.warn(
					"keyEventToString() is deprecated: use eventToString()"
				);
				return this.eventToString(event);
			},
			/** Return a wrapped handler method, that provides `this._super`.
			 *
			 * @example
				// Implement `opts.createNode` event to add the 'draggable' attribute
				$.ui.fancytree.overrideMethod(ctx.options, "createNode", function(event, data) {
					// Default processing if any
					this._super.apply(this, arguments);
					// Add 'draggable' attribute
					data.node.span.draggable = true;
				});
			 *
			 * @param {object} instance
			 * @param {string} methodName
			 * @param {function} handler
			 * @param {object} [context] optional context
			 */
			overrideMethod: function(instance, methodName, handler, context) {
				var prevSuper,
					_super = instance[methodName] || $.noop;

				instance[methodName] = function() {
					var self = context || this;

					try {
						prevSuper = self._super;
						self._super = _super;
						return handler.apply(self, arguments);
					} finally {
						self._super = prevSuper;
					}
				};
			},
			/**
			 * Parse tree data from HTML <ul> markup
			 *
			 * @param {jQueryObject} $ul
			 * @returns {NodeData[]}
			 */
			parseHtml: function($ul) {
				// TODO: understand this:
				/*jshint validthis:true */
				var classes,
					className,
					extraClasses,
					i,
					iPos,
					l,
					tmp,
					tmp2,
					$children = $ul.find(">li"),
					children = [];

				$children.each(function() {
					var allData,
						lowerCaseAttr,
						$li = $(this),
						$liSpan = $li.find(">span:first", this),
						$liA = $liSpan.length ? null : $li.find(">a:first"),
						d = { tooltip: null, data: {} };

					if ($liSpan.length) {
						d.title = $liSpan.html();
					} else if ($liA && $liA.length) {
						// If a <li><a> tag is specified, use it literally and extract href/target.
						d.title = $liA.html();
						d.data.href = $liA.attr("href");
						d.data.target = $liA.attr("target");
						d.tooltip = $liA.attr("title");
					} else {
						// If only a <li> tag is specified, use the trimmed string up to
						// the next child <ul> tag.
						d.title = $li.html();
						iPos = d.title.search(/<ul/i);
						if (iPos >= 0) {
							d.title = d.title.substring(0, iPos);
						}
					}
					d.title = $.trim(d.title);

					// Make sure all fields exist
					for (i = 0, l = CLASS_ATTRS.length; i < l; i++) {
						d[CLASS_ATTRS[i]] = undefined;
					}
					// Initialize to `true`, if class is set and collect extraClasses
					classes = this.className.split(" ");
					extraClasses = [];
					for (i = 0, l = classes.length; i < l; i++) {
						className = classes[i];
						if (CLASS_ATTR_MAP[className]) {
							d[className] = true;
						} else {
							extraClasses.push(className);
						}
					}
					d.extraClasses = extraClasses.join(" ");

					// Parse node options from ID, title and class attributes
					tmp = $li.attr("title");
					if (tmp) {
						d.tooltip = tmp; // overrides <a title='...'>
					}
					tmp = $li.attr("id");
					if (tmp) {
						d.key = tmp;
					}
					// Translate hideCheckbox -> checkbox:false
					if ($li.attr("hideCheckbox")) {
						d.checkbox = false;
					}
					// Add <li data-NAME='...'> as node.data.NAME
					allData = _getElementDataAsDict($li);
					if (allData && !$.isEmptyObject(allData)) {
						// #507: convert data-hidecheckbox (lower case) to hideCheckbox
						for (lowerCaseAttr in NODE_ATTR_LOWERCASE_MAP) {
							if (allData.hasOwnProperty(lowerCaseAttr)) {
								allData[
									NODE_ATTR_LOWERCASE_MAP[lowerCaseAttr]
								] =
									allData[lowerCaseAttr];
								delete allData[lowerCaseAttr];
							}
						}
						// #56: Allow to set special node.attributes from data-...
						for (i = 0, l = NODE_ATTRS.length; i < l; i++) {
							tmp = NODE_ATTRS[i];
							tmp2 = allData[tmp];
							if (tmp2 != null) {
								delete allData[tmp];
								d[tmp] = tmp2;
							}
						}
						// All other data-... goes to node.data...
						$.extend(d.data, allData);
					}
					// Recursive reading of child nodes, if LI tag contains an UL tag
					$ul = $li.find(">ul:first");
					if ($ul.length) {
						d.children = $.ui.fancytree.parseHtml($ul);
					} else {
						d.children = d.lazy ? undefined : null;
					}
					children.push(d);
					// FT.debug("parse ", d, children);
				});
				return children;
			},
			/** Add Fancytree extension definition to the list of globally available extensions.
			 *
			 * @param {object} definition
			 */
			registerExtension: function(definition) {
				_assert(
					definition.name != null,
					"extensions must have a `name` property."
				);
				_assert(
					definition.version != null,
					"extensions must have a `version` property."
				);
				$.ui.fancytree._extensions[definition.name] = definition;
			},
			/** Inverse of escapeHtml().
			 *
			 * @param {string} s
			 * @returns {string}
			 */
			unescapeHtml: function(s) {
				var e = document.createElement("div");
				e.innerHTML = s;
				return e.childNodes.length === 0
					? ""
					: e.childNodes[0].nodeValue;
			},
			/** Write warning message to console if debugLevel >= 2.
			 * @param {string} msg
			 */
			warn: function(msg) {
				$.ui.fancytree.debugLevel >= 2 &&
					consoleApply("warn", arguments);
			},
		}
	);

	// Value returned by `require('jquery.fancytree')`
	return $.ui.fancytree;
}); // End of closure
;
/*!
 * jquery.fancytree.filter.js
 *
 * Remove or highlight tree nodes, based on a filter.
 * (Extension module for jquery.fancytree.js: https://github.com/mar10/fancytree/)
 *
 * Copyright (c) 2008-2019, Martin Wendt (http://wwWendt.de)
 *
 * Released under the MIT license
 * https://github.com/mar10/fancytree/wiki/LicenseInfo
 *
 * @version 2.30.2
 * @date 2019-01-13T08:17:01Z
 */

(function(factory) {
	if (typeof csui.define === 'function' && csui.define.amd) {
		// AMD. Register as an anonymous module.
		csui.define('csui/lib/fancytree/jquery.fancytree.filter',["csui/lib/jquery", "./jquery.fancytree"], factory);
	} else if (typeof module === "object" && module.exports) {
		// Node/CommonJS
		require("./jquery.fancytree");
		module.exports = factory(require("csui/lib/jquery"));
	} else {
		// Browser globals
		factory(jQuery);
	}
})(function($) {
	"use strict";

	/*******************************************************************************
	 * Private functions and variables
	 */

	var KeyNoData = "__not_found__",
		escapeHtml = $.ui.fancytree.escapeHtml;

	function _escapeRegex(str) {
		/*jshint regexdash:true */
		return (str + "").replace(/([.?*+\^\$\[\]\\(){}|-])/g, "\\$1");
	}

	function extractHtmlText(s) {
		if (s.indexOf(">") >= 0) {
			return $("<div/>")
				.html(s)
				.text();
		}
		return s;
	}

	$.ui.fancytree._FancytreeClass.prototype._applyFilterImpl = function(
		filter,
		branchMode,
		_opts
	) {
		var match,
			statusNode,
			re,
			reHighlight,
			temp,
			count = 0,
			treeOpts = this.options,
			escapeTitles = treeOpts.escapeTitles,
			prevAutoCollapse = treeOpts.autoCollapse,
			opts = $.extend({}, treeOpts.filter, _opts),
			hideMode = opts.mode === "hide",
			leavesOnly = !!opts.leavesOnly && !branchMode;

		// Default to 'match title substring (not case sensitive)'
		if (typeof filter === "string") {
			if (filter === "") {
				this.warn(
					"Fancytree passing an empty string as a filter is handled as clearFilter()."
				);
				this.clearFilter();
				return;
			}
			if (opts.fuzzy) {
				// See https://codereview.stackexchange.com/questions/23899/faster-javascript-fuzzy-string-matching-function/23905#23905
				// and http://www.quora.com/How-is-the-fuzzy-search-algorithm-in-Sublime-Text-designed
				// and http://www.dustindiaz.com/autocomplete-fuzzy-matching
				match = filter.split("").reduce(function(a, b) {
					return a + "[^" + b + "]*" + b;
				});
			} else {
				match = _escapeRegex(filter); // make sure a '.' is treated literally
			}
			re = new RegExp(".*" + match + ".*", "i");
			reHighlight = new RegExp(_escapeRegex(filter), "gi");
			filter = function(node) {
				if (!node.title) {
					return false;
				}
				var text = escapeTitles
						? node.title
						: extractHtmlText(node.title),
					res = !!re.test(text);

				if (res && opts.highlight) {
					if (escapeTitles) {
						// #740: we must not apply the marks to escaped entity names, e.g. `&quot;`
						// Use some exotic characters to mark matches:
						temp = text.replace(reHighlight, function(s) {
							return "\uFFF7" + s + "\uFFF8";
						});
						// now we can escape the title...
						node.titleWithHighlight = escapeHtml(temp)
							// ... and finally insert the desired `<mark>` tags
							.replace(/\uFFF7/g, "<mark>")
							.replace(/\uFFF8/g, "</mark>");
					} else {
						node.titleWithHighlight = text.replace(
							reHighlight,
							function(s) {
								return "<mark>" + s + "</mark>";
							}
						);
					}
					// node.debug("filter", escapeTitles, text, node.titleWithHighlight);
				}
				return res;
			};
		}

		this.enableFilter = true;
		this.lastFilterArgs = arguments;

		this.$div.addClass("fancytree-ext-filter");
		if (hideMode) {
			this.$div.addClass("fancytree-ext-filter-hide");
		} else {
			this.$div.addClass("fancytree-ext-filter-dimm");
		}
		this.$div.toggleClass(
			"fancytree-ext-filter-hide-expanders",
			!!opts.hideExpanders
		);
		// Reset current filter
		this.visit(function(node) {
			delete node.match;
			delete node.titleWithHighlight;
			node.subMatchCount = 0;
		});
		statusNode = this.getRootNode()._findDirectChild(KeyNoData);
		if (statusNode) {
			statusNode.remove();
		}

		// Adjust node.hide, .match, and .subMatchCount properties
		treeOpts.autoCollapse = false; // #528

		this.visit(function(node) {
			if (leavesOnly && node.children != null) {
				return;
			}
			var res = filter(node),
				matchedByBranch = false;

			if (res === "skip") {
				node.visit(function(c) {
					c.match = false;
				}, true);
				return "skip";
			}
			if (!res && (branchMode || res === "branch") && node.parent.match) {
				res = true;
				matchedByBranch = true;
			}
			if (res) {
				count++;
				node.match = true;
				node.visitParents(function(p) {
					p.subMatchCount += 1;
					// Expand match (unless this is no real match, but only a node in a matched branch)
					if (opts.autoExpand && !matchedByBranch && !p.expanded) {
						p.setExpanded(true, {
							noAnimation: true,
							noEvents: true,
							scrollIntoView: false,
						});
						p._filterAutoExpanded = true;
					}
				});
			}
		});
		treeOpts.autoCollapse = prevAutoCollapse;

		if (count === 0 && opts.nodata && hideMode) {
			statusNode = opts.nodata;
			if ($.isFunction(statusNode)) {
				statusNode = statusNode();
			}
			if (statusNode === true) {
				statusNode = {};
			} else if (typeof statusNode === "string") {
				statusNode = { title: statusNode };
			}
			statusNode = $.extend(
				{
					statusNodeType: "nodata",
					key: KeyNoData,
					title: this.options.strings.noData,
				},
				statusNode
			);

			this.getRootNode().addNode(statusNode).match = true;
		}
		// Redraw whole tree
		this.render();
		return count;
	};

	/**
	 * [ext-filter] Dimm or hide nodes.
	 *
	 * @param {function | string} filter
	 * @param {boolean} [opts={autoExpand: false, leavesOnly: false}]
	 * @returns {integer} count
	 * @alias Fancytree#filterNodes
	 * @requires jquery.fancytree.filter.js
	 */
	$.ui.fancytree._FancytreeClass.prototype.filterNodes = function(
		filter,
		opts
	) {
		if (typeof opts === "boolean") {
			opts = { leavesOnly: opts };
			this.warn(
				"Fancytree.filterNodes() leavesOnly option is deprecated since 2.9.0 / 2015-04-19. Use opts.leavesOnly instead."
			);
		}
		return this._applyFilterImpl(filter, false, opts);
	};

	/**
	 * @deprecated
	 */
	$.ui.fancytree._FancytreeClass.prototype.applyFilter = function(filter) {
		this.warn(
			"Fancytree.applyFilter() is deprecated since 2.1.0 / 2014-05-29. Use .filterNodes() instead."
		);
		return this.filterNodes.apply(this, arguments);
	};

	/**
	 * [ext-filter] Dimm or hide whole branches.
	 *
	 * @param {function | string} filter
	 * @param {boolean} [opts={autoExpand: false}]
	 * @returns {integer} count
	 * @alias Fancytree#filterBranches
	 * @requires jquery.fancytree.filter.js
	 */
	$.ui.fancytree._FancytreeClass.prototype.filterBranches = function(
		filter,
		opts
	) {
		return this._applyFilterImpl(filter, true, opts);
	};

	/**
	 * [ext-filter] Reset the filter.
	 *
	 * @alias Fancytree#clearFilter
	 * @requires jquery.fancytree.filter.js
	 */
	$.ui.fancytree._FancytreeClass.prototype.clearFilter = function() {
		var $title,
			statusNode = this.getRootNode()._findDirectChild(KeyNoData),
			escapeTitles = this.options.escapeTitles,
			enhanceTitle = this.options.enhanceTitle;

		if (statusNode) {
			statusNode.remove();
		}
		this.visit(function(node) {
			if (node.match && node.span) {
				// #491, #601
				$title = $(node.span).find(">span.fancytree-title");
				if (escapeTitles) {
					$title.text(node.title);
				} else {
					$title.html(node.title);
				}
				if (enhanceTitle) {
					enhanceTitle(
						{ type: "enhanceTitle" },
						{ node: node, $title: $title }
					);
				}
			}
			delete node.match;
			delete node.subMatchCount;
			delete node.titleWithHighlight;
			if (node.$subMatchBadge) {
				node.$subMatchBadge.remove();
				delete node.$subMatchBadge;
			}
			if (node._filterAutoExpanded && node.expanded) {
				node.setExpanded(false, {
					noAnimation: true,
					noEvents: true,
					scrollIntoView: false,
				});
			}
			delete node._filterAutoExpanded;
		});
		this.enableFilter = false;
		this.lastFilterArgs = null;
		this.$div.removeClass(
			"fancytree-ext-filter fancytree-ext-filter-dimm fancytree-ext-filter-hide"
		);
		this.render();
	};

	/**
	 * [ext-filter] Return true if a filter is currently applied.
	 *
	 * @returns {Boolean}
	 * @alias Fancytree#isFilterActive
	 * @requires jquery.fancytree.filter.js
	 * @since 2.13
	 */
	$.ui.fancytree._FancytreeClass.prototype.isFilterActive = function() {
		return !!this.enableFilter;
	};

	/**
	 * [ext-filter] Return true if this node is matched by current filter (or no filter is active).
	 *
	 * @returns {Boolean}
	 * @alias FancytreeNode#isMatched
	 * @requires jquery.fancytree.filter.js
	 * @since 2.13
	 */
	$.ui.fancytree._FancytreeNodeClass.prototype.isMatched = function() {
		return !(this.tree.enableFilter && !this.match);
	};

	/*******************************************************************************
	 * Extension code
	 */
	$.ui.fancytree.registerExtension({
		name: "filter",
		version: "2.30.2",
		// Default options for this extension.
		options: {
			autoApply: true, // Re-apply last filter if lazy data is loaded
			autoExpand: false, // Expand all branches that contain matches while filtered
			counter: true, // Show a badge with number of matching child nodes near parent icons
			fuzzy: false, // Match single characters in order, e.g. 'fb' will match 'FooBar'
			hideExpandedCounter: true, // Hide counter badge if parent is expanded
			hideExpanders: false, // Hide expanders if all child nodes are hidden by filter
			highlight: true, // Highlight matches by wrapping inside <mark> tags
			leavesOnly: false, // Match end nodes only
			nodata: true, // Display a 'no data' status node if result is empty
			mode: "dimm", // Grayout unmatched nodes (pass "hide" to remove unmatched node instead)
		},
		nodeLoadChildren: function(ctx, source) {
			return this._superApply(arguments).done(function() {
				if (
					ctx.tree.enableFilter &&
					ctx.tree.lastFilterArgs &&
					ctx.options.filter.autoApply
				) {
					ctx.tree._applyFilterImpl.apply(
						ctx.tree,
						ctx.tree.lastFilterArgs
					);
				}
			});
		},
		nodeSetExpanded: function(ctx, flag, callOpts) {
			delete ctx.node._filterAutoExpanded;
			// Make sure counter badge is displayed again, when node is beeing collapsed
			if (
				!flag &&
				ctx.options.filter.hideExpandedCounter &&
				ctx.node.$subMatchBadge
			) {
				ctx.node.$subMatchBadge.show();
			}
			return this._superApply(arguments);
		},
		nodeRenderStatus: function(ctx) {
			// Set classes for current status
			var res,
				node = ctx.node,
				tree = ctx.tree,
				opts = ctx.options.filter,
				$title = $(node.span).find("span.fancytree-title"),
				$span = $(node[tree.statusClassPropName]),
				enhanceTitle = ctx.options.enhanceTitle,
				escapeTitles = ctx.options.escapeTitles;

			res = this._super(ctx);
			// nothing to do, if node was not yet rendered
			if (!$span.length || !tree.enableFilter) {
				return res;
			}
			$span
				.toggleClass("fancytree-match", !!node.match)
				.toggleClass("fancytree-submatch", !!node.subMatchCount)
				.toggleClass(
					"fancytree-hide",
					!(node.match || node.subMatchCount)
				);
			// Add/update counter badge
			if (
				opts.counter &&
				node.subMatchCount &&
				(!node.isExpanded() || !opts.hideExpandedCounter)
			) {
				if (!node.$subMatchBadge) {
					node.$subMatchBadge = $(
						"<span class='fancytree-childcounter'/>"
					);
					$(
						"span.fancytree-icon, span.fancytree-custom-icon",
						node.span
					).append(node.$subMatchBadge);
				}
				node.$subMatchBadge.show().text(node.subMatchCount);
			} else if (node.$subMatchBadge) {
				node.$subMatchBadge.hide();
			}
			// node.debug("nodeRenderStatus", node.titleWithHighlight, node.title)
			// #601: also chek for $title.length, because we don't need to render
			// if node.span is null (i.e. not rendered)
			if (node.span && (!node.isEditing || !node.isEditing.call(node))) {
				if (node.titleWithHighlight) {
					$title.html(node.titleWithHighlight);
				} else if (escapeTitles) {
					$title.text(node.title);
				} else {
					$title.html(node.title);
				}
				if (enhanceTitle) {
					enhanceTitle(
						{ type: "enhanceTitle" },
						{ node: node, $title: $title }
					);
				}
			}
			return res;
		},
	});
	// Value returned by `require('jquery.fancytree..')`
	return $.ui.fancytree;
}); // End of closure
;
csui.define('csui/behaviors/collection.error/collection.error.behavior',[
  'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/error/error.view'
], function (_, Backbone, Marionette, ErrorView) {
  'use strict';

  var CollectionErrorBehavior = Marionette.Behavior.extend({

    constructor: function CollectionErrorBehavior(options, view) {
      Marionette.Behavior.prototype.constructor.apply(this, arguments);

      this.view = view;

      // Behaviors are created before the collection is stored in the view
      var collection = getBehaviorOption.call(this, 'collection') ||
                       view.collection || view.options.collection;

      // Disable the view's empty view, if fetching the collection
      // failed and the error view shoudl be shown
      var getEmptyView = view.getEmptyView;
      view.getEmptyView = function () {
        return collection.error ? ErrorView :
               getEmptyView.apply(view, arguments);
      };
      var emptyViewOptions = view.emptyViewOptions;
      view.emptyViewOptions = function () {
        var error = collection.error;
        if (error) {
          return {
            model: new Backbone.Model({
              message: error.message
            })
          };
        }
        return _.isFunction(emptyViewOptions) ?
               emptyViewOptions.apply(view, arguments) :
               emptyViewOptions;
      };

      // Re-render the view, if fetching the data failed
      this.listenTo(collection, 'error', function () {
        view.collection.reset();
      });
    }

  });

  function getBehaviorOption(property) {
    var value = this.getOption(property);
    return (_.isFunction(value) ? value.call(this.view) : value);
  }

  return CollectionErrorBehavior;
});


/* START_TEMPLATE */
csui.define('hbs!csui/behaviors/collection.state/impl/collection.state',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<p>"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"message") || (depth0 != null ? lookupProperty(depth0,"message") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"message","hash":{},"loc":{"start":{"line":1,"column":3},"end":{"line":1,"column":14}}}) : helper)))
    + "</p>";
}});
Handlebars.registerPartial('csui_behaviors_collection.state_impl_collection.state', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/behaviors/collection.state/collection.state.view',[
  'csui/lib/underscore', 'csui/lib/marionette',
  'hbs!csui/behaviors/collection.state/impl/collection.state'
], function (_, Marionette, template) {
  'use strict';

  var CollectionStateView = Marionette.ItemView.extend({

    className: 'csui-collection-state',

    template: template,

    constructor: function CollectionStateView() {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.listenTo(this.model, 'change:state', this.render)
          .listenTo(this, 'render', this._updateClasses);
    },

    serializeData: function () {
      return _.extend(this.model.toJSON(), {
        // empty, loading, failed
        message: this.options.stateMessages[this.model.get('state')]
      });
    },

    _updateClasses: function () {
      this.$el
          .removeClass('csui-state-empty csui-state-loading csui-state-failed')
          .addClass('csui-state-' + this.model.get('state'));
    }

  });

  return CollectionStateView;
});

csui.define('csui/behaviors/collection.state/collection.state.behavior',[
  'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/behaviors/collection.state/collection.state.view'
], function (_, Backbone, Marionette, CollectionStateView) {
  'use strict';

  var CollectionStateBehavior = Marionette.Behavior.extend({

    constructor: function CollectionStateBehavior(options, view) {
      Marionette.Behavior.prototype.constructor.apply(this, arguments);

      this.view = view;

      // Behaviors are created before the collection is stored in the view
      var viewCollection = view.collection || view.options.collection,
          collection = getBehaviorOption.call(this, 'collection') ||
                       viewCollection;
      this.listenTo(collection, 'request', this._fetchingCollectionStarted)
          .listenTo(collection, 'sync', this._fetchingCollectionSucceeded)
          .listenTo(collection, 'error', this._fetchingCollectionFailed)
          .listenTo(viewCollection, 'reset', this._collectionReset);

      this.collectionState = new Backbone.Model({
        state: collection.fetching ? 'loading' :
               collection.error ? 'failed' :
               collection.length ? 'full' : 'empty'
      });

      var stateView = this.getOption('stateView');
      if (_.isFunction(stateView) &&
          !(stateView.prototype instanceof Backbone.View)) {
        stateView = stateView.call(view);
      }
      view.emptyView = stateView || CollectionStateView;

      var self = this;
      view.emptyViewOptions = function () {
        return _.extend({
          model: self.collectionState,
          stateMessages: getBehaviorOption.call(self, 'stateMessages') || {}
        }, getBehaviorOption.call(self, 'stateViewOptions'));
      };
    },

    _collectionReset: function (collection) {
      var state = this.collectionState.get('state');
      if (state !== 'loading' && state !== 'error') {
        this.collectionState.set('state', collection.length ? 'full' : 'empty');
      }
    },

    _fetchingCollectionStarted: function () {
      // show loading message only if there were already models in the collection
      if (this.view.collection.length === 0) {
        this.collectionState.set('state', 'loading');
        this.view.collection.reset();
        this.view.blockWithoutIndicator && this.view.blockWithoutIndicator();
      }
    },

    _fetchingCollectionSucceeded: function () {
      this.collectionState.set('state',
          this.view.collection.length ? 'full' : 'empty');
      this.view.unblockActions && this.view.unblockActions();
    },

    _fetchingCollectionFailed: function () {
      this.collectionState.set('state', 'failed');
      this.view.unblockActions && this.view.unblockActions();
    }

  });

  function getBehaviorOption(property) {
    var value = this.getOption(property);
    return (_.isFunction(value) ? value.call(this.view) : value);
  }

  return CollectionStateBehavior;
});

// Renders a view in a modal dialog and waits for the user to close it
csui.define('csui/controls/dialog/dialog.view',[
  'smart/controls/dialog/dialog.view',
  'csui/lib/binf/js/binf'
], function (SmartDialogView) {

  var DialogView = SmartDialogView.extend({

    constructor: function DialogView(options) {
      SmartDialogView.prototype.constructor.call(this, options);
    }

  });
 
  return DialogView;

});

csui.define('csui/controls/dialog/impl/header.view',['smart/controls/dialog/header.view'
], function (SmartDialogHeaderView) {

  var DialogHeaderView = SmartDialogHeaderView.extend({

    constructor: function DialogView(options) {
      SmartDialogHeaderView.prototype.constructor.call(this, options);
    }

  });
  return DialogHeaderView;
});

csui.define('csui/controls/dialog/footer.view',['smart/controls/dialog/footer.view'
], function (SmartDialogFooterView) {

  var DialogFooterView = SmartDialogFooterView.extend({

    constructor: function DialogHeaderView(options) {
      SmartDialogFooterView.prototype.constructor.call(this, options);
    }
    
  });

  return DialogFooterView;
});

csui.define('csui/models/facettopic',[
  'csui/lib/backbone'
], function (Backbone) {
  'use strict';

  var FacetTopicModel = Backbone.Model.extend({
    idAttribute: 'value',

    constructor: function FacetTopicModel() {
      Backbone.Model.prototype.constructor.apply(this, arguments);
    }
  });

  return FacetTopicModel;
});

csui.define('csui/models/facettopics',[
  'csui/lib/backbone', 'csui/models/facettopic'
], function (Backbone, FacetTopicModel) {
  'use strict';

  var FacetTopicCollection = Backbone.Collection.extend({
    model: FacetTopicModel,

    constructor: function FacetTopicCollection(models, options) {
      Backbone.Collection.prototype.constructor.apply(this, arguments);
    }
  });

  return FacetTopicCollection;
});

csui.define('csui/models/facet',[
  'csui/lib/backbone', 'csui/models/facettopics'
], function (Backbone, FacetTopicCollection) {
  'use strict';

  var FacetModel = Backbone.Model.extend({
    constructor: function FacetModel(attributes) {
      Backbone.Model.prototype.constructor.apply(this, arguments);

      this.topics = new FacetTopicCollection(attributes && attributes.topics);
    },

    parse: function (response, options) {
      if (this.topics) {
        this.topics.reset(response.topics);
      }
      return response;
    }
  });

  return FacetModel;
});

csui.define('csui/models/facets',[
  'csui/lib/underscore', 'csui/lib/backbone', 'csui/models/facet',
  'csui/utils/deepClone/deepClone'
], function (_, Backbone, FacetModel) {
  'use strict';

  var FacetCollection = Backbone.Collection.extend({
    model: FacetModel,

    constructor: function FacetCollection(models, options) {
      Backbone.Collection.prototype.constructor.apply(this, arguments);
      options || (options = {});
      this.filters = options.filters || [];
      this.itemsToShow = options.itemsToShow;  // only used with v2/facets call
      this.facetIds = options.facetIds || [];  // only used with v2/facets call
    },

    clone: function () {
      return new this.constructor(this.models, {
        filters: _.deepClone(this.filters)
      });
    },

    setFilter: function (filters, fetch, options) {
      if (!_.isEqual(this.filters, filters)) {
        this.filters = filters;
        if (fetch !== false && areFacetsFetchable(this)) {
          this.fetch(options);
        }
        return true;
      }
    },

    addFilter: function (filters, fetch, options) {
      var existingFilters = this.filters,
          newFilters = [],
          modified;
      if (!Array.isArray(filters)) {
        filters = [filters];
      }
      filters.forEach(function (filter) {
        var existingFilter = _.findWhere(existingFilters, {id: filter.id});
        if (existingFilter) {
          var existingValues = existingFilter.values,
              newValues = filter.values.filter(function (value) {
                return !_.findWhere(existingValues, {id: value.id});
              });
          if (newValues.length) {
            existingValues.push.apply(existingValues, newValues);
            modified = true;
          }
        } else {
          if (filter.values.length) {
            newFilters.push(filter);
          }
        }
      });
      if (newFilters.length) {
        existingFilters.push.apply(existingFilters, newFilters);
        modified = true;
      }
      if (modified) {
        if (fetch !== false && areFacetsFetchable(this)) {
          this.fetch(options);
        }
        return true;
      }
    },

    removeFilter: function (filters, fetch, options) {
      var modified;
      if (!Array.isArray(filters)) {
        filters = [filters];
      }
      this.filters = this.filters.facet ? this.filters.facet : this.filters;
      this.filters = _.reject(this.filters, function (existingFilter) {
        var filter = _.findWhere(filters, {id: existingFilter.id});
        if (filter) {
          var values = filter.values,
              newValues = _.reject(existingFilter.values, function (existingValue) {
                if (_.findWhere(values, {id: existingValue.id})) {
                  modified = true;
                  return true;
                }
              });
          if (!newValues.length) {
            modified = true;
            return true;
          }
          existingFilter.values = newValues;
        }
      });
      if (modified) {
        if (fetch !== false && areFacetsFetchable(this)) {
          this.fetch(options);
        }
        return true;
      }
    },

    clearFilter: function (fetch, options) {
      if (this.filters.length > 0) {
        this.filters = [];
        if (fetch !== false && areFacetsFetchable(this)) {
          this.fetch(options);
        }
        return true;
      }
    },

    getAvailableFacets: function () {
      return getSomeFacets(this, false);
    },

    getSelectedFacets: function () {
      return getSomeFacets(this, true);
    }
  });

  function areFacetsFetchable(facets) {
    return facets.isFetchable && facets.isFetchable();
  }

  function getSomeFacets(facets, selected) {
    selected = !!selected;
    return facets
      // Take only facets with at least one selected/available topic.
      .filter(function (facet) {
        return facet.topics.some(function (topic) {
          var isSelected = !!topic.get('selected');
          return selected === isSelected;
        });
      })
      // Clone facets with selected/available topics.
      .map(function (facet) {
        facet = facet.toJSON();
        facet.topics = facet.topics.filter(function (topic) {
          var isSelected = !!topic.selected;
          return selected === isSelected;
        });
        return facet;
      });
  }

  return FacetCollection;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/facet.bar/impl/facet.bar.item',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return " csui-facet-item-content-readonly ";
},"3":function(container,depth0,helpers,partials,data) {
    return " csui-label-readonly ";
},"5":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "      <span class=\"csui-icon binf-close\" data-csui-facet=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"facetId") || (depth0 != null ? lookupProperty(depth0,"facetId") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"facetId","hash":{},"loc":{"start":{"line":8,"column":58},"end":{"line":8,"column":69}}}) : helper)))
    + "\"\r\n            data-csui-topic=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"topicId") || (depth0 != null ? lookupProperty(depth0,"topicId") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"topicId","hash":{},"loc":{"start":{"line":9,"column":29},"end":{"line":9,"column":40}}}) : helper)))
    + "\"></span>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<a href=\"#\" role=\"button\" class=\"csui-facet-item-content"
    + ((stack1 = lookupProperty(helpers,"unless").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableCloseIcon") : depth0),{"name":"unless","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":1,"column":56},"end":{"line":1,"column":128}}})) != null ? stack1 : "")
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"facetItemAria") || (depth0 != null ? lookupProperty(depth0,"facetItemAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"facetItemAria","hash":{},"loc":{"start":{"line":1,"column":142},"end":{"line":1,"column":159}}}) : helper)))
    + "\">\r\n  <div>\r\n    <span class=\"csui-label"
    + ((stack1 = lookupProperty(helpers,"unless").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableCloseIcon") : depth0),{"name":"unless","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":3,"column":27},"end":{"line":3,"column":86}}})) != null ? stack1 : "")
    + "\">\r\n      <span class=\"csui-facet-item-facet-name\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"facetName") || (depth0 != null ? lookupProperty(depth0,"facetName") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"facetName","hash":{},"loc":{"start":{"line":4,"column":47},"end":{"line":4,"column":60}}}) : helper)))
    + ":</span>\r\n      <span class=\"csui-facet-item-topic-name\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"topicName") || (depth0 != null ? lookupProperty(depth0,"topicName") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"topicName","hash":{},"loc":{"start":{"line":5,"column":47},"end":{"line":5,"column":60}}}) : helper)))
    + "</span>\r\n    </span>\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableCloseIcon") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"loc":{"start":{"line":7,"column":4},"end":{"line":10,"column":11}}})) != null ? stack1 : "")
    + "  </div>\r\n</a>\r\n";
}});
Handlebars.registerPartial('csui_controls_facet.bar_impl_facet.bar.item', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/facet.bar/impl/facet.bar.item.view',["module",
  "csui/lib/jquery",
  "csui/lib/underscore",
  "csui/lib/marionette",
  "hbs!csui/controls/facet.bar/impl/facet.bar.item"
], function (module, $, _, Marionette, template) {

  var FacetBarItemView = Marionette.ItemView.extend({

    className: 'csui-facet-item',

    tagName: 'li',

    template: template,

    ui: {
      'item': '.csui-facet-item',
      'content': '.csui-facet-item-content'
    },

    events: {
      'click @ui.item': 'cancelClick',
      'click @ui.content': 'cancelClick'
    },

    templateHelpers: function () {
      return {
        enableCloseIcon : this.enableCloseIcon
      };
    },

    constructor: function FacetBarItemView(options) {
      this.options = options || {};
      this.enableCloseIcon = this.options.model && this.options.model.get('readOnlyFilter') ? false : true;
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    cancelClick: function (event) {
      // there is a href="#" set on the a-tag to let the browser make the facet item accessible
      // by keyboard. Don't let the event do anything, because it would let the browser to
      // navigate to the landing page.
      if (!$(event.target).hasClass('binf-close')) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  });

  return FacetBarItemView;
});

csui.define('csui/controls/facet.bar/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/facet.bar/impl/nls/root/lang',{
  clearAll: 'Clear all',
  saveAs: 'Save As',
  saveAsAria: 'Save as Virtual Folder',
  previous:'Show previous filter(s)',
  next:'Show next filter(s)',
  filterListAria: 'List of active filters',
  clearAllAria: 'Clear all filters',
  facetItemAria: 'Selected filter {0}:{1}, press to clear.'
});



csui.define('css!csui/controls/facet.bar/impl/facet.bar',[],function(){});
csui.define('csui/controls/facet.bar/facet.bar.items.view',["csui/lib/underscore", "csui/lib/jquery", "csui/lib/marionette",
  'csui/controls/facet.bar/impl/facet.bar.item.view',
  'i18n!csui/controls/facet.bar/impl/nls/lang',
  'css!csui/controls/facet.bar/impl/facet.bar'
], function (_, $, Marionette,
    FacetBarItemView, lang) {

  var FacetBarItemsView = Marionette.CollectionView.extend({

    childView: FacetBarItemView,
    tagName: "ol",
    className: 'csui-facet-list',

    constructor: function FacetBarItemsView(options) {
      Marionette.CollectionView.prototype.constructor.apply(this, arguments);
      this.listenTo(this.collection, 'reset', this._checkOverflow);
      this.listenTo(this.collection, 'change', this._checkOverflow);
      this.listenTo(this.collection, 'add', this._checkOverflow);
      this.listenTo(this.collection, 'remove', this._checkOverflow);
      this.listenTo(this, 'dom:refresh', this._checkOverflow);
      this.listenTo(this, 'dom:refresh', this._calcScrollSteps);
    },

    onRender: function () {
      this.$el.attr('aria-label', lang.filterListAria);
    },

    _calcScrollSteps: function () {
      var el = this.$el[0];
      var ow = el.offsetWidth;
      var sw = el.scrollWidth;
      this.scrollStepPx = (ow / 3) * 2;
      if (sw > ow) {
        this.maxScrollLeft = sw - ow + 8; // add a few pixel to let it scroll enough to the left
      } else {
        this.maxScrollLeft = 0;
      }
    },

    _checkOverflow: function () {
      if (this.$el.length) {
        var el = this.$el[0];
        var ow = el.offsetWidth;
        var sw = el.scrollWidth;
        // list of facet bar items is overflowing or not -> others might do something depending
        // on it
        this.trigger('overflow', ow < sw);
        this.trigger('scrolled',
            {currentScrollLeft: this.$el.scrollLeft(), maxScrollLeft: this.maxScrollLeft});
      }
    },

    scrollLeft: function () {
      var el = this.$el;
      var currentScrollLeft = el.scrollLeft();
      var newScrollLeft = currentScrollLeft;
      if (currentScrollLeft < this.maxScrollLeft) {
        newScrollLeft = currentScrollLeft + this.scrollStepPx;
        if (newScrollLeft > this.maxScrollLeft) {
          newScrollLeft = this.maxScrollLeft;
        }
        el.animate({scrollLeft: newScrollLeft}, 500);
      }
      this.trigger('scrolled',
          {currentScrollLeft: newScrollLeft, maxScrollLeft: this.maxScrollLeft});
      return newScrollLeft;
    },

    scrollRight: function () {
      var el = this.$el;
      var currentScrollLeft = el.scrollLeft();
      var newScrollLeft = 0;
      if (currentScrollLeft > this.scrollStepPx) {
        newScrollLeft = currentScrollLeft - this.scrollStepPx;
      }
      el.animate({scrollLeft: newScrollLeft}, 500);
      this.trigger('scrolled',
          {currentScrollLeft: newScrollLeft, maxScrollLeft: this.maxScrollLeft});
      return el.scrollLeft();
    }
  });

  return FacetBarItemsView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/facet.bar/impl/facet.bar',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<button class=\"binf-btn binf-btn-primary csui-filter-save binf-hidden\"\r\n        aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"saveAsAria") || (depth0 != null ? lookupProperty(depth0,"saveAsAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"saveAsAria","hash":{},"loc":{"start":{"line":25,"column":20},"end":{"line":25,"column":34}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"saveas") || (depth0 != null ? lookupProperty(depth0,"saveas") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"saveas","hash":{},"loc":{"start":{"line":25,"column":36},"end":{"line":25,"column":46}}}) : helper)))
    + "</button>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"csui-facet-list-bar\">\r\n  <div class=\"csui-mover csui-overflow-left binf-hidden\">\r\n    <a href=\"#\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"previous") || (depth0 != null ? lookupProperty(depth0,"previous") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"previous","hash":{},"loc":{"start":{"line":3,"column":23},"end":{"line":3,"column":35}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"previous") || (depth0 != null ? lookupProperty(depth0,"previous") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"previous","hash":{},"loc":{"start":{"line":3,"column":49},"end":{"line":3,"column":61}}}) : helper)))
    + "\">\r\n      <span class=\"csui-icon goto_previous_page\"  ></span>\r\n    </a>\r\n    <span class=\"csui-facet-list-fade csui-facet-list-fadein\"></span>\r\n  </div>\r\n\r\n  <div class=\"csui-facet-list-area\"></div>\r\n\r\n  <div class=\"csui-mover csui-overflow-right binf-hidden\">\r\n    <span class=\"csui-facet-list-fade csui-facet-list-fadeout\"></span>\r\n    <a href=\"#\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"next") || (depth0 != null ? lookupProperty(depth0,"next") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"next","hash":{},"loc":{"start":{"line":13,"column":23},"end":{"line":13,"column":31}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"next") || (depth0 != null ? lookupProperty(depth0,"next") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"next","hash":{},"loc":{"start":{"line":13,"column":45},"end":{"line":13,"column":53}}}) : helper)))
    + "\">\r\n      <span class=\"csui-icon goto_next_page\" ></span>\r\n    </a>\r\n  </div>\r\n</div>\r\n\r\n<a href=\"#\" class=\"csui-clear-all binf-hidden\" role=\"button\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"clearAllAria") || (depth0 != null ? lookupProperty(depth0,"clearAllAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"clearAllAria","hash":{},"loc":{"start":{"line":19,"column":73},"end":{"line":19,"column":89}}}) : helper)))
    + "\">\r\n  <div class='cs-icon binf-close'></div>\r\n  <div class='clear-label'>"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"clearAll") || (depth0 != null ? lookupProperty(depth0,"clearAll") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"clearAll","hash":{},"loc":{"start":{"line":21,"column":27},"end":{"line":21,"column":39}}}) : helper)))
    + "</div>\r\n</a>\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"showSaveFilter") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":23,"column":0},"end":{"line":26,"column":7}}})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_facet.bar_impl_facet.bar', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('csui/controls/facet.bar/savefilter.unsupported.list.ids',['csui/lib/underscore',
  // Load external unsupported types
  'csui-ext!csui/controls/facet.bar/savefilter.unsupported.list.ids',
], function (_, unsupportedList) {
  'use strict';

  return _.flatten(unsupportedList);

});
csui.define('csui/controls/facet.bar/facet.bar.view',[
  "csui/lib/jquery",
  "csui/lib/underscore",
  "csui/lib/backbone",
  "csui/lib/marionette",
  "csui/models/facets",
  "csui/models/facettopics",
  "csui/controls/facet.bar/facet.bar.items.view",
  "csui/behaviors/keyboard.navigation/tabable.region.behavior",
  "hbs!csui/controls/facet.bar/impl/facet.bar",
  "i18n!csui/controls/facet.bar/impl/nls/lang",
  "csui/utils/commands",
  "csui/controls/facet.bar/savefilter.unsupported.list.ids",
  "css!csui/controls/facet.bar/impl/facet.bar"
], function ($, _, Backbone, Marionette, FacetCollection,
    FacetTopicCollection, FacetBarItemsView, TabableRegionBehavior,
    template, lang, commands, unsupportedList) {
  'use strict';

  var FacetBarView = Marionette.LayoutView.extend({
    className: 'csui-facet-bar csui-facet-bar-hidden',

    template: template,

    ui: {
      facetListArea: '> .csui-facet-list-bar > .csui-facet-list-area',
      facetList: '> .csui-facet-list-bar > .div.csui-facet-list-area > .csui-facet-list',
      clearAll: '.csui-clear-all',
      moveLeft: '.csui-overflow-left',
      moveRight: '.csui-overflow-right',
      movers: '.csui-mover',
      leftFader: '.csui-mover.csui-overflow-left > .csui-facet-list-fade',
      rightFader: '.csui-mover.csui-overflow-right > .csui-facet-list-fade',
      saveFilter: '.csui-filter-save'
    },

    regions: {
      facetBarItemsRegion: '.csui-facet-list-area',
      clearAllRegion: '.csui-clear-all'
    },

    triggers: {
      'click .csui-clear-all': 'clear:all'
    },

    events: {
      'click @ui.moveLeft': 'onMoveLeft',
      'click @ui.moveRight': 'onMoveRight',
      'click .csui-facet-item .binf-close': 'onRemoveFilter',
      'click @ui.saveFilter': 'onClickSaveFilter',
      'keydown': 'onKeyInView'
    },

    constructor: function FacetBarView(options) {
      Marionette.LayoutView.prototype.constructor.apply(this, arguments);

      this.allTopicsCollection = new Backbone.Collection(this._getAllTopics(
          this.collection.filters));
      this.listenTo(this.collection, 'reset', this._filtersUpdated, this);
      this.listenTo(this.collection, 'set:readonly', this._filtersUpdated, this);
      this.onWinResize = _.bind(function () {
        this.render();
        this._filtersUpdated();
      }, this);
      $(window).on("resize.facetview", this.onWinResize);
    },

    onKeyInView: function (event) {
      var keyCode = event.keyCode,
          retVal  = true,
          $target = $(event.target);

      switch (keyCode) {
        //delete key
      case 46:
        if ($target.parent().hasClass('csui-facet-item')) {
          this._triggerRemoveFilter($target.find('.binf-close'));
          retVal = false;
        }
        break;
        //enter and space bar
      case 13:
        if ($target.parent().hasClass('csui-facet-item')) {
          this._triggerRemoveFilter($target.find('.binf-close'));
          retVal = false;
        }
        if ($target.hasClass('csui-clear-all')) {
          if (this.ui.saveFilter && this.ui.saveFilter.length > 0) {
            this.ui.saveFilter.addClass('binf-hidden');
          }
          this.trigger('remove:all');
          retVal = false;
        }
        break;
        //ignore space bar but return false as it appears to affect the facet panel scrolling
      case 32:
        retVal = false;
        break;
      }
      return retVal;
    },

    onDestroy: function () {
      $(window).off("resize.facetview", this.onWinResize);
    },

    onRender: function () {
      this.visibleItemIndex = 0;
      this.facetBarItemsView = new FacetBarItemsView({collection: this.allTopicsCollection});
      this.listenTo(this.facetBarItemsView, 'overflow', this._makeSlideable);
      this.listenTo(this.facetBarItemsView, 'scrolled', this._updateFading);
      this.facetBarItemsRegion.show(this.facetBarItemsView);
    },

    onMoveLeft: function (event) {
      event.preventDefault();
      event.stopPropagation();

      this.facetBarItemsView.scrollRight();
    },

    onMoveRight: function (event) {
      event.preventDefault();
      event.stopPropagation();

      this.facetBarItemsView.scrollLeft();
    },

    _makeSlideable: function (hasOverflow) {
      if (hasOverflow) {
        this.ui.facetListArea.addClass('csui-facet-list-overflowed');
        this.ui.movers.removeClass('binf-hidden');
      } else {
        this.ui.facetListArea.removeClass('csui-facet-list-overflowed');
        this.ui.movers.addClass('binf-hidden');
      }
    },

    _updateFading: function (options) {
      if (options.currentScrollLeft === 0) {
        this.ui.leftFader.addClass('binf-hidden');
        this.ui.rightFader.removeClass('binf-hidden');
      } else {
        if (options.currentScrollLeft === options.maxScrollLeft) {
          this.ui.leftFader.removeClass('binf-hidden');
          this.ui.rightFader.addClass('binf-hidden');
        } else {
          this.ui.leftFader.removeClass('binf-hidden');
          this.ui.rightFader.removeClass('binf-hidden');
        }
      }

    },

    _getAllTopics: function () {
      var allTopics = [];
      var filters = this.collection.filters;
      for (var i = 0; i < filters.length; i++) {
        var filter = filters[i],
            values = filter.values,
            facetId = filter.id,
            readOnlyFilter = filter.readOnlyFilter,
            facet = this.collection.get(facetId);
        if (facet) {
          var facetName = !!facet && facet.get('name');
          for (var j = 0; j < values.length; j++) {
            var value     = values[j],
                topicId   = value.id,
                topic     = !!facet.topics && facet.topics.get(topicId),
                topicName = !!topic && topic.get('name');
            allTopics.push({
              facetName: facetName,
              topicName: topicName,
              facetId: facetId,
              topicId: topicId,
              facetItemAria: _.str.sformat(lang.facetItemAria, facetName, topicName),
              readOnlyFilter: readOnlyFilter
            });
          }
        }
      }
      return allTopics;
    },

    _filtersUpdated: function () {
      var allTopics = this._getAllTopics(this.collection.filters);
      this.allTopicsCollection.reset(allTopics);
      if (this.allTopicsCollection.length > 0) {
        // this.$el.show();
        // this.$el.removeClass('binf-hidden');
        // this.$el.height('100%');
        this.$el.removeClass('csui-facet-bar-hidden');
        //if any of the filters are readOnly filters, then hide clear all button
        var hideClearAll = allTopics.some(function( topic ) { return topic.readOnlyFilter === true });
        hideClearAll ? this.$el.find('.csui-clear-all').addClass('binf-hidden') : this.$el.find('.csui-clear-all').removeClass('binf-hidden');
        this.trigger('facet:bar:visible');
        // this.$el.parent().removeClass('csui-facet-bar-hidden');
      }
      else {
        // this.$el.hide();
        // this.$el.addClass('binf-hidden');
        // this.$el.height('0px');
        this.$el.addClass('csui-facet-bar-hidden');
        this.$el.find('.csui-clear-all').addClass('binf-hidden');
        this.$el.find('.csui-filter-save').addClass('binf-hidden');
        this.trigger('facet:bar:hidden');
        // this.$el.parent().addClass('csui-facet-bar-hidden');
      }
      if (this.showSaveFilter && this.allTopicsCollection.length > 0) {
        if (this.ui.saveFilter && this.ui.saveFilter.length > 0) {
          this.ui.saveFilter.removeClass('binf-hidden');
        }
      }
      this.facetBarItemsView && this.facetBarItemsView.trigger('dom:refresh');
    },

    showOrHideSaveFilterButton: function () {
      var self = this;
      if (unsupportedList.length > 0) {
       var isUnsupportedType = _.some(unsupportedList, function (ids) {
          var unsupportedTypes = typeof ids.saveFilterUnsupportedList === 'function' ? ids.saveFilterUnsupportedList(self.options) : ids.saveFilterUnsupportedList,
           nodeType = self.options.context.getModel('node').attributes.type;
          if (_.isArray(unsupportedTypes) || _.isNumber(unsupportedTypes) ) {
            return _.isArray(unsupportedTypes) ? _.contains(unsupportedTypes,nodeType) : unsupportedTypes === nodeType;
          }
          else {
            throw new Error("Unsupported object type");
          }
        });
        return !isUnsupportedType;
      }
      else if (_.has(this.options, "showSaveFilter")) {
        return this.options.showSaveFilter;
      }
      else {
        var objectTypes = this.options.context && this.options.context._factories.objecttypes && _.has(this.options.context._factories.objecttypes.property.attributes, "objecttypes") &&
          this.options.context._factories.objecttypes.property.attributes.objecttypes;
        //verifying if the current user has permissions to create a virtual folder
        return !!_.find(objectTypes, function (object) { return object.type === 899; });
      }
    },

    templateHelpers: function () {
      this.showSaveFilter = this.showOrHideSaveFilterButton();
      return {
        clearAll: lang.clearAll,
        saveas: lang.saveAs,
        saveAsAria: lang.saveAsAria,
        showSaveFilter: this.showSaveFilter,
        previous: lang.previous,
        next: lang.next,
        clearAllAria: lang.clearAllAria
      };
    },

    onClearAll: function () {
      // if (this.ui.saveFilter && this.ui.saveFilter.length > 0) {
      //   this.ui.saveFilter.addClass('binf-hidden');
      // }
      this.trigger('remove:all');
    },

    onRemoveFilter: function (e) {
      e.preventDefault();
      e.stopPropagation();
      this._triggerRemoveFilter($(e.target));
    },

    applyFilter: function (facet) {
      this.trigger('apply:filter', facet.newFilter);
    },

    onClickSaveFilter: function (event) {
      event.preventDefault();
      event.stopPropagation();
      var context         = this.options.context,
          connector       = this.collection.connector,
          node            = this.collection.node,
          facetCollection = this.collection,
          // Get the SaveFilter command and execute it for the specific node
          saveFilter      = commands.get('SaveFilter'),
          promise         = saveFilter.execute({
            context: context,
            nodes: new Backbone.Collection(node),
            facets: facetCollection,
            container: node,
            connector: connector
          });
      // Wait until the deletion is done and log the result on the console
      promise.always(function () {
        var succeeded = promise.state() === 'resolved';
      });
    },

    _triggerRemoveFilter: function ($target) {
      this.trigger('remove:filter', {
        id: $target.attr('data-csui-facet'),
        values: [
          {id: $target.attr('data-csui-topic')}
        ]
      });
    }
  });

  return FacetBarView;
});

csui.define('csui/controls/list/behaviors/list.item.keyboard.behavior',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/utils/log', 'csui/lib/marionette'
], function (module, _, $, log, Marionette) {
  'use strict';

  //
  // This behavior implements a default keyboard navigation for the ListItemView.
  // TODO: Move duplicate code of show/hide inline action from listitem and treeitem to here
  //

  function stopEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  return Marionette.Behavior.extend({

    ui: {
      titleName: '.list-item-title',
      moreActions: '.csui-tileview-more-btn'
    },

    events: function() {
      var events = {
        'keydown @ui.titleName': '_doDefaultAction'
      };
      if (this.view.showInlineActionBar) {
        events = _.extend(events, {
          'keydown': '_handleInlineKeyDown'
        });
      } else {
        events = _.extend(events, {
          'keydown': '_doDefaultAction'
        });
      }
      return events;
    },

    constructor: function ListItemKeyboardBehavior(options, view) {
      Marionette.Behavior.prototype.constructor.apply(this, arguments);
    },

    _doDefaultAction: function (e) {
      if (e.keyCode == 13 || e.keyCode == 32) {
        e.stopPropagation();
        this.view.trigger("click:item", {target: this.view.model});
      }
    },

    _handleInlineKeyDown: function (e) {
      var $target = $(e.target);
      switch (e.keyCode) {
      case 13: // enter
        this.view.onShowInlineMenu(e);
        this.ui.titleName.prop('tabindex', -1).trigger("focus");
        stopEvent(e);
        break;
      case 27: //escape
        var hasInlineMenu = this.view.onHideInlineMenu();
        if (hasInlineMenu) {
          this.$el.trigger("focus");
          stopEvent(e);
        }
        break;
      case 37: // arrow left
          if ((this.ui.moreActions.is($target) || this.ui.moreActions.has($target).length)) {
            this.ui.titleName.prop('tabindex', -1).trigger("focus");
            stopEvent(e);
          } else if (this.ui.titleName.is($target)) {
            stopEvent(e);
          }
        break;
      case 39: // arrow right
        if (this.ui.titleName.is($target)) {
          this.view._inlineMenuView.acquireFocus();
          stopEvent(e);
        }
        break;
      default:
        if ((this.ui.moreActions.is($target) || this.ui.moreActions.has($target).length) ||
          this.ui.titleName.is($target)) {
          // on children of row (title and 3-dot menu):
          if (e.keyCode>=33 && e.keyCode<=40)
          {
            // Cancel only unwanted navigation events
            stopEvent(e);
          }
        }
      }
    },

  });

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/listitem/impl/inline.menu/inline.menu',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "\r\n      title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"dropDownText") || (depth0 != null ? lookupProperty(depth0,"dropDownText") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"dropDownText","hash":{},"loc":{"start":{"line":2,"column":13},"end":{"line":2,"column":29}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"dropDownText") || (depth0 != null ? lookupProperty(depth0,"dropDownText") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"dropDownText","hash":{},"loc":{"start":{"line":2,"column":43},"end":{"line":2,"column":59}}}) : helper)))
    + "\" tabindex=\"-1\"";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<span class=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"dropDownIcon") || (depth0 != null ? lookupProperty(depth0,"dropDownIcon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"dropDownIcon","hash":{},"loc":{"start":{"line":3,"column":35},"end":{"line":3,"column":51}}}) : helper)))
    + "\"></span>";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"states":"true","iconName":(depth0 != null ? lookupProperty(depth0,"dropDownIconName") : depth0)},"loc":{"start":{"line":4,"column":26},"end":{"line":4,"column":79}}})) != null ? stack1 : "");
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"csui-icon-group csui-menu-btn\" role=\"button\" aria-expanded=\"false\" "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"dropDownText") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":1,"column":79},"end":{"line":2,"column":81}}})) != null ? stack1 : "")
    + ">\r\n  "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"dropDownIcon") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":3,"column":2},"end":{"line":3,"column":67}}})) != null ? stack1 : "")
    + "\r\n  "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"dropDownIconName") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"loc":{"start":{"line":4,"column":2},"end":{"line":4,"column":86}}})) != null ? stack1 : "")
    + "\r\n</div>\r\n<div class=\"csui-icon-group csui-loading-parent-wrapper binf-disabled binf-hidden\"\r\n      title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"loadingTitle") || (depth0 != null ? lookupProperty(depth0,"loadingTitle") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"loadingTitle","hash":{},"loc":{"start":{"line":7,"column":13},"end":{"line":7,"column":29}}}) : helper)))
    + "\" role=\"presentation\" tabindex=\"-1\">\r\n  <div class=\"csui-loading-dots-wrapper\">\r\n    <span class=\"csui-loading-dot\"></span>\r\n    <span class=\"csui-loading-dot\"></span>\r\n    <span class=\"csui-loading-dot\"></span>\r\n  </div>\r\n</div>\r\n<div class=\"csui-menu-btn-region binf-hidden\"></div>";
}});
Handlebars.registerPartial('csui_controls_listitem_impl_inline.menu_inline.menu', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/listitem/impl/inline.menu/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/listitem/impl/inline.menu/nls/root/lang',{
  loadingActions: 'Loading {0}'
});



csui.define('css!csui/controls/listitem/impl/inline.menu/inline.menu',[],function(){});
csui.define('csui/controls/listitem/impl/inline.menu/inline.menu.view',['require', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/utils/base', 'csui/controls/globalmessage/globalmessage',
  'hbs!csui/controls/listitem/impl/inline.menu/inline.menu',
  'i18n!csui/controls/listitem/impl/inline.menu/nls/lang',
  'css!csui/controls/listitem/impl/inline.menu/inline.menu'
], function (require, _, $, Marionette, base, GlobalMessage, template, lang) {
  'use strict';

  var InlineMenuView = Marionette.ItemView.extend({

    tagName: 'div',
    className: 'csui-inline-menu',

    template: template,
    templateHelpers: function () {
      return {
        dropDownText: this.inlineActionbarOptions.dropDownText,
        dropDownIconName: this.inlineActionbarOptions.dropDownIconName,
        loadingTitle: _.str.sformat(lang.loadingActions, this.inlineActionbarOptions.dropDownText),

        // remove when css based icons no more used
        dropDownIcon: this.inlineActionbarOptions.dropDownIcon

      };
    },

    ui: {
      moreToggle: '.csui-menu-btn',
      toolbarContainer: '.csui-menu-btn-region',
      dropdownToggle: '.csui-menu-btn-region .binf-dropdown .binf-dropdown-toggle',
      loadingContainer: '.csui-loading-parent-wrapper'
    },

    events: {
      'click @ui.moreToggle': 'onClickMenuButton',
      'click @ui.dropdownToggle': 'onClickMenuButton',
      'keydown @ui.moreToggle': 'onKeydownMenu',
      'keydown @ui.dropdownToggle': 'onKeydownMenu',
      'click': '_onClickInlineMenu'
    },

    constructor: function InlineMenuView(options) {
      options || (options = {});
      this.tileViewToolbarItems = options.tileViewToolbarItems || {};
      this.inlineActionbar = this.tileViewToolbarItems.inlineActionbar;
      this.inlineActionbarOptions = (this.inlineActionbar && this.inlineActionbar.options) || {};
      Marionette.ItemView.call(this, options);
    },

    onBeforeDestroy: function () {
      this._destroyInlineMenu();
    },

    _onClickInlineMenu: function (event) {
      event.stopPropagation();
      event.preventDefault();
    },

    onClickMenuButton: function (event) {
      event.preventDefault();
      event.stopPropagation();

      var lazyActionsAreRetrieved = !!this.model.get('csuiLazyActionsRetrieved'),
          nonPromotedCommands = this.model.nonPromotedActionCommands;
      if (!lazyActionsAreRetrieved && nonPromotedCommands && nonPromotedCommands.length) {
        var self = this;
        this._toggleLoadingIcon(true);
        this.ui.loadingContainer.trigger('focus');
        this.model.setEnabledLazyActionCommands(true)
            .done(function () {
              // As per UX req: need to show loading dots at least for 300ms after fetch as like in
              // inline actionbar.
              setTimeout(function () {
                self._showInlineMenu(event);
              }, 300);
            })
            .fail(function (err) {
              self._toggleLoadingIcon(false);
              var error = new base.Error(err);
              GlobalMessage.showMessage('error', error.message);
            });
      } else {
        this._showInlineMenu(event);
      }
    },

    onKeydownMenu: function (event) {
      switch (event.which) {
      case 13: // Enter
      case 32: // Space
      case 40: // KeyDown
        this.onClickMenuButton(event);
        return false;
      }
    },

    acquireFocus: function () {
      // Set Focus based on toolbar actions initialization
      this.$el.find("*[tabindex]:visible").first().trigger("focus");
    },

    _toggleLoadingIcon: function (showLoading) {
      this.$el.attr("aria-busy", !!showLoading);
      if (showLoading) {
        this.ui.moreToggle.addClass('binf-hidden');
        this.ui.loadingContainer.removeClass('binf-hidden');
      } else {
        this.ui.moreToggle.removeClass('binf-hidden');
        this.ui.loadingContainer.addClass('binf-hidden');
      }
    },

    _toggleMenuButton: function () {
      this.ui.moreToggle.addClass('binf-hidden');
      this.ui.loadingContainer.addClass('binf-hidden');
      this.ui.toolbarContainer.removeClass('binf-hidden');
    },

    _focusFirstItem: function (event) {
      if (event.type == "keydown") {
        this.$el.find('.binf-dropdown-menu li:first a').trigger("focus");
      }
    },

    closeDropdownMenuIfOpen: function () {
      if (this.inlineMenuBarView && this.inlineMenuBarView.closeDropdownMenuIfOpen()) {
        this._removeContainerShowingInlineMenuClass();
      }
    },

    _addContainerShowingInlineMenuClass: function () {
      this.$el.closest('.tile-content').addClass('showing-inline-menu');
      // Edge browser: disable title attribute due to mouse hover causing mouseleave event and closing the menu
      if (base.isEdge()) {
        this.inlineMenuBarView.$el.find('li.binf-dropdown a').each(function () {
          var title = $(this).attr('title');
          title && $(this).data('title', title).removeAttr('title');
        });
      }
    },

    _removeContainerShowingInlineMenuClass: function () {
      this.$el.closest('.tile-content').removeClass('showing-inline-menu');
      // Edge browser: enable title attribute
      if (base.isEdge()) {
        this.inlineMenuBarView.$el.find('li.binf-dropdown a').each(function () {
          $(this).attr('title', $(this).data('title'));
        });
      }
    },

    _showInlineMenu: function (event) {
      if (this.isDestroyed) {
        // Possible focus / mouse moved outof row, hence inline actions destroyed.
        return;
      }

      if (!!this.inlineMenuBarView) {
        this._addContainerShowingInlineMenuClass();
        this.inlineMenuBarView.toggleDropdownMenu();
        this._focusFirstItem(event);
        return;
      }

      var requiredModules = [
        'csui/controls/tableactionbar/tableactionbar.view'
      ];
      require(requiredModules, _.bind(function (TableActionBarView) {
        this.inlineMenuBarView = new TableActionBarView(_.extend({
          context: this.options.context,
          originatingView: this.options.originatingView,
          commands: this.options.commands,
          model: this.model,
          collection: this.inlineActionbar,
          containerCollection: this.model.collection,
          status: {originatingView: this.options.originatingView}
        }, this.inlineActionbarOptions));
        this._toggleMenuButton();
        var inlineBarElem = this.$el.find('.csui-menu-btn-region'),
            inlineBarRegion = new Marionette.Region({el: inlineBarElem});
        inlineBarRegion.show(this.inlineMenuBarView);
        this.listenTo(this.inlineMenuBarView, 'before:execute:command', function (args) {
          this.trigger('before:execute:command', args);
        });
        this.listenTo(this.inlineMenuBarView, 'after:execute:command', function (args) {
          this.trigger('after:execute:command', args);
        });
        this.listenTo(this.inlineMenuBarView, 'destroy', function (args) {
          $(document).off('scroll.inline.menu');
          this._removeContainerShowingInlineMenuClass();
        });

        var dropdown = this.inlineMenuBarView.$el.find('li.binf-dropdown');
        //close dropdown on window resize
        $(window).on('resize', this.closeDropdownMenuIfOpen.bind(this));
        dropdown.on('show.binf.dropdown', _.bind(function () {
          this._addContainerShowingInlineMenuClass();
        }, this));
        dropdown.on('hide.binf.dropdown', _.bind(function () {
          this._removeContainerShowingInlineMenuClass();
        }, this));
        $(document).on('scroll.inline.menu', this.closeDropdownMenuIfOpen.bind(this));
        this._addContainerShowingInlineMenuClass();
        this.inlineMenuBarView.toggleDropdownMenu(true);
        this._focusFirstItem(event);
      }, this));
    },

    _destroyInlineMenu: function () {
      this.inlineMenuBarView && this.inlineMenuBarView.destroy();
    }
  });

  return InlineMenuView;
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/listitem/impl/listitemstandard',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "<a class=\"csui-tileview-contains-more-btn\" tabindex=\"-1\"> ";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"csui-type-icon "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":2,"column":45},"end":{"line":2,"column":53}}}) : helper)))
    + "\"></div>";
},"5":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"end-icon-class") || (depth0 != null ? lookupProperty(depth0,"end-icon-class") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"end-icon-class","hash":{},"loc":{"start":{"line":4,"column":28},"end":{"line":4,"column":46}}}) : helper)))
    + "\"></div>";
},"7":function(container,depth0,helpers,partials,data) {
    return "<div class=\"csui-tileview-more-btn\"></div>";
},"9":function(container,depth0,helpers,partials,data) {
    return "</a>";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"showInlineActionBar") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":1,"column":0},"end":{"line":1,"column":92}}})) != null ? stack1 : "")
    + "\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableIcon") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":2,"column":0},"end":{"line":2,"column":68}}})) != null ? stack1 : "")
    + "\r\n<div title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":3,"column":12},"end":{"line":3,"column":20}}}) : helper)))
    + "\" class=\"list-item-title\" role=\"link\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"itemLabel") || (depth0 != null ? lookupProperty(depth0,"itemLabel") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"itemLabel","hash":{},"loc":{"start":{"line":3,"column":70},"end":{"line":3,"column":83}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":3,"column":85},"end":{"line":3,"column":93}}}) : helper)))
    + "</div>\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"end-icon") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"loc":{"start":{"line":4,"column":0},"end":{"line":4,"column":61}}})) != null ? stack1 : "")
    + "\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"showInlineActionBar") : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":76}}})) != null ? stack1 : "")
    + "\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"showInlineActionBar") : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":38}}})) != null ? stack1 : "")
    + "\r\n";
}});
Handlebars.registerPartial('csui_controls_listitem_impl_listitemstandard', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/listitem/impl/listitemstandard',[],function(){});
// Shows a list of links
csui.define('csui/controls/listitem/listitemstandard.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette','csui/utils/base',
  'csui/behaviors/default.action/default.action.behavior',
  'csui/controls/list/behaviors/list.item.keyboard.behavior',
  'csui/utils/node.links/node.links',
  'csui/controls/listitem/impl/inline.menu/inline.menu.view',
  'csui/utils/accessibility',
  'hbs!csui/controls/listitem/impl/listitemstandard',
  'css!csui/controls/listitem/impl/listitemstandard'
], function (_, $, Marionette, base, DefaultActionBehavior, ListItemKeyboardBehavior, nodeLinks,
    InlineMenuView, Accessibility,
    itemTemplate) {
  'use strict';

  var accessibleTable = Accessibility.isAccessibleTable();

  var StandardListItem = Marionette.ItemView.extend({

    tagName: function () {
      return this.showInlineActionBar ? 'div' : 'a';
    },
    className: 'csui-item-standard binf-list-group-item',

    behaviors: {
      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      },
      ListItemKeyboardBehavior: {
        behaviorClass: ListItemKeyboardBehavior
      }
    },

    template: itemTemplate,
    templateHelpers: function () {
      return _.reduce(this.options, function (result, name, key) {
        if (typeof name === 'string') {
          var value = this._getValue(name);
          if (key === 'icon') {
            value = 'csui-icon ' + value;
            result.enableIcon = true;
          }
          result[key] = value;
        }
        return result;
      }, {}, this);
    },

    constructor: function StandardListItem(options) {
      options || (options = {});
      if (!!options.toolbarData) {
        this._setInlineActions(options);
      }
      this.context = options.context;
      Marionette.ItemView.call(this, options);
      this.listenTo(this, 'doc:preview:generic:actions', this._highlightRow);
      this.$el.on("click",_.bind(function(event){
        if (base.isControlClick(event)) {
          // do nothing, let's execute browser's default behaviour as it is in both ctrl+click and
          // command+click in mac.
        } else {
          event.preventDefault();
          event.stopPropagation();
          this.triggerMethod("click:item");
        }
      },this));
    },

    _highlightRow: function (targetNode, HIGHLIGHT_CLASS_NAME) {
      $('.' + HIGHLIGHT_CLASS_NAME).removeClass(HIGHLIGHT_CLASS_NAME);
      this.$el.addClass(HIGHLIGHT_CLASS_NAME);
    },

    _setInlineActions: function (options) {
      this.showInlineActionBar = true;
      this.tileViewToolbarItems = options.toolbarData.toolbaritems;
      this.ui = {
        titleName: '.list-item-title',
        icon: '.csui-icon-group'
      };
      if (!accessibleTable) {
        this.events = {
          'mouseenter': 'onShowInlineMenu',
          'mouseleave': 'onHideInlineMenu',
          'wheel': 'onWheelEvent'
        };
      }

    },

    // To prevent metadata from getting close on recreating the list item (on search refilter etc.)
    cascadeDestroy: function () {
      return false;
    },

    setElementData: function () {
      var elementData;
      if (this.showInlineActionBar) {
        elementData = this.$el.find("a");
      } else {
        elementData = this.$el;
        elementData.prop('tabindex', '-1');
      }
      return elementData;
    },

    onRender: function () {
      var id = this.model && this.model.get('id');
      this.eleData = this.setElementData();
      if (id != null) {
        this.eleData.attr('href', nodeLinks.getUrl(this.model));
      }
      if(this.options.refetchNodeActions && this.model) {
        this.model.refetchNodeActions = true;
      }
      if (this.model && this.options && this.options.checkDefaultAction) {
        var disabled = this.model.fetched === false ||
                       !this.defaultActionController.hasAction(this.model);
        this.$el[disabled ? 'addClass' : 'removeClass']('inactive');
      }
      // console.log("removing a role: " + this.$el.attr('role'));
      this.$el.removeAttr('role'); // these roles on the <a are not valid html
      if(base.isHybrid()){
        this.onShowInlineMenu();
      }
    },

    _getValue: function (name) {
      if (name.indexOf('{') === 0) {
        var names = name.substring(1, name.length - 1).split('.'),
            value = this.model.attributes;
        _.find(names, function (name) {
          value = value[name];
          if (value === undefined) {
            return true;
          }
        });
        return value;
      }
      return name;
    },

    onShowInlineMenu: function (event) {
      var inlineBarElem = this.$el.find('.csui-tileview-more-btn');
      if(base.isHybrid() && (event || !inlineBarElem.length)){
        return;
      }
      event && event.preventDefault();
      event && event.stopPropagation();
      this.$el.addClass('csui-tile-with-more-btn');
      // Create inline menu view
      this._inlineMenuView = new InlineMenuView({
        context: this.options.context,
        originatingView: this,
        commands: this.defaultActionController.commands,
        model: this.model,
        tileViewToolbarItems: this.tileViewToolbarItems
      });

      var inlineBarRegion = new Marionette.Region({el: inlineBarElem});
      inlineBarRegion.show(this._inlineMenuView);
      this.listenTo(this._inlineMenuView, 'before:execute:command', function(args){
        this.trigger('before:execute:command', args);
      });
      this.listenTo(this._inlineMenuView, 'after:execute:command', function(){
        if(!base.isHybrid()){
          this.onHideInlineMenu();
        }
      });
    },

    onHideInlineMenu: function (event) {
      if (event && base.isHybrid()) {
        this._inlineMenuView && this._inlineMenuView.inlineMenuBarView &&
          this._inlineMenuView.inlineMenuBarView.closeDropdownMenuIfOpen();
        return;
      }
      this.$el.removeClass('csui-tile-with-more-btn');
      if (this._inlineMenuView) {
        this._inlineMenuView.destroy();
        this._inlineMenuView = undefined;
        return true;
      }
    },

    onWheelEvent: function (event) {
      this._inlineMenuView && this._inlineMenuView.closeDropdownMenuIfOpen();
    }

  });

  return StandardListItem;
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/list/impl/simplelist',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <div class=\"cs-header binf-panel-heading cs-header-with-go-back\" tabindex=\"0\" role=\"link\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"goBackAria") || (depth0 != null ? lookupProperty(depth0,"goBackAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"goBackAria","hash":{},"loc":{"start":{"line":2,"column":104},"end":{"line":2,"column":118}}}) : helper)))
    + "\">\r\n    <span class=\"icon circular arrow_back cs-go-back\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"goBackTooltip") || (depth0 != null ? lookupProperty(depth0,"goBackTooltip") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"goBackTooltip","hash":{},"loc":{"start":{"line":3,"column":61},"end":{"line":3,"column":78}}}) : helper)))
    + "\"></span>\r\n    <span class=\"cs-title cs-title-with-go-back\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":4,"column":56},"end":{"line":4,"column":65}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":4,"column":67},"end":{"line":4,"column":76}}}) : helper)))
    + "</span>\r\n  </div>\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"title") : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"loc":{"start":{"line":6,"column":0},"end":{"line":10,"column":0}}})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <div class=\"cs-header binf-panel-heading\" tabindex=\"0\">\r\n    <span class=\"cs-title\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":8,"column":34},"end":{"line":8,"column":43}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":8,"column":45},"end":{"line":8,"column":54}}}) : helper)))
    + "</span>\r\n  </div>\r\n";
},"6":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return " role=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"listRole") || (depth0 != null ? lookupProperty(depth0,"listRole") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"listRole","hash":{},"loc":{"start":{"line":13,"column":51},"end":{"line":13,"column":63}}}) : helper)))
    + "\"";
},"8":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return " aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"listAria") || (depth0 != null ? lookupProperty(depth0,"listAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"listAria","hash":{},"loc":{"start":{"line":13,"column":100},"end":{"line":13,"column":112}}}) : helper)))
    + "\"";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"back_button") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"loc":{"start":{"line":1,"column":0},"end":{"line":10,"column":7}}})) != null ? stack1 : "")
    + "\r\n<div class=\"cs-content csui-normal-scrolling\">\r\n  <div class=\"cs-list-group\""
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"listRole") : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"loc":{"start":{"line":13,"column":28},"end":{"line":13,"column":71}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"listAria") : depth0),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"loc":{"start":{"line":13,"column":71},"end":{"line":13,"column":120}}})) != null ? stack1 : "")
    + "></div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_list_impl_simplelist', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/list/impl/simplelistitem',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"nameTitleAria") || (depth0 != null ? lookupProperty(depth0,"nameTitleAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"nameTitleAria","hash":{},"loc":{"start":{"line":1,"column":84},"end":{"line":1,"column":101}}}) : helper)))
    + "\"";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<span class=\"csui-type-icon "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":2,"column":46},"end":{"line":2,"column":54}}}) : helper)))
    + "\"></span>";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"binf-list-group-item\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":1,"column":41},"end":{"line":1,"column":49}}}) : helper)))
    + "\" "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"nameTitleAria") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":1,"column":51},"end":{"line":1,"column":109}}})) != null ? stack1 : "")
    + ">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableIcon") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":2,"column":0},"end":{"line":2,"column":70}}})) != null ? stack1 : "")
    + "\r\n<div title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":3,"column":12},"end":{"line":3,"column":20}}}) : helper)))
    + "\" class=\"list-item-title\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":3,"column":46},"end":{"line":3,"column":54}}}) : helper)))
    + "</div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_list_impl_simplelistitem', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/list/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/list/impl/nls/root/lang',{
  goBackTooltip: 'Go back',
  goBackAria: 'Go back to {0}',
  goBackTitleForEmptyTitle: 'Back',
  emptyViewDefaultText: 'No items.',
  clearAll: 'Clear',
  clearAllAria: 'Clear search',
  expandView: 'Expand',
  expandAria: 'Expand {0} widget',
  searchView: 'Search',
  searchAria: 'Search {0} widget',
  collapseSearch: 'Close search',
  collapseAria: 'Clear all and close search',
  elementsVisibleAria: '{0} Elements are visible in {1}',
  nameTitleAria: '{0} of type {1}',
  openPerspective: 'Open Perspective',
  openPerspectiveTooltip: 'Open Perspective'
});



csui.define('css!csui/controls/list/impl/simplelist',[],function(){});
// Shows a simply list of items with scrollbar
csui.define('csui/controls/list/simplelist.view',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/lib/marionette', 'csui/utils/base',
  'csui/controls/listitem/listitemstandard.view',
  'csui/utils/node.links/node.links',
  'hbs!csui/controls/list/impl/simplelist',
  'hbs!csui/controls/list/impl/simplelistitem',
  'csui/utils/nodesprites',
  'i18n!csui/controls/list/impl/nls/lang',
  'css!csui/controls/list/impl/simplelist'
], function (_, $, Backbone, Marionette, base, ListItemStandardView,
    nodeLinks, listTemplate, listItemTemplate, nodeSpriteCollection, lang) {
  'use strict';

  var SimpleListItemView = Marionette.ItemView.extend({
    constructor: function SimpleListItemView() {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    tagName: 'a',

    template: listItemTemplate,

    events: {
      'click': 'onClickItem'
    },

    // a configured icon will only be displayed, if data.enableIcon is set to true
    serializeData: function () {
      var data = Marionette.ItemView.prototype.serializeData.apply(this, arguments);
      if (data) {
        var icon = data.icon;
        if (icon) {
          data.icon = 'csui-icon ' + icon;
        }
      }
      return data;
    },

    onRender: function () {
      var id = this.model && this.model.get('id');
      if (id != null) {
        this.$el.attr('href', nodeLinks.getUrl(this.model));
      }
      var exactNodeSprite = nodeSpriteCollection.findByNode(this.model) || {},
          mimeTypeFromNodeSprite;
      if (exactNodeSprite.attributes) {
        mimeTypeFromNodeSprite = exactNodeSprite.get('mimeType');
      }
      var title = mimeTypeFromNodeSprite || this.model.get("type_name") || this.model.get("type");
      if (this.model.get("name") && title) {
        var nameTitleAria = _.str.sformat(lang.nameTitleAria, this.model.get("name"), title);
        this.$el.attr("aria-label", nameTitleAria);
      }
      this.$el.attr('role', this.options.childRole);
    },

    onClickItem: function (event) {
      if (base.isControlClick(event)) {
        // do nothing, let's execute browser's default behaviour as it is in both ctrl+click and
        // command+click in mac.
      } else {
        event.preventDefault();
        event.stopPropagation();
        this.trigger("click:item");
      }
    },

    modelEvents: {
      'change': 'render'
    },
  });

  var SimpleListView = Marionette.CompositeView.extend({

    constructor: function SimpleListView(options) {
      options || (options = {});
      options.data || (options.data = {});

      Marionette.CompositeView.call(this, options);

      // TODO: Deprecate this, or fix it, so that a collection can be created
      // without breaking the client
      // Passing a collection without knowing its model schema and identifier
      // is not possible in Backbone, where the collections should be indexed
      if (this.options.data && this.options.data.items) {
        if (!this.collection) {
          var ViewCollection = Backbone.Collection.extend({
            model: Backbone.Model.extend({
              idAttribute: null
            })
          });
          this.collection = new ViewCollection();
        }
        this.collection.add(this.options.data.items);
      }
    },

    ui: {
      header: '.cs-header',
      headerGoBack: '.cs-header-with-go-back',
      back: '.cs-go-back',
      backTitle: '.cs-title-with-go-back'
    },

    events: {
      'click @ui.back': 'onClickBack',
      'click @ui.backTitle': 'onClickBack',
      'click @ui.headerGoBack': 'onClickBack'
    },

    childEvents: {
      'click:item': 'onClickItem',
      'render': '_onChildRender'
    },

    className: 'cs-simplelist binf-panel binf-panel-default',
    template: listTemplate,

    templateHelpers: function () {
      var backButton = this.options.data.back_button;
      var title = this.options.data.title;
      if (backButton && (title === undefined || title.length === 0)) {
        title = lang.goBackTitleForEmptyTitle;
      }
      return {
        back_button: backButton,
        goBackTooltip: lang.goBackTooltip,
        goBackAria: _.str.sformat(lang.goBackAria, title),
        title: title,
        listAria: this.options.data.listAria,
        listRole: this.options.data.listRole
      };
    },

    childViewContainer: '.cs-list-group',

    childView: SimpleListItemView,

    childViewOptions: function () {
      return {
        template: this.options.childViewTemplate,
        childRole: this.options.data.childRole
      };
    },

    _onChildRender: function (childView) {
      var $item = childView.$el;
      if ($item.is('[data-csui-active]')) {
        $item.addClass('binf-active').attr('aria-current', 'page');
      }
    },

    onDomRefresh: function () {
      var selectedItem = this.getSelectedItem();
      if (!!selectedItem && !this._isScrolledIntoView(selectedItem.$el)) {
        this.setSelectedIndex(this.getSelectedIndex());
      }
    },

    /**
     * Get the selected item's view
     * @returns {Marionette.ItemView}
     */
    getSelectedItem: function () {
      var selectedIndex = this.getSelectedIndex();
      var selectedItem = this.children.findByIndex(selectedIndex);
      return selectedItem;
    },

    /**
     * Get the index of the selected item
     * @returns {Number}
     */
    getSelectedIndex: function () {
      var $selectedItem = this.$el.find('[data-csui-active]');
      var selectedIndex = this.$el.find('.cs-list-group>a').index($selectedItem);
      return selectedIndex;
    },

    /**
     * Set the item with the given index selected
     * @param index
     */
    setSelectedIndex: function (index) {
      if (isNaN(index) || (index < 0)) {
        return;
      }
      var nthChildSel = _.str.sformat('div a:nth-child({0})', index + 1); // index is zero-based
      var $item = this.$(nthChildSel);
      this._setCssItemSelected($item);
      $item.first().trigger('focus');

      //console.log( 'inview', this._isScrolledIntoView($item));
      var $contentView = this.$('.cs-content');
      if (!this._isScrolledIntoView($item)) {

        var itemPosTop = $item.position().top;
        var deltaScroll = (itemPosTop > 0) ?
                          ($item.height() - $contentView.height()) + itemPosTop : itemPosTop;

        $contentView.animate({
          scrollTop: $contentView.scrollTop() + deltaScroll
        }, 500);
      }
    },

    setSelectedElement: function (element) {
      var index = this.getItemIndex(element);
      if (index !== -1) {
        this.setSelectedIndex(index);
      }
    },

    getItemIndex: function (element) {
      var index = -1;
      this.children.some(function (view, viewIndex) {
        if (view === element) {
          index = viewIndex;
          return true;
        }
      });
      return index;
    },

    selectedIndexElem: function (index) {
      if (isNaN(index) || (index < 0)) {
        return null;
      }
      var nthChildSel = _.str.sformat('div a:nth-child({0})', index + 1); // index is zero-based
      var $item = this.$(nthChildSel);
      return $($item[0]);
    },

    selectNext: function () {
      var nSelected = this.getSelectedIndex();
      var nNext = Math.min(nSelected + 1, this.collection.models.length);
      this.setSelectedIndex(nNext);
    },

    selectPrevious: function () {
      var nSelected = this.getSelectedIndex();
      var nNext = Math.max(nSelected - 1, 0);
      this.setSelectedIndex(nNext);
    },

    onClickItem: function (src) {
      src.cancelClick = false;
      this.trigger('click:item', src);
      if (src.cancelClick === false) {
        this._setCssItemSelected(src.$el);
      }
    },

    onClickBack: function (event) {
      event.preventDefault();
      event.stopPropagation();

      this.clickBack();
    },

    clickBack: function () {
      this.trigger('click:back');
    },

    _setCssItemSelected: function ($item) {
      if (!($item instanceof $)) {
        return;
      }
      // unmark old
      var $active = $item.siblings('[data-csui-active]');
      $active.removeClass('binf-active').removeAttr('data-csui-active').removeAttr('aria-current');
      $item.addClass('binf-active').attr('data-csui-active', '').attr('aria-current', 'page');

      // for keyboard navigation, set tabindex=-1
      $item.siblings().prop('tabindex', '-1');
    },

    _isScrolledIntoView: function ($item) {
      var $contentWindow = this.$('.cs-content');
      var elemTop = $item.position().top;
      var elemBottom = elemTop + $item.height();
      return ((elemTop >= 0) && (elemBottom <= $contentWindow.height()));
    }
  });

  return SimpleListView;
});

csui.define('csui/models/node.facets2/facet.query.mixin',[
  'csui/lib/underscore', 'csui/lib/jquery'
], function (_, $) {
  'use strict';

  var FacetQueryMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makeFacetQuery: function (options) {
          return this;
        },

        getFilterQuery: function (filters) {
          return getFilterQuery(filters || this.filters,
              this.filterQueryParameterName);
        },

        getFilterQueryValue: function (filters) {
          return getFilterQueryValue(filters || this.filters);
        },

        getFacetIdQuery: function (facetIds) {
          return getFacetIdQuery(facetIds || this.facetIds,
              this.facetIdQueryParameterName);
        }
      });
    }
  };

  function getFilterQuery(filters, parameterName) {
    var value = getFilterQueryValue(filters);
    if (value.length) {
      var parameters = {};
      parameters[parameterName] = value;
      return $.param(parameters, true);
    }
    return '';
  }

  function getFilterQueryValue(filters) {
    return filters && _.map(filters, getFilterValue) || [];
  }

  function getFilterValue(filter) {
    return filter.id + ':' +
           _.reduce(filter.values, function (result, value) {
             if (result) {
               result += '|';
             }
             return result + value.id.toString();
           }, '');
  }

  function getFacetIdQuery(facetIds, parameterName) {
    if (facetIds.length) {
      var parameters = {};
      parameters[parameterName] = facetIds;
      return $.param(parameters, true);
    }
    return '';
  }

  return FacetQueryMixin;
});

csui.define('csui/models/node.facets2/server.adaptor.mixin',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/utils/url',
  'csui/models/node.facets2/facet.query.mixin'
], function (_, $, Url, FacetQueryMixin) {
  'use strict';

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      var originalFetch = prototype.fetch;

      FacetQueryMixin.mixin(prototype);

      return _.extend(prototype, {
        filterQueryParameterName: 'where_facet',
        facetIdQueryParameterName: 'facet_id',

        makeServerAdaptor: function (options) {
          return this.makeFacetQuery(options);
        },

        isFetchable: function () {
          var node       = this.node,
              type       = node.get('type'),
              locationId = node.get('location_id');
          //Location id === 0 means the VF is empty, and in the eyes of CS invalid, so
          //no need to burden server with a request that will only return an error result.
          if (type === 899 && locationId === 0) {
            return false;
          }
          return true;
        },

        url: function () {
          var nodeId  = this.node.get(this.node.get('type') === 899 ? 'location_id' : 'id'),
              filters = _.union(getNodeFilters(this.node), this.filters),
              filter  = this.getFilterQuery(filters),
              facetId = this.getFacetIdQuery(),
              apiBase = new Url(this.connector.connection.url).getApiBase('v2'),
              url     = Url.combine(apiBase, '/facets/', nodeId);
          this.itemsToShow && (url = Url.appendQuery(url, 'top_values_limit=' + this.itemsToShow));
          filter && (url = Url.appendQuery(url, filter));
          facetId && (url = Url.appendQuery(url, facetId));
          return url;
        },

        parse: function (response, options) {
          var topics    = response.results.data || {},
              facets    = topics.facets || {},
              selected  = topics.values.selected || [],
              available = topics.values.available || [];
          selected.forEach(markSelectedTopics.bind(null, true));
          available.forEach(markSelectedTopics.bind(null, false));
          if (this.node.get('type') === 899) {
            var nodeFacets = this.node.get('selected_facets') || [];
            nodeFacets = nodeFacets.map(function (facet) {
              return facet[0];
            });
            selected = selected.filter(function (facet) {
              var id = _.keys(facet)[0];
              return !_.contains(nodeFacets, id);
            });
          }
          return selected
              .concat(available)
              .map(mergeFacetTopics.bind(this, facets));
        }
      });
    }
  };

  function markSelectedTopics(selected, facet) {
    // topics are nested by the facet id as the key property
    var id     = _.keys(facet)[0],
        topics = facet[id];
    _.each(topics, function (topic) {
      // Convert the ID always to string to be able to use Backbone
      // searching methods like where(), which compare by ===.
      topic.value = topic.value.toString();
      topic.selected = selected;
    });
  }

  function mergeFacetTopics(facets, facet) {
    // topics are nested by the facet id as the single key property
    var id         = _.keys(facet)[0],
        topics     = facet[id],
        properties = facets[id] || {};
    // merge topics with the facet information
    return _.extend({
      nodeFacetsCollection: this,
      items_to_show: this.itemsToShow,
      select_multiple: true,
      topics: topics
    }, properties, {
      // Convert the ID always to string to be able to use Backbone
      // searching methods like where(), which compare by ===.
      id: id.toString()
    });
  }

  function getNodeFilters(node) {
    var selectedFacets = [];
    if (node.get('type') === 899) {
      //selected_facets format = [['61033', [140]], ['61032', ['1000', '64039']]];
      var virtualFacets = node.get('selected_facets');
      selectedFacets = _.map(virtualFacets, function (item) {
        var facetGroup = {'id': item[0], 'values': []};
        item[1].forEach(function (id) {
          facetGroup.values.push({'id': id});
        });
        return facetGroup;
      });
    }
    return selectedFacets;
  }

  return ServerAdaptorMixin;
});

csui.define('csui/models/nodefacets2',[
  'csui/lib/underscore', 'csui/models/facets',
  'csui/models/mixins/node.resource/node.resource.mixin',
  'csui/models/node.facets2/server.adaptor.mixin',
  'csui/utils/deepClone/deepClone'
], function (_, FacetCollection, NodeResourceMixin, ServerAdaptorMixin) {
  'use strict';

  var NodeFacet2Collection = FacetCollection.extend({
    constructor: function NodeFacet2Collection(models, options) {
      FacetCollection.prototype.constructor.apply(this, arguments);
      this.makeNodeResource(options)
          .makeServerAdaptor(options);
    },

    isFetchable: function () {
      return this.areFacetsFetchable(this);
    },

    clone: function () {
      return new this.constructor(this.models, {
        node: this.node,
        itemsToShow: this.itemsToShow,
        facetIds: this.facetIds,
        filters: _.deepClone(this.filters)
      });
    }
  });

  NodeResourceMixin.mixin(NodeFacet2Collection.prototype);
  ServerAdaptorMixin.mixin(NodeFacet2Collection.prototype);

  return NodeFacet2Collection;
});

csui.define('csui/controls/facet.panel/impl/facet/facet.key.navigation',['csui/lib/underscore', 'csui/lib/jquery'
], function (_, $) {
  'use strict';

  var KeyEventNavigation = {

    onKeyInView: function (event) {
      var keyCode = event.keyCode;
      var retVal = false;

      switch (keyCode) {
        //escape
      case 27:
        this.trigger('escape:focus');
        if (this.activeChild) {
          this.activeChild.removeClass('csui-focus');
        }
        break;
        //Enter and space
      case 32:
      case 13:
        this.execute(this.activeChild);
        break;
        //up arrow, page up
        //down arrow, page down
      case 38:
      case 33:
      case 40:
      case 34:
        //ignore up/down arrow keys for sub-facet. Up/down arrow keys is only relevant
        //on the facet panel or with in the individual filter lists.
        if (this.activeChild && this.activeChild.hasClass('csui-focus')) {
          break;
        }
        retVal = true;
        break;
        //tab/shift-tab
      case 9:
        retVal = this.tab(event.shiftKey);
        break;
      default:
        retVal = true;
      }
      return retVal;
    },

    execute: function (activeChild) {
      //If this facet is disabled for selection, then on execution expand or collapse
      //the facet group
      this.$el.addClass('csui-focus');
      if (this.$el.find('.facet-disabled').length) {
        this.onShowFacet();
      }
      else {
        this.setfocus(activeChild);
      }
    },
    setfocus: function (activeChild) {
      (activeChild && activeChild.is(':visible')) || (activeChild = this.getActiveChild());

      if (activeChild.hasClass('csui-focus')) {

        switch (activeChild) {
        case this.ui.facetHeaderIcon:
          if (this.ui.facetHeader.hasClass('binf-disabled')) {
            break;
          }
          activeChild.trigger('click');
          if (this.ui.facetHeaderIcon.hasClass('icon-expandArrowDown')) {
            this.trigger('escape:focus');
            this.activeChild = this.getActiveChild();
          } else {
            activeChild.addClass('csui-focus');
          }
          break;

        case this.ui.apply:
        case this.ui.cancel:
          activeChild.trigger('click');
          this.trigger('escape:focus');
          this.activeChild = undefined;
          break;

        case this.ui.facetMore:
          //reset focus to "show more/less" so that
          //scrolled focus is still on the "show more/less" after the
          //default action
          activeChild.trigger('click');
          if (activeChild === this.ui.facetMore) {
            this.activateChild(activeChild);
          }
        }
      }
      else {
        this.activateChild(activeChild);
      }
    },

    tab: function (shiftTab) {
      var facets = this.$el.find('.csui-facet-item:not(.binf-hidden)');

      if (this.activeChild && this.activeChild.hasClass('csui-focus')) {
        if (shiftTab) {
          this.activeChild = this._getPrevActiveChild(facets);
        }
        else {
          this.activeChild = this._getNextActiveChild(facets);
        }

        this.activateChild(this.activeChild);
        return false;
      }

      return true;
    },

    activateChild: function (activeChild) {
      activeChild || (activeChild = this.getActiveChild());
      if (this.prevChild) {
        this.prevChild.removeClass('csui-focus');
      }
      activeChild.addClass('csui-focus');
      activeChild.trigger('focus');
      this.prevChild = this.activeChild;
    },

    getActiveChild: function () {
      var childViewContainers = this.$el.find('.csui-facet-item:not(.binf-hidden)');
      if (!this.activeChild || !this.activeChild.is(':visible')) {
        if (this.ui.facetHeaderIcon.hasClass('icon-expandArrowDown')) {
          this.activeChild = this.ui.facetHeaderIcon;
        }
        else {
          var activeChildContainer = childViewContainers[0];
          this.activeChild = $(activeChildContainer).find('.csui-checkbox');
          if (this.activeChild.length === 0) {
            this.activeChild = $(activeChildContainer).find('div[tabindex]');
          }
          this.activeChildIndex = 0;
        }
      }
      return this.activeChild;
    },

    cursorNextFilter: function (view, keyUp, target) {
      var childViewContainers = this.$el.find('.csui-facet-item:not(.binf-hidden)'),
          numViews            = childViewContainers.length - 1;

      if (keyUp) {
        this.activeChildIndex = this.activeChildIndex === 0 ? numViews : --this.activeChildIndex;
      }
      else {
        this.activeChildIndex = this.activeChildIndex === numViews ? 0 : ++this.activeChildIndex;
      }

      this.activeChild = $(childViewContainers[this.activeChildIndex]).find('.csui-checkbox');

      //checkbox is not available in search filters
      if (!this.activeChild.length) {
        this.activeChild = $(childViewContainers[this.activeChildIndex]).find('.csui-filter-name');
      }

      this.children.findByIndex(this.activeChildIndex).activeChild = this.activeChild;
      this.activateChild(this.activeChild);
    },

    _getLastFilterFocus: function (facets) {
      var childIndex = this.activeChildIndex;
      this.activeChildIndex = childIndex && childIndex < facets.length ? childIndex : 0;
      return this.children.findByIndex(this.activeChildIndex).activeChild;
    },

    _getNextActiveChild: function (facets) {
      var nextChild = this.activeChild;

      var multiSelects = this.$el.find('.csui-multi-select');
      switch (this.activeChild) {
      case this.ui.facetHeaderIcon:
        if (this.ui.facetHeaderIcon.hasClass('icon-expandArrowUp')) {
          nextChild = this._getLastFilterFocus(facets);
        }
        break;
      case this.ui.facetMore:
        if (multiSelects.length > 0) {
          nextChild = this.ui.apply;
        } else if (multiSelects.length === 0 &&
                   this.ui.facetHeaderIcon.hasClass('icon-expandArrowUp')) {
          nextChild = this.ui.facetHeaderIcon;
        }
        break;
      case this.ui.cancel:
        if (multiSelects.length > 0 &&
            !this.ui.facetHeader.hasClass('binf-disabled') &&
            this.ui.facetHeaderIcon.hasClass('icon-expandArrowUp')) {
          nextChild = this.ui.facetHeaderIcon;
        } else if (this.ui.facetHeader.hasClass('binf-disabled')) {
          nextChild = this._getLastFilterFocus(facets);
        }
        break;
      case this.ui.apply:
        nextChild = this.ui.cancel;
        break;
      default:
        if (this.ui.facetMore.length > 0) {
          nextChild = this.ui.facetMore;
        } else if (multiSelects.length > 0) {
          nextChild = this.ui.apply;
        } else if (multiSelects.length === 0 &&
                   this.ui.facetMore.length === 0) {
          nextChild = this.ui.facetHeaderIcon;
        }
      }

      return nextChild;
    },

    _getPrevActiveChild: function (facets) {
      var nextChild = this.activeChild;

      switch (this.activeChild) {
      case this.ui.facetHeaderIcon:
        if (this.$el.find('.csui-multi-select').length > 0) {
          nextChild = this.ui.cancel;
        } else if (this.$el.find('.csui-multi-select').length === 0 &&
                   this.ui.facetMore.length === 0) {
          nextChild = this._getLastFilterFocus(facets);
        } else if (this.$el.find('.csui-multi-select').length === 0 &&
                   this.ui.facetMore.length > 0) {
          nextChild = this.ui.facetMore;
        }
        break;
      case this.ui.facetMore:
        nextChild = this._getLastFilterFocus(facets);
        break;
      case this.ui.cancel:
        nextChild = this.ui.apply;
        break;
      case this.ui.apply:
        if (this.ui.facetMore.length > 0) {
          nextChild = this.ui.facetMore;
        }
        else {
          nextChild = this._getLastFilterFocus(facets);
        }
        break;
      default:
        if (this.ui.facetHeader.hasClass('binf-disabled')) {
          nextChild = this.ui.cancel;
          break;
        }
        nextChild = this.ui.facetHeaderIcon;
      }

      return nextChild;
    }

  };

  return KeyEventNavigation;

});

csui.define('csui/controls/checkbox/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/checkbox/impl/nls/root/lang',{
  ariaLabel: 'Item selection',
  title: 'Item selection'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/checkbox/impl/checkbox.view',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        aria-labelledBy=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"ariaLabelledBy") || (depth0 != null ? lookupProperty(depth0,"ariaLabelledBy") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"ariaLabelledBy","hash":{},"loc":{"start":{"line":3,"column":25},"end":{"line":3,"column":43}}}) : helper)))
    + "\"\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"ariaLabel") || (depth0 != null ? lookupProperty(depth0,"ariaLabel") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"ariaLabel","hash":{},"loc":{"start":{"line":5,"column":20},"end":{"line":5,"column":33}}}) : helper)))
    + "\"\r\n";
},"5":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(((helper = (helper = lookupProperty(helpers,"label") || (depth0 != null ? lookupProperty(depth0,"label") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"label","hash":{},"loc":{"start":{"line":9,"column":15},"end":{"line":9,"column":24}}}) : helper)));
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<button type=\"button\" role=\"checkbox\" class=\"csui-control csui-checkbox\"\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"ariaLabelledBy") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"loc":{"start":{"line":2,"column":2},"end":{"line":6,"column":9}}})) != null ? stack1 : "")
    + "  "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"disabled") || (depth0 != null ? lookupProperty(depth0,"disabled") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"disabled","hash":{},"loc":{"start":{"line":7,"column":2},"end":{"line":7,"column":14}}}) : helper)))
    + " title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":7,"column":22},"end":{"line":7,"column":31}}}) : helper)))
    + "\" aria-checked=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"ariaChecked") || (depth0 != null ? lookupProperty(depth0,"ariaChecked") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"ariaChecked","hash":{},"loc":{"start":{"line":7,"column":47},"end":{"line":7,"column":62}}}) : helper)))
    + "\">\r\n  <span class=\"csui-checkbox-icon-container\"></span>\r\n  "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"label") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"loc":{"start":{"line":9,"column":2},"end":{"line":9,"column":31}}})) != null ? stack1 : "")
    + "\r\n</button>";
}});
Handlebars.registerPartial('csui_controls_checkbox_impl_checkbox.view', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/checkbox/checkbox.icons.v2',[
  'csui/controls/icons.v2',
], function (iconRegistry) {
  iconRegistry.registerIcons(
      {
        "csui_checkbox": '<svg class="csui-icon-v2 csui-impl-icon-v2__checkbox" version="1.1"' +
                         ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"' +
                         ' x="0px" y="0px" viewBox="0 0 32 32"' +
                         ' xml:space="preserve"><path class="csui-icon-v2-metaphor2"' +
                         ' d="M29.8556+26.8889C29.8556+28.6+28.4629+30+26.7606+30L5.09507+30C3.39278+30+2+28.6+2+26.8889L2+5.11111C2+3.4+3.39278+2+5.09507+2L26.7606+2C28.4629+2+29.8556+3.4+29.8556+5.11111L29.8556+26.8889Z" opacity="1" fill="#ffffff"/>' +
                         '<path class="csui-icon-v2-metaphor0"' +
                         ' d="M26.7606+3.55556C27.6133+3.55556+28.3081+4.254+28.3081+5.11111L28.3081+26.8889C28.3081+27.746+27.6133+28.4444+26.7606+28.4444L5.09507+28.4444C4.24238+28.4444+3.54754+27.746+3.54754+26.8889L3.54754+5.11111C3.54754+4.254+4.24238+3.55556+5.09507+3.55556L26.7606+3.55556M26.7606+2L5.09507+2C3.39278+2+2+3.4+2+5.11111L2+26.8889C2+28.6+3.39278+30+5.09507+30L26.7606+30C28.4629+30+29.8556+28.6+29.8556+26.8889L29.8556+5.11111C29.8556+3.4+28.4629+2+26.7606+2L26.7606+2Z" fill-rule="evenodd" clip-rule="evenodd" fill="#333333"/>' +
                         '</svg>',
        "csui_checkbox-selected": '<svg class="csui-icon-v2 csui-impl-icon-v2__checkbox-selected"' +
                                  ' version="1.1" xmlns="http://www.w3.org/2000/svg"' +
                                  ' xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"' +
                                  ' viewBox="0 0 32 32" xml:space="preserve">' +
                                  '<g opacity="1"><path class="csui-icon-v2-metaphor2"' +
                                  ' d="M26.8889+30L5.11111+30C3.39222+30+2+28.6078+2+26.8889L2+5.11111C2+3.39222+3.39222+2+5.11111+2L26.8889+2C28.6078+2+30+3.39222+30+5.11111L30+26.8889C30+28.6078+28.6078+30+26.8889+30Z" opacity="1" fill="#ffffff"/>' +
                                  '<path class="csui-icon-v2-metaphor2"' +
                                  ' d="M26.3818+29.3482L5.61822+29.3482C3.98022+29.3482+2.65178+28.0198+2.65178+26.3818L2.65178+5.61822C2.65178+3.98022+3.98022+2.65178+5.61822+2.65178L26.3833+2.65178C28.0213+2.65178+29.3498+3.98022+29.3498+5.61822L29.3498+26.3833C29.3482+28.0213+28.0213+29.3482+26.3818+29.3482Z" opacity="1" fill="#ffffff"/>' +
                                  '<path class="csui-icon-v2-metaphor0"' +
                                  ' d="M26.8889+3.55556C27.746+3.55556+28.4444+4.254+28.4444+5.11111L28.4444+26.8889C28.4444+27.746+27.746+28.4444+26.8889+28.4444L5.11111+28.4444C4.254+28.4444+3.55556+27.746+3.55556+26.8889L3.55556+5.11111C3.55556+4.254+4.254+3.55556+5.11111+3.55556L26.8889+3.55556M26.8889+2L5.11111+2C3.39222+2+2+3.39222+2+5.11111L2+26.8889C2+28.6078+3.39222+30+5.11111+30L26.8889+30C28.6078+30+30+28.6078+30+26.8889L30+5.11111C30+3.39222+28.6078+2+26.8889+2L26.8889+2Z" fill-rule="evenodd" clip-rule="evenodd" fill="#333333"/>' +
                                  '</g>' + '' +
                                  '<path class="csui-icon-v2-metaphor0" d="M13.1129+23.4496L7.63733+17.974C7.02911+17.3658+7.02911+16.3827+7.63733+15.7744C8.24556+15.1662+9.22867+15.1662+9.83689+15.7744L13.1113+19.0489L21.7073+10.4529C22.3156+9.84467+23.2987+9.84467+23.9069+10.4529C24.5151+11.0611+24.5151+12.0442+23.9069+12.6524L13.1129+23.4496Z" fill-rule="evenodd" clip-rule="evenodd" fill="#333333"/>' +
                                  '</svg>',
        "csui_checkbox-mixed": '<svg class="csui-icon-v2 csui-impl-icon-v2_checkbox-mixed" version="1.1"' +
                               ' xmlns="http://www.w3.org/2000/svg"' +
                               ' xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"' +
                               ' viewBox="0 0 32 32" xml:space="preserve">' +
                               '<g opacity="1"><path class="csui-icon-v2-metaphor2"' +
                               ' d="M30+26.8889C30+28.6+28.6+30+26.8889+30L5.11111+30C3.4+30+2+28.6+2+26.8889L2+5.11111C2+3.4+3.4+2+5.11111+2L26.8889+2C28.6+2+30+3.4+30+5.11111L30+26.8889Z" opacity="1" fill="#ffffff"/>' +
                               '<path class="csui-icon-v2-metaphor0"' +
                               ' d="M26.8889+3.55556C27.746+3.55556+28.4444+4.254+28.4444+5.11111L28.4444+26.8889C28.4444+27.746+27.746+28.4444+26.8889+28.4444L5.11111+28.4444C4.254+28.4444+3.55556+27.746+3.55556+26.8889L3.55556+5.11111C3.55556+4.254+4.254+3.55556+5.11111+3.55556L26.8889+3.55556M26.8889+2L5.11111+2C3.4+2+2+3.4+2+5.11111L2+26.8889C2+28.6+3.4+30+5.11111+30L26.8889+30C28.6+30+30+28.6+30+26.8889L30+5.11111C30+3.4+28.6+2+26.8889+2L26.8889+2Z" fill-rule="evenodd" clip-rule="evenodd" fill="#333333"/>' +
                               '<path class="csui-icon-v2-metaphor0"' +
                               ' d="M22.2222+17.5556L9.77778+17.5556C8.84444+17.5556+8.22222+16.9333+8.22222+16C8.22222+15.0667+8.84444+14.4444+9.77778+14.4444L22.2222+14.4444C23.1556+14.4444+23.7778+15.0667+23.7778+16C23.7778+16.9333+23+17.5556+22.2222+17.5556Z" fill-rule="evenodd" clip-rule="evenodd" fill="#333333"/>' +
                               '</g>' +
                               '</svg>',

      }
  );
});

csui.define('css!csui/controls/control/impl/control',[],function(){});

csui.define('css!csui/controls/checkbox/impl/checkbox.view',[],function(){});
csui.define('csui/controls/checkbox/checkbox.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/controls/icon/icon.view',
  'i18n!csui/controls/checkbox/impl/nls/lang',
  'hbs!csui/controls/checkbox/impl/checkbox.view',
  'csui/controls/checkbox/checkbox.icons.v2',
  'css!csui/controls/control/impl/control',
  'css!csui/controls/checkbox/impl/checkbox.view'
], function ($, _, Backbone, Marionette, IconView, lang, template) {
  'use strict';

  /**
   * @class Checkbox
   * @fires click - on the view model
   * @description

   ## Checkbox Control

   The checkbox.view.js implements a marionette.js view that renders a checkbox but without using a
   native html input type="checkbox" element. Instead it is displaying a custom styled checkbox
   depending on the checkbox state.

   The checkbox.view creates a model in its constructor to store view state.

   The attribute which stores the checked state is *checked* and can have these states:
   * 'true'
   * 'false'
   * 'mixed'
   */
  return Marionette.ItemView.extend(/** @lends Checkbox# */ {



    // all controls should have csui-control-view for applying common css */
    className: 'csui-control-view csui-checkbox-view',
    template: template,

    /**
     *
     * @returns {string}
     */
    calculateIconName: function () {
      var checked = this.model.get('checked');
      this._iconName = 'csui_checkbox';
      switch (checked) {
      case 'true':
        this._iconName = 'csui_checkbox-selected';
        break;
      case 'mixed':
        this._iconName = 'csui_checkbox-mixed';
        break;
      case 'false':
        this._iconName = 'csui_checkbox';
        break;
      }
      return this._iconName;
    },

    /**
     *
     * @param d
     */
    setDisabled: function (d) {
      this.model.set('disabled', !!d);
    },


    /**
     *
     * @returns {{ariaLabelledBy: *, ariaChecked: any, disabled: string, label: (*|string), title: *, ariaLabel: *}}
     */
    templateHelpers: function () {
      return {
        disabled: this.model.get('disabled') ? 'disabled' : '',
        ariaChecked: this.model.get('checked'),
        title: this.title !== undefined ? this.title : lang.title,
        ariaLabelledBy: this.ariaLabelledBy, // if ariaLabelledBy is set, the ariaLabel field will NOT be created
        ariaLabel: this.ariaLabel !== undefined ? this.ariaLabel : lang.ariaLabel,
        label: this.label || ''
      };
    },

    /**
     *
     */
    ui: {
      cb: 'button.csui-control.csui-checkbox',
      checkboxIconContainer: '.csui-checkbox-icon-container'
    },

    /**
     *
     */
    events: {
      'click': '_toggleChecked'
    },

    /**
     * @name Checkbox
     * @extends Marionette.ItemView
     * @constructs
     * @param options {Object} - Recognized option properties:
     * @param options.disabled {Boolean} - Initial *disabled* state. Default is *false*.
     * @param options.checked {String} -  Initial *checked* state. Default is *'false'*.
     * @param options.ariaLabel {String} - *aria-label* attribute, set on the HTML markup of the control.
     * @param options.ariaLabelledBy {String} - *aria-labelledBy* attribute, set on the HTML markup of the control.
     * When this is present an *ariaLabel* value will be ignored.
     * @param options.titleForCheckedFalse {String} - *title* attribute, set on the HTML markup of the control
     * for the *checked=false* state.
     * @param options.titleForCheckedTrue {String} - *title* attribute, set on the HTML markup of the control
     * for the *checked=true* state.
     * @param options.titleForCheckedMixed {String} - *title* attribute set on the HTML markup of the control
     * for the *checked=mixed* state.
     * @param options.title {String} - *title* attribute, set on the HTML markup of the control. Default is ''.
     * @param options.model {Object} - Model to use as view model.
     */
    constructor: function Checkbox(options) {
      options || (options = {});

      this.ariaLabel = options.ariaLabel;
      this.ariaLabelledBy = options.ariaLabelledBy;
      this.title = options.title;
      this.label = options.label;
      if (!options.model) {

        options.model = new Backbone.Model(
            {disabled: options.disabled === undefined ? false : options.disabled}
        );

      }
      Marionette.ItemView.prototype.constructor.call(this, options);
      this._setChecked(options.checked, {silent: true});
      this.calculateIconName();
      this.checkboxIconView = new IconView(
          {iconName: this._iconName, size: 'xsmall', states: 'true'});

      this.listenTo(this, 'render', function () {
        var region = new Marionette.Region({el: this.ui.checkboxIconContainer});
        region.show(this.checkboxIconView);
      });

      this._undelegateModelAndCollectionEvents();

      // setup specific model events but don't call render, but instead change specific attributes
      this.listenTo(this.model, 'change:disabled', this._handleDisableChanged);
      this.listenTo(this.model, 'change:checked', this._handleCheckedChanged);
    },


    /**
     *
     * @param state
     */
    setChecked: function (state) {
      var options = {silent: false};
      if (this.model.get('disabled')) {
        options.silent = true;
      }
      this._setChecked(state, options);
    },

    /**
     * Update icon.
     * @private
     */
    _updateIcon: function () {
      this.calculateIconName();
      this.checkboxIconView.setIcon(this._iconName);
    },

    /**
     *
     * @private
     */
    _handleDisableChanged: function () {
      var disabled = this.model.get('disabled');
      this.ui.cb.prop('disabled', disabled);
    },

    /**
     *
     * @private
     */
    _handleCheckedChanged: function () {
      this._updateIcon();
      var checked = this.model.get("checked");
      this.ui.cb.attr('aria-checked', checked);
    },

    _setChecked: function (state, options) {
      switch (state) {
      case 'true':
      case true:
        this.model.set('checked', 'true', options);
        break;
      case 'mixed':
        this.model.set('checked', 'mixed', options);
        break;
      default:
        this.model.set('checked', 'false', options);
        break;
      }
    },

    /**
     *
     * @private
     */
    _toggleChecked: function () {
      if (this.model.get('disabled')) {
        return; // don't change checkbox and don't fire events, because it's disabled
      }

      // first trigger a clicked event and if no listener set cancel=true on the event args toggle
      // the checked state
      var currentState = this.model.get('checked');
      var args = {sender: this, model: this.model};
      this.triggerMethod('clicked', args);

      if (!args.cancel) {
        if (!currentState || currentState === 'false' || currentState === 'mixed') {
          this.model.set('checked', 'true');
        } else {
          this.model.set('checked', 'false');
        }
      }
    }

  });
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/facet.panel/impl/facet/facet.item',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <div class=\"csui-facet-item-checkbox "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"showOnHover") || (depth0 != null ? lookupProperty(depth0,"showOnHover") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"showOnHover","hash":{},"loc":{"start":{"line":2,"column":41},"end":{"line":2,"column":56}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"checkbox") || (depth0 != null ? lookupProperty(depth0,"checkbox") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"checkbox","hash":{},"loc":{"start":{"line":2,"column":58},"end":{"line":2,"column":70}}}) : helper)))
    + "</div>\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <div class=\"csui-total\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"count") || (depth0 != null ? lookupProperty(depth0,"count") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"count","hash":{},"loc":{"start":{"line":7,"column":26},"end":{"line":7,"column":35}}}) : helper)))
    + "</div>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableCheckBox") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":7}}})) != null ? stack1 : "")
    + "  <div class=\"csui-filter-name\" tabindex=\"-1\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"filterTitle") || (depth0 != null ? lookupProperty(depth0,"filterTitle") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"filterTitle","hash":{},"loc":{"start":{"line":4,"column":53},"end":{"line":4,"column":68}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"filterTitleAria") || (depth0 != null ? lookupProperty(depth0,"filterTitleAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"filterTitleAria","hash":{},"loc":{"start":{"line":4,"column":82},"end":{"line":4,"column":101}}}) : helper)))
    + "\">\r\n  <div class=\"csui-name\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":5,"column":25},"end":{"line":5,"column":33}}}) : helper)))
    + "</div>\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"displayCount") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":6,"column":2},"end":{"line":8,"column":9}}})) != null ? stack1 : "")
    + "</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_facet.panel_impl_facet_facet.item', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/facet.panel/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/facet.panel/impl/nls/root/lang',{
  facetsTitle: 'Refine by',
  facetsRegionAria: 'Refinement options',
  facetTitleAria: 'Refine by {0}',
  searchIconTooltip: 'Search by {0}',
  filterTitle: '{0} ({1})',
  filterTitleAria: 'Filter {0} with {1} items',
  filterTitleAriaNoDisplayCount: 'Filter {0}',
  filterCheckboxAria: 'Filter {0} with {1} items',
  filterCheckboxAriaNoDisplayCount: 'Filter {0}',
  searchClearIconTooltip: 'Clear all',
  emptyFacetMessage: 'No filters available.',
  emptyFilteredFacetMessage: 'No more filters available.',
  loadingFacetMessage: 'Loading filters...',
  failedFacetMessage: 'Loading filters failed.',
  noFiles: 'No drop files were provided.',
  addTypeDenied: 'Cannot add documents to {0}.',
  showMore: 'Show more',
  showMoreAria: 'Show more filters',
  showLess: 'Show less',
  showLessAria: 'Show less filters',
  apply: 'Apply',
  applyFiltersAria: 'Apply selected filters',
  clear: 'Cancel',
  clearFiltersAria: 'Clear selected filters',
  showFacetAria: 'Show facet',
  hideFacetAria: 'Hide facet',
  filterOptions: 'Filter options'
});



csui.define('css!csui/controls/facet.panel/impl/facet/facet.item',[],function(){});
csui.define('csui/controls/facet.panel/impl/facet/facet.item.view',["csui/lib/jquery", "csui/utils/base", "csui/lib/underscore", "csui/lib/marionette",
  "csui/controls/checkbox/checkbox.view",
  "hbs!csui/controls/facet.panel/impl/facet/facet.item",
  'i18n!csui/controls/facet.panel/impl/nls/lang',
  "css!csui/controls/facet.panel/impl/facet/facet.item"
], function ($, base, _, Marionette, CheckboxView, template, lang) {

  var FacetItemView = Marionette.ItemView.extend({

    template: template,
    className: 'csui-facet-item',

    constructor: function FacetItemView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.showInputOnHover =  !base.isTouchBrowser();
    },

    triggers: {
      'click .csui-filter-name': 'single:filter:select'
    },

    ui: {
      name: '.csui-name'
    },

    events: {
      'click .csui-checkbox': 'onToggleCheckbox',
      'change .csui-checkbox': 'onChangeValue',
      'focus .csui-facet-item-checkbox': 'onFocus',
      'blur .csui-facet-item-checkbox': 'onBlur',
      'keydown .csui-facet-item-checkbox': 'onToggleCheckbox',
      'keydown .csui-filter-name': 'onToggleCheckbox'
    },

    templateHelpers: function () {
      var showOnHover = this.showInputOnHover ? '' : 'csui-showAlways',
          count       = this.options.model.get('count') ? this.options.model.get('count') :
                        this.options.model.get('total'),
      filterTitleAria, filterCheckboxAria,filterTitle,
          showDisplayCount         = true,
          context                  = this.options.context,
          userHasSystemAdminRights = context && context._user && context._user.get(
              'privilege_system_admin_rights');

      //display count will be showed for admin users irrespective of Dispaly counts setting,
      //where as for non admin users display count will be displayed as per display count settings.
      if (!userHasSystemAdminRights) {
        switch (this.options.displayCount) {
        case "Never": {
          showDisplayCount = false;
          break;
        }
        case "Always": {
          showDisplayCount = true;
          break;
        }
        default: {
          var displayCount =
                  this.options.displayCount &&
                  this.options.displayCount.split(">")[1];
          showDisplayCount = !!displayCount && (count > parseInt(displayCount));
        }
        }
      }
      this.showDisplayCount = showDisplayCount;
      filterTitleAria = showDisplayCount ? _.str.sformat(lang.filterTitleAria, this.options.model.get('name'), count) :
        _.str.sformat(lang.filterTitleAriaNoDisplayCount, this.options.model.get('name'));
      filterCheckboxAria = showDisplayCount ? _.str.sformat(lang.filterCheckboxAria, this.options.model.get('name'), count) :
        _.str.sformat(lang.filterCheckboxAriaNoDisplayCount, this.options.model.get('name'));
      filterTitle = showDisplayCount ? _.str.sformat(lang.filterTitle, this.options.model.get('name'), count) : this.options.model.get('name');
      return {
        showOnHover: showOnHover,
        count: count,
        enableCheckBox: this.options.enableCheckBoxes,
        displayCount: showDisplayCount,
        filterTitleAria: filterTitleAria,
        filterCheckboxAria: filterCheckboxAria,
        filterTitle: filterTitle
      };
    },

    onToggleCheckbox: function(event){
      var keyCode = event.keyCode,
          target = $(event.target);

      event.preventDefault();

      switch (keyCode) {
        //Enter and space
        case 32:
        case 13:
          if (this.checkboxView) {
            var isChecked = this.checkboxView.model.get('checked');
            if (isChecked === 'true') {
              this.checkboxView.setChecked(false);
            } else {
              this.checkboxView.setChecked(true);
            }
//            this.triggerMethod('multi:filter:select');
          } else {
            //for filters in search results
            this.triggerMethod('single:filter:select');
          }
          break;
        //right/left arrow
        case 39:
        case 37:
          // moving right/left is of no use as the two locations do not differ in functionality
          break;
        case 38:
        case 40:
          this.trigger('keyupdown', keyCode === 38, target);
          break;
        default:
          return true;
      }

      return false;
    },

    onChangeValue: function(event) {
      if (this.checkboxView) {
        var checkbox = event.target;
        this.checkboxView.setDisabled(checkbox.disabled);
      }
    },

    onDomRefresh: function() {
      if (this.options.enableCheckBoxes) {
        var checkboxDiv = this.$el.find(".csui-facet-item-checkbox");
        var count = this.model.get('count') ? this.options.model.get('count') : this.options.model.get('total');
        var checkboxTitle = this.showDisplayCount ? _.str.sformat(lang.filterTitleAria, this.model.get('name'), count) :
          _.str.sformat(lang.filterTitleAriaNoDisplayCount, this.model.get('name'));
        var checkboxAriaLabel = this.showDisplayCount ? _.str.sformat(lang.filterCheckboxAria, this.model.get('name'), count) :
          _.str.sformat(lang.filterCheckboxAriaNoDisplayCount, this.model.get('name'));
        if (!this.checkboxView) {
          this.checkboxView = new CheckboxView({
            checked: false,
            disabled: false,
            ariaLabel: checkboxAriaLabel,
            title: checkboxTitle
          });
          this.listenTo(this.checkboxView.model, 'change:checked', function() {
            this.triggerMethod('multi:filter:select');
          });

          var checkboxRegion = new Marionette.Region({el: checkboxDiv});
          checkboxRegion.show(this.checkboxView);
        }
      }
    },

    onFocus: function (event) {
      var facet = $(event.target).closest('.csui-facet');
      if (facet.length > 0) {
        facet.addClass('csui-focus');
      }
    },

    onBlur: function (event) {
      var facet = $(event.target).closest('.csui-facet');
        if (facet.length > 0) {
          facet.removeClass('csui-focus');
        }
    },

    getIndex: function(){
      return this._index;
    }

  });

  return FacetItemView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/facet.panel/impl/facet/facet',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <div class=\"csui-filter-more\" role=\"button\" tabindex=\"-1\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"moreFiltersAria") || (depth0 != null ? lookupProperty(depth0,"moreFiltersAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"moreFiltersAria","hash":{},"loc":{"start":{"line":10,"column":74},"end":{"line":10,"column":93}}}) : helper)))
    + "\">\r\n        <div class=\"csui-more-text\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"more") || (depth0 != null ? lookupProperty(depth0,"more") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"more","hash":{},"loc":{"start":{"line":11,"column":36},"end":{"line":11,"column":44}}}) : helper)))
    + "</div>\r\n        <div class=\"cs-icon "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"more-icon") || (depth0 != null ? lookupProperty(depth0,"more-icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"more-icon","hash":{},"loc":{"start":{"line":12,"column":28},"end":{"line":12,"column":41}}}) : helper)))
    + "\"></div>\r\n    </div>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"csui-facet-header\">\r\n  <div class=\"header-label\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":2,"column":35},"end":{"line":2,"column":43}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":2,"column":45},"end":{"line":2,"column":53}}}) : helper)))
    + "</div>\r\n  <div class=\"header-count\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"count") || (depth0 != null ? lookupProperty(depth0,"count") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"count","hash":{},"loc":{"start":{"line":3,"column":35},"end":{"line":3,"column":44}}}) : helper)))
    + "\"> ("
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"count") || (depth0 != null ? lookupProperty(depth0,"count") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"count","hash":{},"loc":{"start":{"line":3,"column":48},"end":{"line":3,"column":57}}}) : helper)))
    + ")</div>\r\n  <div class=\"cs-icon csui-button-icon icon-expandArrowUp\" role=\"button\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"showFacetAria") || (depth0 != null ? lookupProperty(depth0,"showFacetAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"showFacetAria","hash":{},"loc":{"start":{"line":4,"column":80},"end":{"line":4,"column":97}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"showFacetAria") || (depth0 != null ? lookupProperty(depth0,"showFacetAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"showFacetAria","hash":{},"loc":{"start":{"line":4,"column":111},"end":{"line":4,"column":128}}}) : helper)))
    + "\" tabindex=\"-1\"></div>\r\n</div>\r\n\r\n<div class=\"csui-facet-content "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"show-content") || (depth0 != null ? lookupProperty(depth0,"show-content") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"show-content","hash":{},"loc":{"start":{"line":7,"column":31},"end":{"line":7,"column":47}}}) : helper)))
    + "\" role=\"presentation\">\r\n  <div class=\"cs-filter-group\" role=\"presentation\"></div>\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"more") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":9,"column":2},"end":{"line":14,"column":9}}})) != null ? stack1 : "")
    + "  <div class=\"csui-facet-controls "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"show-controls") || (depth0 != null ? lookupProperty(depth0,"show-controls") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"show-controls","hash":{},"loc":{"start":{"line":15,"column":34},"end":{"line":15,"column":51}}}) : helper)))
    + "\">\r\n      <button class=\"csui-btn binf-btn binf-btn-primary csui-apply\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"applyFiltersAria") || (depth0 != null ? lookupProperty(depth0,"applyFiltersAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"applyFiltersAria","hash":{},"loc":{"start":{"line":16,"column":80},"end":{"line":16,"column":100}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"apply") || (depth0 != null ? lookupProperty(depth0,"apply") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"apply","hash":{},"loc":{"start":{"line":16,"column":102},"end":{"line":16,"column":111}}}) : helper)))
    + "</button>\r\n      <button class=\"csui-btn binf-btn binf-btn-secondary csui-clear\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"clearFiltersAria") || (depth0 != null ? lookupProperty(depth0,"clearFiltersAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"clearFiltersAria","hash":{},"loc":{"start":{"line":17,"column":82},"end":{"line":17,"column":102}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"clear") || (depth0 != null ? lookupProperty(depth0,"clear") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"clear","hash":{},"loc":{"start":{"line":17,"column":104},"end":{"line":17,"column":113}}}) : helper)))
    + "</button>\r\n  </div>\r\n\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_facet.panel_impl_facet_facet', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/facet.panel/impl/facet/facet',[],function(){});
csui.define('csui/controls/facet.panel/impl/facet/facet.view',[
  'csui/lib/underscore', 'module',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/utils/base',
  'csui/models/facettopics',
  'csui/models/nodefacets2',
  'csui/controls/facet.panel/impl/facet/facet.key.navigation',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/facet.panel/impl/facet/facet.item.view',
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'csui/controls/globalmessage/globalmessage',
  'csui/controls/progressblocker/blocker',
  'hbs!csui/controls/facet.panel/impl/facet/facet',
  'i18n!csui/controls/facet.panel/impl/nls/lang',
  'css!csui/controls/facet.panel/impl/facet/facet'
], function (_, module, $, Marionette, base, FacetTopicCollection, NodeFacet2Collection,
    KeyEventNavigation, TabableRegionBehavior, FacetItemView, ViewEventsPropagationMixin,
    GlobalMessage, BlockingView, template, lang) {

  var config = module.config();
  _.defaults(config, {
    displayCount: 'Always'
  });

  var FacetView = Marionette.CompositeView.extend({

    childView: FacetItemView,
    template: template,
    className: 'csui-facet',

    childViewContainer: '.cs-filter-group',

    ui: {
      facetContent: '.csui-facet-content',
      facetHeader: '.csui-facet-header',
      facetHeaderIcon: '.csui-facet-header > .cs-icon',
      facetSubmitControls: '.csui-facet-controls',
      facetCollapseControls: '.csui-facet-collapse-controls',
      facetMoreText: '.csui-more-text',
      facetMoreIcon: '.csui-filter-more .cs-icon',
      facetMore: '.csui-filter-more',
      apply: '.csui-facet-controls .csui-apply',
      cancel: '.csui-facet-controls .csui-clear',
      selectCount: '.header-count'
    },

    childEvents: {
      'single:filter:select': 'onSingleFilterSelect',
      'multi:filter:select': 'onMultiFilterSelect',
      'keyupdown': 'cursorNextFilter',
      'keyleftright': 'cursorInsideFilter'
    },

    events: {
      'click .csui-filter-more:not(.binf-disabled)': 'onShowMore',
      'click .csui-facet-header': 'onShowFacet',
      'mouseleave': 'onMouseLeave',
      'keydown': 'onKeyInView'
    },

    triggers: {
      'click .csui-clear': 'clear:all',
      'click .csui-apply': 'apply:all'
    },

    templateHelpers: function () {
      var moreLabel = this.showAll ? lang.showLess : lang.showMore,
          moreFiltersAria = this.showAll ? lang.showLessAria : lang.showMoreAria;
      return {
        'more': this.haveMore ? moreLabel : undefined,
        'moreFiltersAria': moreFiltersAria,
        'more-icon': this.showAll ? 'icon-expandArrowUp' : 'icon-expandArrowDown',
        'apply': lang.apply,
        'applyFiltersAria': lang.applyFiltersAria,
        'clear': lang.clear,
        'clearFiltersAria': lang.clearFiltersAria,
        'show-controls': this.selectItems.length > 0 ? 'csui-multi-select' : '',
        'show-content': this.showFacet ? '' : 'binf-hidden',
        'showFacetAria': this.showFacet ? lang.hideFacetAria : lang.showFacetAria
      };
    },

    childViewOptions: function () {
      //Checkboxes will be enabled by default. To disable checkboxes set 'select_multiple' as false.
      return {
        enableCheckBoxes: this.model.get('select_multiple') !== undefined ?
                          this.model.get('select_multiple') : true,
        displayCount: config && config.displayCount,
        context: this.options.context
      };
    },

    constructor: function FacetView(options) {
      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
      this.$el.attr('tabindex', 0);
      this.options = options || {};
      this.collection = new FacetTopicCollection();
      this.itemsToShow = this.model.get('items_to_show');
      this.nodeFacetsCollection = this.model.get('nodeFacetsCollection');
      this.showAll = false;
      this._fillCollection();
      var totalDisplayable = this.model.has('total_displayable') ?
                             this.model.get('total_displayable') : this.model.topics.length;
      this.haveMore = totalDisplayable > this.collection.length;
      this.showFacet = true;
      this.selectItems = [];
      this.listenTo(this, 'add:child', this.propagateEventsToViews);

      if (this.options.blockingParentView) {
        BlockingView.delegate(this, this.options.blockingParentView);
      }
    },

    onClearAll: function () {
      // Find all of the checkboxes that are checked and trigger a click event on them so that they will be unchecked.
      var checkboxes = this.$el.find(".csui-checkbox[aria-checked='true']");
      checkboxes.trigger('click');

      this.selectItems = [];
      this.ui.facetCollapseControls.removeClass('multi-select');
      this._setDisabledFilters(0);
      this.$el.removeClass('multi-select');
      this._updateFacetSubmitControls();
      this.ui.facetHeader.removeClass('binf-disabled');
      this.trigger('activate:facet', this);
    },

    onApplyAll: function () {
      var facet = this.model,
          filters = this._getFilterArray();

      this.newFilter = {
        id: facet.get('id'),
        values: filters
      };
      this.trigger('apply:filter');
    },

    onRender: function () {
      if (this.collection.length === 0) {
        this.$el.hide();
      }
      this.$el.attr('role', 'menu');
      this.$el.attr('aria-label', _.str.sformat(lang.facetTitleAria, this.model.get('name')));
    },

    onSingleFilterSelect: function (filter) {
      if (!filter.$el.hasClass('binf-disabled')) {
        if (this.$el.hasClass('multi-select')) {
          filter.$el.find('.csui-checkbox').trigger('click');
        } else {
          var facet = this.model;
          this.newFilter = {
            id: facet.get('id'),
            values: [{
              id: filter.model.get('value')
            }]
          };
          this.trigger('apply:filter');
        }
      }
    },

    onShowMore: function (event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }

      this.showAll = !this.showAll;

      var self = this;
      this._fillCollection()
          .done(function () {
            // Show more/less triggers a DOM refresh, which causes the checkbox views to be recreated, losing the current
            // selections.  For each view that is saved in the selectItems array we must find the new view that corresponds to
            // the same model.  We will then set that new view to be checked and save the new view to a separate array.  Once
            // all selected views are processed we will update the selectItems array with the new views.
            var newSelectItems = [];
            self.children.each(function (child, childIndex) {
              if (child.checkboxView) {
                if (self.selectItems[childIndex]) {
                  child.checkboxView.setChecked(true);
                  newSelectItems[childIndex] = child;
                } else {
                  child.checkboxView.setChecked(false);
                }
              }
            });

            self.selectItems = newSelectItems;

            var numCheckedItems = self._countCheckedItems();
            self._setDisabledFilters(numCheckedItems);

            self._setMoreLabel(self.showAll);
            self.trigger('facet:size:change');
          })
          .fail(function () {
            self.showAll = !self.showAll;
          });
    },

    onShowFacet: function (event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      this.showFacet = !this.showFacet;
      if (this.showFacet) {
        this.ui.facetContent.removeClass('binf-hidden');
        this.ui.facetCollapseControls.removeClass('multi-select');
        this.ui.facetHeaderIcon[0].className = 'cs-icon csui-button-icon icon-expandArrowUp';
        this.ui.facetHeaderIcon[0].setAttribute('aria-label', lang.hideFacetAria);
        this.ui.facetHeaderIcon[0].setAttribute('title', lang.hideFacetAria);
      } else {
        var numCheckedItems = this._countCheckedItems();
        this.ui.facetContent.addClass('binf-hidden');
        this.ui.facetHeaderIcon[0].className = 'cs-icon csui-button-icon icon-expandArrowDown';
        this.ui.facetHeaderIcon[0].setAttribute('aria-label', lang.showFacetAria);
        this.ui.facetHeaderIcon[0].setAttribute('title', lang.showFacetAria);
        if (numCheckedItems) {
          this.ui.facetCollapseControls.addClass('multi-select');
        }
      }
      this.trigger('facet:size:change');
    },

    onMouseLeave: function (event) {
      event.preventDefault();
      event.stopPropagation();
    },

    getIndex: function () {
      return this._index;
    },

    _countCheckedItems: function () {
      var numCheckedItems = 0;
      this.children.each(function (child) {
        if (child.checkboxView) {
          var checked = child.checkboxView.model.get('checked');
          if (checked === 'true') {
            numCheckedItems++;
          }
        }
      });
      return numCheckedItems;
    },

    onMultiFilterSelect: function (childView) {
      var numCheckedItems = this._countCheckedItems();
      this._updateSelectList(childView);
      this._updateFacetSubmitControls(numCheckedItems);
      this._setDisabledFilters(numCheckedItems);
      this.selectItems = (numCheckedItems === 0) ? [] : this.selectItems;
      this.trigger('activate:facet', this);
    },

    _updateFacetSubmitControls: function () {
      var numCheckedItems = this._countCheckedItems();
      if (numCheckedItems > 0) {
        this.ui.facetSubmitControls.addClass('csui-multi-select');
        this.$el.addClass('multi-select');
        this.ui.facetHeader.addClass('binf-disabled');
      } else {
        this.ui.facetSubmitControls.removeClass('csui-multi-select');
        this.$el.removeClass('multi-select');
        this.ui.facetHeader.removeClass('binf-disabled');
      }
    },

    _updateSelectList: function (childView) {
      var childIndex = childView.getIndex();
      if (this.selectItems[childIndex]) {
        delete this.selectItems[childIndex];
      } else {
        this.selectItems[childIndex] = childView;
      }
    },

    _setDisabledFilters: function (numCheckedItems) {
      var unselectedItems = this.children.filter(function (child) {
        if (child.checkboxView) {
          var checked = child.checkboxView.model.get('checked');
          return (checked === 'false');
        } else {
          return true;  // if no checkbox it is not selected...
        }
      });

      _.each(unselectedItems, function (facetItemView) {
        facetItemView.checkboxView.setDisabled(numCheckedItems >= 5);
      });

      this.ui.selectCount.text(numCheckedItems);
    },

    _setMoreLabel: function (showAll) {
      var moreItems = this.$el.find('.csui-facet-item.more');
      if (this.ui.facetMoreIcon[0]) {
        if (showAll) {
          //moreItems.removeClass('binf-hidden');
          this.ui.facetMoreIcon[0].className = 'cs-icon icon-expandArrowUp';
          this.ui.facetMoreText.text(lang.showLess);
          this.ui.facetMore[0].setAttribute('aria-label', lang.showLessAria);
          this.ui.facetMoreText[0].setAttribute('aria-expanded', 'true');
        } else {
          //moreItems.addClass('binf-hidden');
          this.ui.facetMoreIcon[0].className = 'cs-icon icon-expandArrowDown';
          this.ui.facetMoreText.text(lang.showMore);
          this.ui.facetMore[0].setAttribute('aria-label', lang.showMoreAria);
          this.ui.facetMoreText[0].setAttribute('aria-expanded', 'false');
        }
      }
      this.trigger('facet:size:change');
    },

    _getFilterArray: function () {
      var filters = [];
      _.each(this.selectItems, function (item) {
        if (item) {
          filters.push({
            id: item.model.get('value')
          });
        }
      });
      return filters;
    },

    _fillCollection: function () {
      var self = this,
          deferred = $.Deferred();

      if (this.showAll) {
        // Fetch more facet values for only this facet if it has not been done
        if (this.model.get('total_displayable') > this.model.topics.length) {
          var facetId = this.model.get('id'),
              options = {
                filters: this.nodeFacetsCollection.filters,
                facetIds: [facetId],
                node: this.nodeFacetsCollection.node
              },
              nodeFacets = new NodeFacet2Collection(null, options);

          this.blockActions && this.blockActions();
          nodeFacets.fetch()
              .always(function () {
                self.unblockActions && self.unblockActions();
              })
              .done(function () {
                self.model.topics.reset(nodeFacets.get(facetId).topics.models, {silent: true});
                self.collection.reset(self.model.topics.models);
                deferred.resolve();
              })
              .fail(function (err) {
                var error = new base.Error(err);
                GlobalMessage.showMessage('error', error.message);
                deferred.reject(error);
              });
          return deferred.promise();
        } else {
          this.collection.reset(this.model.topics.models);
        }
      } else {
        var topics = this.model.topics.first(this.itemsToShow);
        this.collection.reset(topics);
      }

      return deferred.resolve().promise();
    }

  });

  _.extend(FacetView.prototype, KeyEventNavigation);
  _.extend(FacetView.prototype, ViewEventsPropagationMixin);

  return FacetView;
});

csui.define('csui/controls/facet.panel/impl/facet.panel.key.navigation',['csui/lib/underscore', 'csui/lib/jquery'
], function (_, $) {
  'use strict';

  var KeyEventNavigation = {

    currentlyFocusedElement: function () {
      //change facet group items back to tabindex = 0. Tabable behavior sets all tabindex to -1, which doesn't work for
      //this scenario
      var focusables = this.$('.cs-list-group .csui-facet[tabindex=-1]');
      if (focusables.length) {
        focusables.prop('tabindex', 0);
      }
      return this.getActiveChild();
    },
    onSetNextChildFocus: function(childView){
      this.activeChildIndex = childView.getIndex();
    },
    accActivateTabableRegion: function () {
      $(document).unbind('mousedown', this._onRemoveKeyboardFocus);
      $(document).bind('mousedown', this._onRemoveKeyboardFocus);

    },

    _removeKeyboardFocus: function () {
      this.$el.find('.csui-focus').removeClass('csui-focus');
      $(document).unbind('mousedown', this._onRemoveKeyboardFocus);
    },

    onKeyInView: function (event) {
      var keyCode = event.keyCode;
      var retVal = false;

      switch (keyCode) {
        case 38:
        case 33:
          var prevChild = this._getPrevActiveChild();
          prevChild.trigger('focus');
          break;
        //down arrow, page down
        case 40:
        case 34:
          var nextChild = this._getNextActiveChild();
          nextChild.trigger('focus');
          break;
        default:
          return true;
      }
      return retVal;
    },

    resetFacetFocus: function (childView) {
      childView.$el.trigger('focus');
    },



    getActiveChild: function () {
      // FIXMWE: How is it possible, that $childViewContainer is undefined,
      // but somebody called this method?
      if (!this.$childViewContainer) {
        return $();
      }
      if (!this.activeChild){
      var childViewContainer = this.$childViewContainer[0];
        if (childViewContainer && childViewContainer.childNodes[0]) {
        this.activeChild = $(childViewContainer.childNodes[0]);
        this.activeChildIndex = 0;
      }


      }
      return this.activeChild;
    },

    _getNextActiveChild: function(){
      var childNodes = this.$childViewContainer[0].childNodes;
      if(childNodes.length - 1 > this.activeChildIndex){
        this.activeChildIndex++;
      }
      else{
        this.activeChildIndex = 0;
      }

      return $(childNodes[this.activeChildIndex]);
    },

    _getPrevActiveChild: function(){
      var childNodes = this.$childViewContainer[0].childNodes;
      if(this.activeChildIndex > 0){
        this.activeChildIndex--;
      }
      else {
        this.activeChildIndex = childNodes.length - 1;
      }

      return $(childNodes[this.activeChildIndex]);
    }


  };

  return KeyEventNavigation;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/facet.panel/impl/facet.panel',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <div class=\"cs-header binf-panel-heading\">\r\n    <span class=\"cs-title\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":3,"column":27},"end":{"line":3,"column":36}}}) : helper)))
    + "</span>\r\n  </div>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"showTitle") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":1,"column":0},"end":{"line":5,"column":7}}})) != null ? stack1 : "")
    + "\r\n<div class=\"cs-content\" tabindex=\"-1\">\r\n  <div class=\"cs-list-group\" role=\"region\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"regionAria") || (depth0 != null ? lookupProperty(depth0,"regionAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"regionAria","hash":{},"loc":{"start":{"line":8,"column":55},"end":{"line":8,"column":69}}}) : helper)))
    + "\"></div>\r\n</div>\r\n\r\n\r\n";
}});
Handlebars.registerPartial('csui_controls_facet.panel_impl_facet.panel', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/facet.panel/impl/facet.panel',[],function(){});
csui.define('csui/controls/facet.panel/facet.panel.view',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/models/facets',
  'csui/controls/list/simplelist.view',
  'csui/controls/facet.panel/impl/facet/facet.view',
  'csui/behaviors/collection.state/collection.state.behavior',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/controls/facet.panel/impl/facet.panel.key.navigation',
  'csui/controls/progressblocker/blocker',
  'csui/controls/mixins/view.events.propagation/view.events.propagation.mixin',
  'hbs!csui/controls/facet.panel/impl/facet.panel',
  'i18n!csui/controls/facet.panel/impl/nls/lang',
  'css!csui/controls/facet.panel/impl/facet.panel'
], function (_, $, FacetCollection, SimpleListView, FacetView,
    CollectionStateBehavior, TabableRegionBehavior, KeyEventNavigation,
    BlockingView, ViewEventsPropagationMixin, template, lang) {
  'use strict';

  var FacetPanelView = SimpleListView.extend({

    template: template,

    className: 'cs-simplelist csui-facet-panel',

    behaviors: {

      CollectionState: {
        behaviorClass: CollectionStateBehavior,
        collection: function () {
          if (this.facets.length) {
            var availableFacets = this._getAvailableFacets();
            this.facets.models = availableFacets.models;
            this.facets.length = availableFacets.length;
          }
          return this.facets;
        },
        stateMessages: function () {
          return {
            empty: _.isEmpty(this.facets.filters) ?
                   lang.emptyFacetMessage :
                   lang.emptyFilteredFacetMessage,
            loading: lang.loadingFacetMessage,
            failed: lang.failedFacetMessage
          };
        }
      },

      TabableRegion: {
        behaviorClass: TabableRegionBehavior
      }

    },

    childView: FacetView,

    childViewOptions: function () {
      return {
        blockingParentView: this.options.blockingParentView,
        context: this.options.context
      };
    },

    childEvents: {
      'apply:filter': 'applyFilter',
      'activate:facet': 'setActiveFacet',
      'facet:size:change': '_updateScrollbar',
      'escape:focus': 'resetFacetFocus'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    templateHelpers: function () {
      var showTitle = this.options.data.showTitle;
      var title = this.options.data.title;
      var regionAria = this.options.data.regionAria;
      return {
        showTitle: showTitle,
        title: title,
        regionAria: regionAria
      };
    },

    onAddChild: function (childView) {
      var $child = childView.$el,
          self = this;
      //Hide all children with index greater than the set number of items to show from server
      if (childView.getIndex() === (this.collection.length - 1)) {
        $child.css('border-bottom', '0px');
      }
      $child.on('focus', function () {
        self.onSetNextChildFocus(childView);
      });
      this.propagateEventsToViews(childView);
    },

    constructor: function FacetPanelView(options) {
      this.facets = options.collection;
      this.originatingView = options.originatingView;
      options.collection = this._getAvailableFacets();

      SimpleListView.prototype.constructor.apply(this, arguments);
      this.options.data.title = lang.facetsTitle;
      this.options.data.regionAria = lang.facetsRegionAria;

      /* Show title by default if not specified in options*/
      this.options.data.showTitle = this.options.showTitle === undefined ? true :
                                    this.options.showTitle;

      //This function is used in the keyevent.navigation to remove focus from a facet group once focus
      //falls outside the Facet Filter. Within keyevent.navigation 'onRemoveKeyboardFocus' is bound to the
      //browser Documents 'mousedown' event at the time of Tab entry.
      this._onRemoveKeyboardFocus = _.bind(this._removeKeyboardFocus, this);

      if (this.options.blockingParentView && !this.options.blockingLocal) {
        BlockingView.delegate(this, this.options.blockingParentView);
        this.listenTo(this.facets, "request", this.blockActions)
            .listenTo(this.facets, "sync", this.unblockActions)
            .listenTo(this.facets, "error", this.unblockActions);
      } else {
        BlockingView.imbue({
          parent: this,
          local: this.options.blockingLocal
        });
      }
    },

    _getAvailableFacets: function () {
      var availableFacets = this.facets.getAvailableFacets();
      this.listenTo(this.facets, 'reset', function () {
        var availableFacets = this.facets.getAvailableFacets();
        this.collection.reset(availableFacets);
      });
      var self = this;
      this.listenTo(this.facets, "request", function() {
        self.originatingView && self.originatingView.blockActions();
      });
      this.listenTo(this.facets, "sync", function () {
        self.originatingView && self.originatingView.unblockActions();
        if (self.originatingView && self.originatingView.filterToolItemModel && self.originatingView.filterToolItemModel.get('isKeyEvent')) {
          $(self.$el.find('.csui-facet')[0]).trigger('focus');
        }
      });
      this.listenTo(this.facets, "destroy", function(){
        self.originatingView && self.originatingView.unblockActions();
      });
      this.listenTo(this, "destroy", function(){
        self.originatingView && self.originatingView.unblockActions();
      });
      this.listenTo(this.facets, "error", function(){
        self.originatingView && self.originatingView.unblockActions();
      });
      this.listenTo(this, "error", function(){
        self.originatingView && self.originatingView.unblockActions();
      });
      return new FacetCollection(availableFacets);
    },

    isTabable: function () {
      return !(this.$el.parent().hasClass('binf-hidden') || this.$el.parent().hasClass('csui-facetview-hidden'));
    },

    onRenderCollection: function () {
      this.trigger('refresh:tabindexes');
    },

    onBeforeDestroy: function () {
      $(document).off('mousedown', this._onRemoveKeyboardFocus);
    },

    applyFilter: function (facet) {
      this.trigger('apply:filter', facet.newFilter);
    },

    //Set active facet and disable all others.
    setActiveFacet: function (facet) {
      if (facet.selectItems.length > 0) {
        this.children.each(function (view) {
          if (view.getIndex() !== facet.getIndex()) {
            view.$el.find('.csui-facet-content').addClass('facet-disabled');
          }
        });
      }
      else {
        this.$el.find('.csui-facet-content').removeClass('facet-disabled');
      }
    },

    _updateScrollbar: function () {
      this.triggerMethod('update:scrollbar', this);
    }

  });

  _.extend(FacetPanelView.prototype, KeyEventNavigation);
  _.extend(FacetPanelView.prototype, ViewEventsPropagationMixin);
  return FacetPanelView;

});

csui.define('csui/controls/list/behaviors/list.view.keyboard.behavior',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/utils/log', 'csui/lib/marionette'
], function (module, _, $, log, Marionette) {
  'use strict';

  //
  // This behavior implements a default keyboard navigation for the ListView.
  // Include this behavior in your view (if derived from ListView) to enable keyboard navigation.
  //

  // keep the numbers in sequence for value increment/decrement computation
  var TabPosition = {
    none: -1,
    search: 0,
    open_perspective: 1,
    close_search: 1,
    list: 2,
    footer: 3
  };
  //open_perspective and close_search having same value, when one is visible other one is hidden
  // and same tab sequence will be maintained.

  function stopEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  return Marionette.Behavior.extend({

    constructor: function ListViewKeyboardBehavior(options, view) {
      Marionette.Behavior.prototype.constructor.apply(this, arguments);

      view.keyboardBehavior = this;
      this.tabableElements = [];

      var self = this;
      this.listenTo(view, 'show', function () {
        self.refreshTabableElements(view);
      });
      this.listenTo(view, 'childview:click:item childview:click:tree:header', function (item) {
        // clear the currently focused element
        var selIndex = view.selectedIndex;
        var selectedElem = view.getElementByIndex(selIndex);
        selectedElem && selectedElem.prop('tabindex', '-1');
        // set the new element tabindex
        view.currentTabPosition = TabPosition.list;
        view.selectedIndex = view.collection.indexOf(item.model);
        selectedElem = view.getElementByIndex(view.selectedIndex);
        selectedElem && selectedElem.prop('tabindex', '0');
      });
      this.listenTo(view, 'change:filterValue', function () {
        // when search filter changes, reset the focus element to the first item
        // change this if UX has a different design
        self.refreshTabableElements(view);
      });
      this.listenTo(view, 'before:collection:scroll:fetch', function () {
        view._beforeCollectionScrollFetch();
      });
      this.listenTo(view, 'collection:scroll:fetch', function () {
        view._afterCollectionScrollFetch();
      });

      _.extend(view, {

        _focusSearchButton: function (event) {
          this.currentTabPosition = TabPosition.search;
          var shiftTab = event && event.shiftKey;
          if (shiftTab) {
            return $(this.ui.searchButton);
          } else if (this._isSearchInputVisible()) {
            return $(this.ui.searchInput);
          } else {
            return $(this.ui.searchButton);
          }
        },

        _isSearchInputVisible: function () {
          return this.ui.searchInput.css &&
                 this.ui.searchInput.css('display') !== 'none';
        },

        _isOpenPerspectiveButtonFocusable: function() {
          return this.ui.openPerspectiveButton.css &&
                 this.ui.openPerspectiveButton.hasClass('cs-open-perspective-button') &&
                 this.ui.openPerspectiveButton.css('display') !== 'none';
        },

        _focusOpenPerspectiveButton:function(/*event*/) {
          this.currentTabPosition = TabPosition.open_perspective;
          return $(this.ui.openPerspectiveButton);
        },

        _focusCloseSearchButton:function(/*event*/) {
          this.currentTabPosition = TabPosition.close_search;
          return $(this.ui.searchCloseButton);
        },

        _focusList: function (event) {
          // set focus back to the last focused element
          this.currentTabPosition = TabPosition.list;
          if (this.selectedIndex < 0 || this.selectedIndex > this.collection.length - 1) {
            // safety check: set to the first item if selectedIndex is out-of-range
            this.selectedIndex = 0;
          }
          return this.getElementByIndex(this.selectedIndex, event);
        },

        _focusFooter: function () {
          this.currentTabPosition = TabPosition.footer;
          return $(this.ui.tileExpand);
        },

        currentlyFocusedElement: function (event) {
          if (this.isDestroyed) {
            return this.$el;
          }
          // Try restoring the focus to the previously focused region, especially when coming back from
          // tabable views like Dialogs, Global Message dialog etc.,
          var currentTabPosition = this._getCurrentTabPosition();
          if (_.isUndefined(currentTabPosition) || currentTabPosition === TabPosition.none) {
            // No previous KN state, hence first or last (if SHIFT used) element to acquire focus
            if (event && event.shiftTab) {
              if (this._isFooterVisible()) {
                currentTabPosition = TabPosition.footer;
              } else {
                currentTabPosition = TabPosition.list;
              }
            } else {
               if (!this.hideSearch) {
                currentTabPosition = TabPosition.search;
              } else {
                 if (this._enableOpenPerspective) {
                  currentTabPosition = TabPosition.open_perspective;
                 } else {
                  currentTabPosition = TabPosition.list;
                 }
              }
            }
          }
          return this._setFocusAtTabPosition(currentTabPosition);
        },

        _setFocusAtTabPosition: function(tabPosition) {
          switch(tabPosition) {
            case TabPosition.search:
                return this._focusSearchButton();
            case TabPosition.open_perspective:
            case TabPosition.close_search:
              return  this._isSearchInputVisible() ? this._focusCloseSearchButton() :  this._focusOpenPerspectiveButton();
            case TabPosition.list:
                return this._focusList();
            case TabPosition.footer:
                return this._focusFooter();
          }
        },

        _isFooterInFocus: function () {
          return this.currentTabPosition === TabPosition.footer || this.ui.tileExpand.is(":focus");
        },

        _isFooterVisible: function () {
          return this.ui.tileExpand.css &&
                  this.ui.tileExpand.css('display') !== 'none' &&
                  !this.ui.tileExpand.hasClass('binf-hidden') &&
                  this.ui.tileExpand.hasClass("tile-expand");
        },

        _isFooterFocusable: function() {
          return this._isFooterVisible();
        },

        isMoreActionsDropdownOpen: function () {
          return this.$el.find('.csui-table-cell-name-appendix .csui-table-actionbar' +
                               ' .binf-dropdown-menu').is(':visible');
        },

        _isSearchInFocus: function () {
          return this.currentTabPosition === TabPosition.search ||
                 this.ui.searchButton.is(":focus") ||
                 this.ui.searchInput.is(":focus") ||
                 this.ui.clearer.is(":focus");
        },

        _isCloseSearchInFocus: function () {
          return (this._isSearchInputVisible() && this.currentTabPosition === TabPosition.close_search) ||
                 this.ui.searchCloseButton.is(":focus");
        },

        _isOpenPerspectiveButtonInFocus: function () {
          return this.currentTabPosition === TabPosition.title ||
                 this.ui.headerTitle.is(":focus");
        },

        _isSearchButtonVisible: function () {
          return this.ui.searchButton.is(":visible") ||
                 (this.ui.searchButton.hasClass && !this.ui.searchButton.hasClass('binf-hidden'));
        },

        _isCloseSearchVisible: function () {
          return this.ui.searchCloseButton.is(":visible")  ||
                 (this.ui.searchCloseButton.hasClass && !this.ui.searchCloseButton.hasClass('binf-hidden'));
        },

        _isSearchButtonFocusable: function() {
          return this._isSearchButtonVisible();
        },

        _isCloseSearchFocusable: function() {
          return this._isCloseSearchVisible();
        },

        _beforeCollectionScrollFetch: function () {
          this.selectedIndexInFocus = false;
          if (this.selectedIndex >= 0 && this.selectedIndex < this.collection.length) {
            var $elem = this.getElementByIndex(this.selectedIndex);
            if ($elem && $elem.is(":focus")) {
              $elem.prop('tabindex', '-1');
              this.selectedIndexInFocus = true;
            }
          }
        },

        _afterCollectionScrollFetch: function () {
          if (this.selectedIndexInFocus === true &&
              this.selectedIndex >= 0 &&
              this.selectedIndex < this.collection.length) {
            setTimeout(this._setFocusToListElement.bind(this, this.selectedIndex), 100);
          }
        },

        _setFocusToListElement: function(selectedIndex) {
          var $elem = this.getElementByIndex(selectedIndex);
          if ($elem) {
            $elem.prop('tabindex', '0');
            $elem.focus();
          }
        },

        _onKeyInSearchArea: function (event) {
          if (this.ui.searchButton.is(":focus") || this.ui.searchCloseButton.is(":focus") || this.ui.clearer.is(":focus")) {
            stopEvent(event);
            $(event.target).trigger('click');
          } else if (this.ui.searchInput.is(":focus") && event.keyCode === 13) {  // Enter (13)
            stopEvent(event);
            this.filterChanged(event);
          }
        },

        _moveTo: function (event, $elem, $preElem) {
          stopEvent(event);
          this.trigger('before:keyboard:change:focus');
          $preElem && $preElem.prop('tabindex', '-1');
          $elem && $elem.prop('tabindex', '0');
          $elem && $elem.trigger('focus');
          this.trigger('changed:focus');
          this.trigger('after:keyboard:change:focus');
        },

        onKeyInView: function (event) {
          if (event.keyCode === 9) {  // tab (9)
            this._onTabKey(event);
          } else if (event.keyCode === 32 || event.keyCode === 13) {  // space (32) or enter (13)
            this._onEnterOrSpace(event);
          } else if (event.keyCode === 27) {  // escape (27)
            this._onEscape(event);
          }
        },

        _onTabKey: function (event) {
          if (this._isSearchInFocus() && !this.ui.searchButton.is(":focus") && !this.ui.searchCloseButton.is(":focus")) {
            return;
          }

          this._moveToTabPosition(event, this._getNextTabPosition(event));
        },

        _isListFocusable: function() {
          return this.collection.length > 0;
        },

        _getCurrentTabPosition: function() {
          var curPos = this.currentTabPosition;
          if (this._isSearchInFocus() && !this.ui.searchCloseButton.is(":focus")) {
            curPos = TabPosition.search;
          } else if (this._isOpenPerspectiveButtonInFocus()) {
            curPos = TabPosition.open_perspective;
          } else if (this._isFooterInFocus()) {
            curPos = TabPosition.footer;
          } else if (this._isCloseSearchInFocus()){
            curPos = TabPosition.close_search;
          }
          return curPos;
        },

        _isTabPositionFocusable: function(tabPosition) {
          switch(tabPosition) {
            case TabPosition.footer:
              return this._isFooterFocusable();
            case TabPosition.list:
              return this._isListFocusable();
            case TabPosition.open_perspective:
            case TabPosition.close_search:
              return  this._isSearchInputVisible() ? this._isCloseSearchFocusable() :  this._isOpenPerspectiveButtonFocusable();
            case TabPosition.search:
              return this._isSearchButtonFocusable();
          }
          return false;
        },

        _getFirstTabPosition: function() {
          return TabPosition.search;
        },

        _getLastTabPosition: function() {
          return TabPosition.footer;
        },

        _getValidTabPosition: function (curPos, shiftKey) {
          var i,
              firstTabPosition = this._getFirstTabPosition(),
              lastTabPosition  = this._getLastTabPosition();

          if (shiftKey) {
            for (i = lastTabPosition; i >= firstTabPosition; i--) {
              if (curPos === i && !this._isTabPositionFocusable(i)) {
                curPos--;
              }
            }
          } else {
            for (i = firstTabPosition; i <= lastTabPosition; i++) {
              if (curPos === i && !this._isTabPositionFocusable(i)) {
                curPos++;
              }
            }
          }

          if (curPos < firstTabPosition || curPos > lastTabPosition) {
            return TabPosition.none;
          }

          return curPos;
        },

        _getNextTabPosition: function (event) {
          var curPos = this._getCurrentTabPosition(),
              shiftKey = event.shiftKey;
          if (curPos === TabPosition.none) {
            return;
          }
          shiftKey ? curPos-- : curPos++;
          return this._getValidTabPosition(curPos, shiftKey);
        },

        _moveToTabPosition: function (event, curPos) {
          var func;
          switch (curPos) {
            case TabPosition.search:
              func = this._focusSearchButton;
              break;
            case TabPosition.open_perspective:
            case TabPosition.close_search:
              func = this._isSearchInputVisible() ? this._focusSearchButton :  this._focusOpenPerspectiveButton;
              break;
            case TabPosition.list:
              func = this._focusList;
                break;
            case TabPosition.footer:
              func = this._focusFooter;
              break;
          }

          // We are protecting against widgets that do not return valid tab position
          // element. Or if any of the functions does not return a valid element. If they
          // do return invalid element we just skip moving to the next element in the view list
          // and we exit the navigation from this widget. At the time of this change, the 'My Shares'
          // widget did not override the getElementByIndex and the default getElementByIndex in the list.view.js
          // was failing to find an element to stop at.
          if (func) {
              var element = func.apply(this, event);
              if (element && element.length > 0) {
                return this._moveTo(event, element);
              }
          }
        },

        _onEnterOrSpace: function (event) {
          if (this._isSearchInFocus() || this._isCloseSearchInFocus()) {
            this.currentTabPosition = TabPosition.search;
            this._onKeyInSearchArea(event);
          } else {
            stopEvent(event);
            $(event.target).trigger('click');
          }
        },

        _onEscape: function (event) {
          if (this.isMoreActionsDropdownOpen()) {
            return false;
          } else if (this._isSearchInFocus() || this._isCloseSearchInFocus()) {
            var bIsSearchVisible = this.ui.searchInput.is(":visible");
            if (bIsSearchVisible) {
              stopEvent(event);
              this.closeSearchClicked(event);
              setTimeout(_.bind(function () {
                this.ui.searchButton.prop('tabindex', '0');
                this.ui.searchButton.focus();
              }, this), 250);
            }
          }
        },

        onKeyDown: function (event) {
          if (this._isSearchInFocus() || this._isFooterInFocus() || this._isCloseSearchInFocus()) {
            this.onKeyInView(event);
            return;
          }

          var $preElem;  // get this $preElem before any _select*() method call
          switch (event.which) {
          case 33: // page up (30)
          case 36: // home (36)
            $preElem = this.getElementByIndex(this.selectedIndex);
            this._moveTo(event, this._selectFirstListElement(), $preElem);
            break;
          case 34: // page down (34)
          case 35: // end (35)
            $preElem = this.getElementByIndex(this.selectedIndex);
            this._moveTo(event, this._selectLastListElement(event), $preElem);
            break;
          case 38: // arrow up (38)
            if (this.selectedIndex > 0) {
              $preElem = this.getElementByIndex(this.selectedIndex);
              this._moveTo(event, this._selectPreviousListElement(event), $preElem);
            } else {
              // do not get $preElem because it would change the internal position index
              stopEvent(event);
            }
            break;
          case 40: // arrow down (40)
            if (this.selectedIndex < this.collection.length - 1) {
              $preElem = this.getElementByIndex(this.selectedIndex);
              this._moveTo(event, this._selectNextListElement(), $preElem);
            } else {
              // do not get $preElem because it would change the internal position index
              stopEvent(event);
            }
            break;
          default:
            this.onKeyInView(event);
            return; // exit this handler for other keys
          }
        },

        _selectFirstListElement: function () {
          this.selectedIndex = 0;
          return this.getElementByIndex(this.selectedIndex);
        },

        _selectLastListElement: function (event) {
          // try from the last item to find the last focusable item
          var focusableItem;
          var currentIndex = this.selectedIndex;
          if (currentIndex < 0 || currentIndex >= this.collection.length) {
            currentIndex = 0;
          }
          var focusableIndex = this.collection.length;
          while (focusableIndex > currentIndex && !focusableItem) {
            focusableIndex--;
            focusableItem = this.getElementByIndex(focusableIndex, event);
          }
          if (focusableItem) {
            this.selectedIndex = focusableIndex;
            return focusableItem;
          }
          return this.getElementByIndex(this.selectedIndex);  // no change of focus
        },

        _selectNextListElement: function () {
          // keep trying next item until find a focusable item
          var focusableItem;
          var focusableIndex = this.selectedIndex;
          if (focusableIndex < 0 || focusableIndex >= this.collection.length) {
            focusableIndex = -1;
          }
          while (focusableIndex < this.collection.length - 1 && !focusableItem) {
            focusableIndex++;
            focusableItem = this.getElementByIndex(focusableIndex);
          }
          if (focusableItem) {
            this.selectedIndex = focusableIndex;
            return focusableItem;
          }
          return this.getElementByIndex(this.selectedIndex);  // no change of focus
        },

        _selectPreviousListElement: function (event) {
          if (this.selectedIndex > 0) {
            this.selectedIndex--;
          }
          return this.getElementByIndex(this.selectedIndex, event);
        }

      });

    }, // constructor

    refreshTabableElements: function (view) {
      log.debug('ListViewKeyboardBehavior::refreshTabableElements ' + view.constructor.name) &&
      console.log(log.last);
      this.view.currentTabPosition = TabPosition.none;
      this.view.selectedIndex = -1;
    }

  });

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/list/impl/emptylist',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"cs-emptylist-placeholder\"></div>\r\n<div class=\"cs-emptylist-text\"><p class=\"csui-no-result-message\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"text") || (depth0 != null ? lookupProperty(depth0,"text") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"text","hash":{},"loc":{"start":{"line":2,"column":72},"end":{"line":2,"column":80}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"text") || (depth0 != null ? lookupProperty(depth0,"text") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"text","hash":{},"loc":{"start":{"line":2,"column":82},"end":{"line":2,"column":90}}}) : helper)))
    + "</p></div>\r\n<div class=\"cs-emptylist-placeholder\"></div>\r\n";
}});
Handlebars.registerPartial('csui_controls_list_impl_emptylist', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/list/impl/emptylist',[],function(){});
// Shows a list of items
csui.define('csui/controls/list/emptylist.view',['csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'hbs!csui/controls/list/impl/emptylist',
  'i18n!csui/controls/list/impl/nls/lang',
  'css!csui/controls/list/impl/emptylist'
], function (_, $, Marionette, emptyListTemplate, lang) {


  var EmptyListView = Marionette.ItemView.extend({

    constructor: function EmptyListView() {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    },

    className: 'cs-emptylist-container',

    template: emptyListTemplate,

    templateHelpers: function() {
      return {
        text: this.options.text || lang.emptyViewDefaultText
      };
    }

  });

  return EmptyListView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/list/impl/list',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <div class=\"tile-type-icon\">\r\n      <span class=\"icon "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":5,"column":24},"end":{"line":5,"column":32}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"expandAria") || (depth0 != null ? lookupProperty(depth0,"expandAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"expandAria","hash":{},"loc":{"start":{"line":5,"column":46},"end":{"line":5,"column":60}}}) : helper)))
    + "\"></span>\r\n    </div>\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"imageUrl") : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"loc":{"start":{"line":8,"column":4},"end":{"line":13,"column":11}}})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "      <div class=\"tile-type-image "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"imageClass") || (depth0 != null ? lookupProperty(depth0,"imageClass") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"imageClass","hash":{},"loc":{"start":{"line":9,"column":34},"end":{"line":9,"column":48}}}) : helper)))
    + "\">\r\n      <span class=\"tile-type-icon tile-type-icon-img\"><img src=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"imageUrl") || (depth0 != null ? lookupProperty(depth0,"imageUrl") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"imageUrl","hash":{},"loc":{"start":{"line":10,"column":64},"end":{"line":10,"column":76}}}) : helper)))
    + "\"\r\n                                                           alt=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"expandAria") || (depth0 != null ? lookupProperty(depth0,"expandAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"expandAria","hash":{},"loc":{"start":{"line":11,"column":64},"end":{"line":11,"column":78}}}) : helper)))
    + "\"></span>\r\n      </div>\r\n";
},"6":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <span class=\"icon-search-placeholder\">"
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"iconName":"csui_action_search32"},"loc":{"start":{"line":23,"column":46},"end":{"line":23,"column":91}}})) != null ? stack1 : "")
    + "</span>\r\n        <input class=\"search\" type=\"search\" placeholder=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"searchPlaceholder") || (depth0 != null ? lookupProperty(depth0,"searchPlaceholder") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"searchPlaceholder","hash":{},"loc":{"start":{"line":24,"column":57},"end":{"line":24,"column":78}}}) : helper)))
    + "\"\r\n               title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"searchTitle") || (depth0 != null ? lookupProperty(depth0,"searchTitle") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"searchTitle","hash":{},"loc":{"start":{"line":25,"column":22},"end":{"line":25,"column":37}}}) : helper)))
    + "\">\r\n        <span class=\"clearer csui-icon formfield_clear\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"clearAll") || (depth0 != null ? lookupProperty(depth0,"clearAll") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"clearAll","hash":{},"loc":{"start":{"line":26,"column":63},"end":{"line":26,"column":75}}}) : helper)))
    + "\"\r\n              aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"clearAllAria") || (depth0 != null ? lookupProperty(depth0,"clearAllAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"clearAllAria","hash":{},"loc":{"start":{"line":27,"column":26},"end":{"line":27,"column":42}}}) : helper)))
    + "\" role=\"button\"></span>\r\n        <span class=\"fadeout csui-icon\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"searchTitle") || (depth0 != null ? lookupProperty(depth0,"searchTitle") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"searchTitle","hash":{},"loc":{"start":{"line":28,"column":47},"end":{"line":28,"column":62}}}) : helper)))
    + "\"></span>\r\n";
},"8":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <div title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"searchTooltip") || (depth0 != null ? lookupProperty(depth0,"searchTooltip") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"searchTooltip","hash":{},"loc":{"start":{"line":34,"column":20},"end":{"line":34,"column":37}}}) : helper)))
    + "\" class=\"cs-icon-container cs-search-button\"\r\n             role=\"button\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"searchAria") || (depth0 != null ? lookupProperty(depth0,"searchAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"searchAria","hash":{},"loc":{"start":{"line":35,"column":39},"end":{"line":35,"column":53}}}) : helper)))
    + "\" aria-expanded=\"false\">\r\n          "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"states":"true","iconName":"csui_action_search32"},"loc":{"start":{"line":36,"column":10},"end":{"line":36,"column":69}}})) != null ? stack1 : "")
    + "\r\n        </div>\r\n";
},"10":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <div title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"openPerspectiveAria") || (depth0 != null ? lookupProperty(depth0,"openPerspectiveAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"openPerspectiveAria","hash":{},"loc":{"start":{"line":40,"column":20},"end":{"line":40,"column":43}}}) : helper)))
    + "\" class=\"cs-icon-container cs-open-perspective-button\"\r\n             role=\"button\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"openPerspectiveAria") || (depth0 != null ? lookupProperty(depth0,"openPerspectiveAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"openPerspectiveAria","hash":{},"loc":{"start":{"line":41,"column":39},"end":{"line":41,"column":62}}}) : helper)))
    + "\">\r\n          "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"states":"true","iconName":"csui_action_expand32"},"loc":{"start":{"line":42,"column":10},"end":{"line":42,"column":69}}})) != null ? stack1 : "")
    + "\r\n        </div>\r\n";
},"12":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <div title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"searchCloseTooltip") || (depth0 != null ? lookupProperty(depth0,"searchCloseTooltip") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"searchCloseTooltip","hash":{},"loc":{"start":{"line":49,"column":20},"end":{"line":49,"column":42}}}) : helper)))
    + "\" class=\"cs-icon-container cs-search-close-button\"\r\n             role=\"button\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"searchCloseAria") || (depth0 != null ? lookupProperty(depth0,"searchCloseAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"searchCloseAria","hash":{},"loc":{"start":{"line":50,"column":39},"end":{"line":50,"column":58}}}) : helper)))
    + "\" aria-expanded=\"true\">\r\n          "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"states":"true","iconName":"csui_action_close_mid"},"loc":{"start":{"line":51,"column":10},"end":{"line":51,"column":70}}})) != null ? stack1 : "")
    + "\r\n        </div>\r\n";
},"14":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <div class=\"tile-footer\">\r\n    <div class=\"cs-more tile-expand\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"expandTitle") || (depth0 != null ? lookupProperty(depth0,"expandTitle") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"expandTitle","hash":{},"loc":{"start":{"line":66,"column":44},"end":{"line":66,"column":59}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"expandAria") || (depth0 != null ? lookupProperty(depth0,"expandAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"expandAria","hash":{},"loc":{"start":{"line":66,"column":73},"end":{"line":66,"column":87}}}) : helper)))
    + "\"\r\n         role=\"button\">\r\n      "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"states":"true","iconName":"csui_action_expand32"},"loc":{"start":{"line":68,"column":6},"end":{"line":68,"column":65}}})) != null ? stack1 : "")
    + "\r\n    </div>\r\n  </div>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"tile-header\">\r\n\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"icon") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"loc":{"start":{"line":3,"column":2},"end":{"line":14,"column":9}}})) != null ? stack1 : "")
    + "\r\n  <div class=\"tile-title\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":16,"column":33},"end":{"line":16,"column":42}}}) : helper)))
    + "\">\r\n    <h2 class=\"csui-heading\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":17,"column":29},"end":{"line":17,"column":38}}}) : helper)))
    + "</h2>\r\n  </div>\r\n\r\n  <div class=\"tile-controls\">\r\n      <div class=\"search-box\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"hideSearch") : depth0),{"name":"if","hash":{},"fn":container.noop,"inverse":container.program(6, data, 0),"loc":{"start":{"line":22,"column":7},"end":{"line":29,"column":15}}})) != null ? stack1 : "")
    + "      </div>\r\n\r\n    <div class=\"tile-icons\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"hideSearch") : depth0),{"name":"if","hash":{},"fn":container.noop,"inverse":container.program(8, data, 0),"loc":{"start":{"line":33,"column":6},"end":{"line":38,"column":13}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableOpenPerspective") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"loc":{"start":{"line":39,"column":6},"end":{"line":44,"column":13}}})) != null ? stack1 : "")
    + "    </div>\r\n\r\n    <div class=\"close-search-icon\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"hideSearch") : depth0),{"name":"if","hash":{},"fn":container.noop,"inverse":container.program(12, data, 0),"loc":{"start":{"line":48,"column":6},"end":{"line":53,"column":13}}})) != null ? stack1 : "")
    + "    </div>\r\n  </div>\r\n\r\n</div>\r\n\r\n<div class=\"tile-content\" role=\"listbox\">\r\n  <div class=\"binf-list-group\"></div>\r\n  <div class=\"binf-sr-only\" aria-live=\"off\"></div>\r\n</div>\r\n\r\n"
    + ((stack1 = lookupProperty(helpers,"unless").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableOpenPerspective") : depth0),{"name":"unless","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"loc":{"start":{"line":64,"column":0},"end":{"line":71,"column":11}}})) != null ? stack1 : "")
    + "\r\n";
}});
Handlebars.registerPartial('csui_controls_list_impl_list', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/list/impl/list',[],function(){});
// Shows a list of items
csui.define('csui/controls/list/list.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/utils/base', 'csui/controls/list/emptylist.view',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior', 'i18n',
  'hbs!csui/controls/list/impl/list', 'i18n!csui/controls/list/impl/nls/lang',
  'css!csui/controls/list/impl/list', 'csui/lib/jquery.ui/js/jquery-ui'
], function (_, $, Marionette, base, EmptyListView,
    PerfectScrollingBehavior, i18n, listTemplate, lang) {

  var ListItemView = Marionette.ItemView.extend({

    constructor: function ListItemView() {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
    }

  });

  var ListView = Marionette.CompositeView.extend({

    direction: !!i18n.settings.rtl ? 'right' : 'left',

    constructor: function ListView(options) {
      options || (options = {});
      _.defaults(options, {
        filterValue: ''
      });

      // Provide the perfect scrollbar to every list view by default
      // (Behaviors cannot be inherited; add the PerfectScrolling
      //  to the local clone of the descendant's behaviors.)
      if (!(this.behaviors && _.any(this.behaviors, function (behavior, key) {
            return behavior.behaviorClass === PerfectScrollingBehavior;
          }))) {
        this.behaviors = _.extend({
          PerfectScrolling: {
            behaviorClass: PerfectScrollingBehavior,
            contentParent: '> .tile-content',
            suppressScrollX: true,
            // like bottom padding of container, otherwise scrollbar is shown always
            scrollYMarginOffset: 15
          }
        }, this.behaviors);
      }

      Marionette.CompositeView.prototype.constructor.call(this, options);

      // let's child view decide the key's values, if not, master view provides the default values.
      var th = this.templateHelpers(),
          currentListTitle = !!th && !!th.title ? th.title.toLowerCase() :
                             !!options && !!options.data && !!options.data.title ? options.data.title : '',
          messages         = {
            'title': currentListTitle,
            'expandTitle': lang.expandView,
            'expandAria': _.str.sformat(lang.expandAria, currentListTitle),
            'searchTooltip': lang.searchView,
            'searchCloseTooltip': lang.collapseSearch,
            'searchAria': _.str.sformat(lang.searchAria, currentListTitle),
            'searchCloseAria': lang.collapseAria,
            'collapseSearchTooltip': lang.collapseSearch,
            'openPerspectiveAria': lang.openPerspective,
            'openPerspectiveTooltip': lang.openPerspectiveTooltip
          };
      this.templateHelpers = _.defaults(th, messages, lang);
      this.listenToOnce(this.collection, "sync",function() {
        this.$el.removeClass("initialLoading");
      });

      this.listenToOnce(this.collection, "error", _.bind(this.handleError, this));
      this.listenToOnce(this.completeCollection, "error", _.bind(this.handleError, this));
      this.listenTo(this, 'doc:preview:generic:actions', this._highlightRow);
    },

    /**
     * The handleError method provides default error handling for list.view.
     * Can be overridden in custom views for different error handling.
     */

    handleError: function () {
      this.errorExists = true;
      this.$el.addClass('csui-list-view-error');
    },

    templateHelpers: function () {
    },

    setValidator: function () {
      this.validator = setInterval(_.bind(this.validateInput, this), 10);
    },

    unsetValidator: function () {
      clearInterval(this.validator);
    },

    className: 'cs-list tile content-tile initialLoading',
    template: listTemplate,

    childViewContainer: '.binf-list-group',
    childView: ListItemView,
    childViewOptions: function () {
      return {
        template: this.options.childViewTemplate
      };
    },

    emptyView: EmptyListView,

    ui: {
      placeholderSearchIcon: '.icon-search-placeholder',
      headerTitle: '.tile-title',
      tileIcon: '.tile-icons',
      searchIcon: '.cs-search-icon',
      searchButton: '.cs-search-button',
      searchCloseButton: '.cs-search-close-button',
      searchBox: '.search-box',
      searchInput: '.search',
      clearer: '.clearer',
      tileExpand: '.tile-expand',
      fadeout: '.fadeout',
      tileHeader: '.tile-header',
      openPerspectiveButton: '.cs-open-perspective-button',
      openPerspectiveIcon: '.icon-perspective-open',
      tileControls: '.tile-controls'
    },

    events: {
      'keydown': 'onKeyDown'
    },

    triggers: {
      'click .tile-header': 'before:click:header',
      'click @ui.openPerspectiveButton': 'click:open:perspective'
    },

     /**
     * This method highlight's the row for which document is getting to be previewed.
     *
     * @param targetRow
     * @private
     */
      _highlightRow: function (targetNode, HIGHLIGHT_CLASS_NAME) {
        $('.' + HIGHLIGHT_CLASS_NAME).removeClass(HIGHLIGHT_CLASS_NAME);
        var rowIndex =  _.findIndex(this.collection.models, function (node) {
          return node.get('id') === targetNode.get("id");
        });
        // ensure current viewing document exists in current page, then only high-light the row.
        // if the document exists in previous or next pages, let's do nothing for now.
        if (rowIndex !== -1) {
          var child = this.$childViewContainer;
          var target = child && child.children();
          var targetRow = target && target.eq(rowIndex);
          targetRow && targetRow.addClass(HIGHLIGHT_CLASS_NAME);
        }
      },

    // empty base method to be overridden by derived class for keyboard navigation if needed
    onKeyDown: function (event) {
      // don't add any code here
    },

    onBeforeClickHeader: function () {
      if (this.errorExists) {
        return;
      }
      this.triggerMethod('click:header');
    },

    onRender: function () {
      this.ui.placeholderSearchIcon.hide();
      this.ui.searchInput.hide();
      this.ui.clearer.toggle(false);

      this.ui.placeholderSearchIcon.on('click', _.bind(this.placeholderSearchIconClicked, this));
      this.ui.searchButton.on('click', _.bind(this.searchClicked, this));
      this.ui.searchCloseButton.on('click', _.bind(this.closeSearchClicked, this));
      this.ui.searchBox.on('click', _.bind(this.searchBoxClicked, this));
      this.ui.clearer.on('click', _.bind(this.searchFieldClearerClicked, this));
      this.ui.searchInput.on('input', _.bind(this.searchInput, this));

      this.srOnly = this.$el.find('.tile-content .binf-sr-only');
      this.tileHeader = this.$el.find('.tile-header');

      this.titleId = _.uniqueId("dlgTitle");
      this.$(this.ui.headerTitle).find('.csui-heading').attr('id', this.titleId);
      this.$(this.tileHeader).parent().attr('role', 'region').attr('aria-labelledby', this.titleId);
      this.$el.find('.tile-content').attr('aria-labelledby', this.titleId);

      // activate/deactivate the screen reader summary in the content when the wrapper is entered/left
      this.$el.on('focusin', _.bind(this.focusinAria, this));
      this.$el.on('focusout', _.bind(this.focusoutAria, this));

      base.isAppleMobile() === false && this._enableOpenPerspective && this._addActivationEventHandlers();
    },

    _addActivationEventHandlers: function () {
      var el = this.$el;
      el.addClass('cs-no-expanding');
      el.on('mouseover', function () {el.addClass('cs-hover')})
          .on('mouseleave', function () {el.removeClass('cs-hover cs-mousedown')})
          .on('mousedown', function () {el.addClass('cs-mousedown')})
          .on('mouseup', function () {el.removeClass('cs-mousedown')})
          .on('focusin', function () {el.addClass('cs-has-focus')})
          .on('focusout', function () {el.removeClass('cs-has-focus')});

      this.ui.tileHeader.on('mouseover', function () {el.addClass('cs-tile-header-hover')})
          .on('mouseleave', function () {el.removeClass('cs-tile-header-hover')});

    },

    focusOutHandle: undefined,

    focusinAria: function () {
      if (this.focusOutHandle) {
        clearTimeout(this.focusOutHandle.handle);
        this.focusOutHandle = undefined;
      } else {
        this.srOnly.attr('aria-live', 'polite');
        this.setElementsVisibleAria();
      }
    },

    focusoutAria: function () {
      var that = this;
      this.focusOutHandle = setTimeout(function() {
        that.srOnly.attr('aria-live', 'off');
        that.srOnly.html('');
        that.focusOutHandle = undefined;
      }, 25);
    },

    searchBoxClicked: function (event) {
      event.stopPropagation();
    },

    searchFieldClearerClicked: function () {
      this.ui.searchInput.val('');
      this.filterChanged();
      this.ui.searchInput.trigger('focus');
    },

    placeholderSearchIconClicked: function () {
      this.ui.searchInput.trigger('focus');
    },

    isSearchOpen: function () {
      return this.ui.searchInput.is && this.ui.searchInput.is(":visible");
    },

    searchClicked: function (event) {
      this.ui.searchInput.val('');
      this.ui.clearer.toggle(false);

          this.ui.headerTitle.hide();
          this.ui.searchInput.show('blind', {direction: this.direction}, 200,_.bind(function(){
            this.ui.searchInput.prop('tabindex', '0');
            this.ui.searchInput.trigger('focus');
          },this));
          this.setValidator();
          this.ui.placeholderSearchIcon.show('fast');
          this.$(this.ui.searchIcon).addClass('icon-search-hide');
          this.$(this.ui.searchCloseButton).addClass('icon-search-hide');
          this.ui.tileIcon.fadeOut();
          this.ui.tileControls.addClass('search-enabled');
          this.ui.searchCloseButton.fadeIn();
          this.ui.searchCloseButton.prop('tabindex', '0');
          //this timeout should be greater then this.ui.searchInput.show animation time
          this.ui.fadeout.show(250,_.bind(function(){
            this._resetFilter();
          },this));

      event && event.stopPropagation();
    },

    closeSearchClicked: function (event) {
        this.ui.searchInput.val('');
        this.ui.clearer.toggle(false);
        this.ui.fadeout.hide();
        this.ui.placeholderSearchIcon.hide();
        this.ui.searchCloseButton.fadeOut(_.bind(function(){
          this.ui.tileIcon.fadeIn();
          this.ui.headerTitle.show('fade',_.bind(function(){
            this.ui.searchButton.prop('tabindex', '0');
            this.ui.searchButton.trigger('focus');
            this._resetFilter();
          },this));
        },this));
        this.ui.tileControls.removeClass('search-enabled');
        this.unsetValidator();
        this.$(this.ui.searchIcon).removeClass('icon-search-hide');
        this.$(this.ui.searchCloseButton).removeClass('icon-search-hide');
        this.ui.searchInput.hide('blind', {direction: this.direction}, 200);
      event && event.stopPropagation();
    },

    validateInput: function () {
      if (!this.ui.searchInput.val) {
        return;
      }
      var bIsFilled = this.ui.searchInput.val && !!this.ui.searchInput.val().length;
      this.ui.clearer.toggle(bIsFilled);
      this.ui.clearer.prop('tabindex', bIsFilled ? '0' : '-1');
    },

    searchInput: function (event) {
      // performance enhancement: queue key input and change filter when user slows down typing
      if (this.keyInputTimer) {
        clearTimeout(this.keyInputTimer);
      }
      this.keyInputTimer = setTimeout(_.bind(function () {
        this.keyInputTimer = undefined;
        this.filterChanged();
      }, this), 300);
    },

    filterChanged: function () {
      this.options.filterValue = this.ui.searchInput.val();
      this.trigger('change:filterValue');
      this.setElementsVisibleAria();
    },

    setElementsVisibleAria: function () {
      // provide the number of visible elements to the screenreader
      var numElements = this.collection ? this.collection.size() : '0';
      this.srOnly.text(_.str.sformat(lang.elementsVisibleAria, numElements, this.templateHelpers.title));
    },

    _resetFilter: function () {
      this.ui.searchInput.val('');
      // Filter changing event is triggered only by keyboard and mouse
      this.filterChanged();
    },

    // return the jQuery list item element by index for keyboard navigation use
    getElementByIndex: function (index) {
      if (isNaN(index) || (index < 0)) {
        return null;
      }
      var targetEle   = this.showInlineActionBar ? 'div.csui-item-standard:nth-child({0})' :
                        'div a:nth-child({0})',
          nthChildSel = _.str.sformat(targetEle, index + 1),
          $item       = this.$(nthChildSel);

      // Protection against widgets that do not have an 'a' tag. We will look for the following
      // selectors for the next tab.
      // First look for the first div tag inside the a tag that has the role="option" and does not have .binf-hidden
      // If that fails, look for any tag that has role="option"
      if ($item.length === 0) {
        $item = this._lookForElementToTabTo(index, ['[role="option"] > div:not(.binf-hidden)', '[role="option"]']);
      }
      if ($item) {
        return $($item[0]);
      }
    },

    _lookForElementToTabTo: function (index, selectors) {
      var $item, listElement = this.el;
      selectors && selectors.some(function (selector) {
        var elements = listElement.querySelectorAll(selector);
        if (elements && elements.length > index) {
          return ($item = $(elements[index]));
        }
      });
      return $item;
    }

  });

  return ListView;

});

csui.define('csui/controls/list/list.state.view',[
  'csui/behaviors/collection.state/collection.state.view',
  'hbs!csui/controls/list/impl/emptylist',
  'css!csui/controls/list/impl/emptylist'
], function (CollectionStateView, emptyListTemplate) {
  'use strict';

  var ListStateView = CollectionStateView.extend({

    constructor: function ListStateView() {
      CollectionStateView.prototype.constructor.apply(this, arguments);
    },

    className: 'cs-emptylist-container ' + CollectionStateView.prototype.className,

    template: emptyListTemplate,

    serializeData: function () {
      var data = CollectionStateView.prototype.serializeData.apply(this, arguments);
      return {
        text: data.state === "loading"?"":data.message
      };
    }

  });

  return ListStateView;

});

csui.define('csui/models/node.children2.lite/server.adaptor.mixin',[
  'csui/lib/underscore', 'csui/utils/url',
  'csui/models/browsable/v1.request.mixin',
  'csui/models/browsable/v2.response.mixin',
  'csui/models/mixins/appcontainer/appcontainer.mixin'
], function (_, Url, BrowsableV1RequestMixin, BrowsableV2ResponseMixin, AppContainerMixin) {
  'use strict';

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      BrowsableV2ResponseMixin.mixin(prototype);
      BrowsableV1RequestMixin.mixin(prototype);
      AppContainerMixin.mixin(prototype);

      return _.extend(prototype, {
        makeServerAdaptor: function (options) {
          this.useSpecialPaging = options.useSpecialPaging;
          this.makeBrowsableV1Request(options)
              .makeBrowsableV2Response(options)
              .makeAppContainer(options);
          return this;
        },

        url: function () {
          var url;
          var apiUrl = new Url(this.node.connector.connection.url).getApiBase(2);

          var query;
          if (this.useSpecialPaging) {
            // special fast browse paging
            url = Url.combine(apiUrl, 'app/container', this.node.get('id'), 'page');
            // needs less parameters
            var resourceFieldsQuery = {
              fields: _.without(this.getResourceFieldsUrlQuery().fields, 'properties')
            };
            query = Url.combineQueryString(
                this.getBrowsableUrlQuery(),
                resourceFieldsQuery
            );
          } else {
            // nodes-based paging
            url = Url.combine(apiUrl, 'nodes', this.node.get('id'), 'nodes');
            query = Url.combineQueryString(
                this.getBrowsableUrlQuery(),
                this.getResourceFieldsUrlQuery(),
                this.getExpandableResourcesUrlQuery(),
                this.getStateEnablingUrlQuery(),
                this.getAdditionalResourcesUrlQuery(),
                this.getRequestedCommandsUrlQuery()
            );
          }

          return Url.appendQuery(url, query);
        },

        parse: function (response, options) {
          if (this.useSpecialPaging) {
            var self = this;
            response.results = response.results.map(function (props) {
              return self.massageResponse(props);
            });
          }

          this.parseBrowsedState(response, options);
          return this.parseBrowsedItems(response, options);
        }
      });
    }
  };

  return ServerAdaptorMixin;
});
csui.define('csui/models/node.children2.lite/node.children2.lite',[
  'module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/models/node/node.model', 'csui/models/node.children2/node.children2',
  'csui/models/node.children2.lite/server.adaptor.mixin'
], function (module, _, Backbone, NodeModel, NodeChildren2Collection, ServerAdaptorMixin) {
  'use strict';

  var config = module.config();
  _.defaults(config, {
    defaultPageSize: 10
  });

  var NodeChildren2LiteCollection = NodeChildren2Collection.extend({
    model: NodeModel,

    constructor: function NodeChildren2LiteCollection(models, options) {
      options = _.defaults({}, options, {
        top: config.defaultPageSize
      }, options);

      NodeChildren2Collection.prototype.constructor.call(this, models, options);
    }

  });

  ServerAdaptorMixin.mixin(NodeChildren2LiteCollection.prototype);

  return NodeChildren2LiteCollection;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/treebrowse/impl/tree.node.error',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<span class=\"csui-icon-group csui-tree-error-node-icon\">\r\n  "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"size":"xsmall","iconName":"csui_action_close32"},"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":60}}})) != null ? stack1 : "")
    + "\r\n</span>";
}});
Handlebars.registerPartial('csui_controls_treebrowse_impl_tree.node.error', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/treebrowse/impl/tree.node.error.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/marionette',
  'hbs!csui/controls/treebrowse/impl/tree.node.error'
], function ($, _, Marionette, TreeNodeErrorTemplate) {
  'use strict';

  return Marionette.ItemView.extend({

    tagName: 'span',
    className: 'csui-tree-error-node-icon-container',
    template: TreeNodeErrorTemplate,

    constructor: function TreeNodeErrorView(options) {
      options = options || {};
      Marionette.ItemView.prototype.constructor.call(this, options);
    }

  });
});

csui.define('csui/controls/treebrowse/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/treebrowse/impl/nls/root/lang',{
  ShowMore : "Show more",
  ShowLess: "Show less",
  tooltipTreeNodeExpand: 'Expand',
  tooltipTreeNodeCollapse: 'Collapse',
  expandNetworkError: 'Unable to open the "{0}" node as the connection is lost.',
  showMoreNetworkError: 'Unable to open the link as the connection is lost.',
  nodeDoesNotExistMsg: 'Node does not exist.'
});


/*
 * FancyTree overrides for csui
 * 1. Add 'level' information in DOM
 * 2. Add padding for indentation at 'fancytree-node' level so that full row selection is possible
 * 3. Add icon placeholder for paging nodes, so that carets can be shown
 * 4. Add icon placeholder for "loading" node so that CSS animated spinner can be used
 * 5. When tree control receives focus then focus the required node
 * 6. Add support for "disabled" nodes
 */

csui.define('csui/controls/treebrowse/impl/fancytree.overrides',[
  'csui/lib/jquery',
  'i18n!csui/controls/treebrowse/impl/nls/lang',
  'csui/lib/fancytree/jquery.fancytree'
], function ($, lang) {
  'use strict';

  $.ui.fancytree.registerExtension({
    name: 'csui-overrides',
    version: '1.0.0',

    // Default options
    options: {
      rootIndent: 0,
      levelIndent: 12
    },

    nodeRenderStatus: function (ctx) {
      var res,
        node = ctx.node,
        spanEl = $(node.span),
        level = node.getLevel(),
        expanded = node.isExpanded(),
        extOpts = ctx.options['csui-overrides'],
        $statusEl = $(node[ctx.tree.statusClassPropName]),
        $ariaEl = $(node.tr || node.li),
        $expander = spanEl.find('.fancytree-expander');

      // Call parent method
      res = this._super(ctx);

      $expander.attr('title', (expanded ? lang.tooltipTreeNodeCollapse : lang.tooltipTreeNodeExpand));

      if (node.data.disabled === true) {
        $statusEl.addClass('fancytree-disabled');
        if (ctx.options.aria) {
          $ariaEl.attr('aria-disabled', true);
        }
      } else if (ctx.options.aria) {
        $ariaEl.attr('aria-disabled', false);
      }

      $ariaEl.addClass('fancytree-level-' + level);
      if (ctx.tree.options.rtl) {
        spanEl.css({
          paddingRight: ((level - 1) * extOpts.levelIndent) + extOpts.rootIndent
        });
      } else {
        spanEl.css({
          paddingLeft: ((level - 1) * extOpts.levelIndent) + extOpts.rootIndent
        });
      }
      // Add icon placeholder for paging nodes
      if (node.isPagingNode()) {
        spanEl.find('.fancytree-title:not(:has(.fancytree-paging-icon))').append(
          '<span class="fancytree-paging-icon ' + (node.data.showMore ? 'show-more' : 'show-less') + '">');
      }

      // Add DOM elements to support CSS spinner for loading nodes
      if (node._isLoading === true) {
        spanEl.find('.fancytree-expander').append('<div class="fancytree-loader"></div>');
      } else {
        spanEl.find('.fancytree-expander').empty();
      }

      //Add error classes to support CSS
      if (node.data.isErrorNode === true) {
        spanEl.addClass('fancytree-node-error');
      } else if (node.hasError === true) {
        spanEl.addClass('fancytree-error');
      }

      return res;
    },

    nodeSetActive: function (ctx, flag, callOpts) {
      if (ctx.node.data.disabled === true) {
        return $.Deferred(function () {
          this.resolveWith(ctx);
        }).promise();
      }

      this._super(ctx, flag, callOpts);
    },

    treeSetFocus: function (ctx, flag, callOpts) {
      if (flag === false && this.focusNode) {
        this._lastFocusNode = this.focusNode;
      }
      var res = this._super(ctx, flag, callOpts);
      if (flag && (!callOpts || !callOpts.calledByNode) && !this.focusNode && this._lastFocusNode) {
        this._lastFocusNode.setFocus();
      }
      return res;
    }

  });

  return $.ui.fancytree;
});


csui.define('css!csui/controls/treebrowse/impl/tree',[],function(){});
csui.define('csui/controls/treebrowse/tree.view',[
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/marionette',
  'csui/models/node/node.model',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/controls/treebrowse/impl/tree.node.error.view',
  'csui/lib/fancytree/jquery.fancytree',
  'csui/controls/treebrowse/impl/fancytree.overrides',
  'css!csui/controls/treebrowse/impl/tree'
], function ($, _, Marionette, NodeModel, NodeTypeIconView, TreeNodeErrorView) {
  'use strict';

  return Marionette.ItemView.extend({

    template: false,
    className: 'csui-tree-browse',

    constructor: function TreeView(options) {
      options = options || {};
      var optionsToPick = ['activate', 'beforeActivate', 'click', 'clickPaging', 'collapse', 'dblclick', 'expand',
        'focus', 'init', 'keydown', 'lazyLoad', 'source', 'rtl'];

      this.treeOptions = _.extend(_.pick(options, optionsToPick), {
        extensions: ['csui-overrides'],
        'csui-overrides': {
          rootIndent: 4,
          levelIndent: 24
        },
        escapeTitles: true,
        autoActivate: false,
        icon: function (event, data) {
          var treeNode = data.node;

          if(treeNode.data.isErrorNode === true) {
            var treeNodeErrorView = new TreeNodeErrorView();
            return {html: treeNodeErrorView.render().el.outerHTML};
          }

          if(_.isEmpty(treeNode.data) || treeNode.data.showMore != undefined) {
            return;
          }

          var node = treeNode.data.origNode;
          if (!node) {
            node = new NodeModel({
              id: treeNode.key
            });
          }
          var iconOptions = {
                              node: node,
                              size: 'xsmall',
                              states: 'true',
                              colorTheme: 'tree'
                            },
              iconView = new NodeTypeIconView(iconOptions);
          return {html: iconView.render().el.outerHTML};
        }
      });

      options = _.omit(options, optionsToPick);
      Marionette.ItemView.prototype.constructor.call(this, options);
    },

    onBeforeRender: function () {
      this.tree = $.ui.fancytree.getTree(this.$el.fancytree(this.treeOptions));
    },

    onBeforeDestroy: function () {
      if (this.tree && this.tree.widget) {
        this.tree.widget.destroy();
      }
    }

  });

});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/treebrowse/impl/node.tree',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"csui-tree-browse-container\"></div>";
}});
Handlebars.registerPartial('csui_controls_treebrowse_impl_node.tree', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/treebrowse/impl/node.tree',[],function(){});
csui.define('csui/controls/treebrowse/node.tree.view',[
  'module',
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/marionette',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/utils/contexts/factories/next.node',
  'csui/utils/contexts/factories/ancestors',
  'csui/controls/globalmessage/globalmessage',
  'csui/utils/log',
  'csui/models/node.children2.lite/node.children2.lite',
  'csui/controls/treebrowse/tree.view',
  'i18n',
  'hbs!csui/controls/treebrowse/impl/node.tree',
  'i18n!csui/controls/treebrowse/impl/nls/lang',
  'css!csui/controls/treebrowse/impl/node.tree'
], function (module, $, _, Marionette, PerfectScrollingBehavior, NextNodeModelFactory,
    AncestorCollectionFactory, GlobalMessage, log, NodeChildren2LiteCollection, TreeView, i18n,
    template, lang
) {
  'use strict';

  log = log(module.id);

  var DEFAULT_SHOW_ITEMS_BLOCK_SIZE = 10;

  return Marionette.LayoutView.extend({

    className: 'csui-tree-browse-panel',
    template: template,

    regions: {
      treeRegion: '.csui-tree-browse-container'
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        suppressScrollX: true
      }
    },

    constructor: function NodeTreeView(options) {
      if (!options || !options.originatingView) {
        throw new Error('originatingView option is mandatory');
      }
      _.defaults(options, {
        lazyTree: true
      });

      this.context = options.originatingView.context;
      this.connector = options.originatingView.connector;
      this.originatingView = options.originatingView;
      this.showItemsBlockSize = options.showItemsBlockSize || DEFAULT_SHOW_ITEMS_BLOCK_SIZE;
      this.rootNodes = options.rootNodes || options.originatingView.rootNodes;
      this.lazyLoading = options.lazyTree;
      this.ancestors = this.context.getCollection(AncestorCollectionFactory);

      Marionette.LayoutView.prototype.constructor.call(this, options);
      this.listenTo(this.originatingView.collection, 'add', this._modelAdded, this);
      this.listenTo(this.originatingView.collection, 'remove', this._modelRemoved, this);
      this.listenTo(this.originatingView.collection, 'change:name sync', this._modelRenamed, this);
      this.listenTo(this.originatingView.container, 'change:name', this._modelRenamed, this);
      this.listenTo(this.originatingView.container, 'delete', this._modelRemoved, this);
    },

    is: "NodeTreeView",

    onRender: function () {
      this.treeView = new TreeView(this._buildTreeOptions());
      this.treeRegion.show(this.treeView);
    },

    updateNodes: function () {
      var self = this,
          activeNode = this.treeView.tree.activeNode;
      if (activeNode) {
        var updatedAncestors  = this.getUpdatedAncestors(this.ancestors),
            ancestorTreeNodes = activeNode.getParentList(false, true),
            index             = 0;
        // updating the ancestors of the active node with the latest names
        // when concurrent users change names of nodes.
        ancestorTreeNodes.forEach(function (treeNode) {
          if (treeNode.title !== updatedAncestors[index].name) {
            self._updateNodeTitle(treeNode, updatedAncestors[index].name);
          }
          index++;
        });
        // updating children of active node with the latest names
        // when cuncurrent users change names of nodes.
        if (activeNode.isExpanded()) {
          var folderNodes       = this.originatingView.collection.filter(function (node) {
                return node.get('container') === true;
              }),
              treeChildrenNodes = activeNode.getChildren();

          folderNodes.forEach(function (collectionNode) {
            var node = _.find(treeChildrenNodes, function (treeNode) {
              return collectionNode.get('id').toString() === treeNode.key;
            });
            if (node && node.key !== collectionNode.get(name)) {
              self._updateNodeTitle(node, collectionNode.get('name'));
            }
          });
        }
      }
    },

    // when the root node is passed as an option to the view , there may be
    // some ancestors of the current node in the table view which maybe be above the
    // root node in the options, so ancestors need to be updated to have all nodes within or
    // on the same level as the root node.
    getUpdatedAncestors: function (ancestors) {
      if (!this.updateAncestors) {
        return ancestors.map(function (ancestor) {
          return {
            id: ancestor.get('id').toString(),
            name: ancestor.get('name')
          };
        });
      } else {
        var updatedAncestors = [];
        var rootFound = false;
        ancestors.each(function (ancestor) {
          if (rootFound) {
            updatedAncestors.push({
              id: ancestor.get('id').toString(),
              name: ancestor.get('name')
            });
          } else {
            this.rootNodes.some(function (rootNode) {
              if (rootNode.get('id') === ancestor.get('id')) {
                rootFound = true;
                updatedAncestors.push({
                  id: ancestor.get('id').toString(),
                  name: ancestor.get('name')
                });
                return true;
              }
              return false;
            });

          }
        }, this);

        return updatedAncestors;
      }

    },

    onDomRefresh: function () {
      this._clearTabIndexes();
    },

    _clearTabIndexes: function () {
      var clearTabIndexesSelector = ".ps-scrollbar-x[tabindex], .ps-scrollbar-y[tabindex]",
          targetElems = this.el.querySelectorAll(clearTabIndexesSelector);
      if (targetElems.length) {
        for(var i = 0; i < targetElems.length; i++) {
          targetElems[i].setAttribute("tabindex", -1);
        }
      }
    },

    _buildTreeOptions: function () {
      var nextNode    = this.context.getModel(NextNodeModelFactory),
          ancestors   = this.context.getCollection(AncestorCollectionFactory),
          treeOptions = _.extend({

            rtl: i18n && i18n.settings.rtl ? true : false,
            source: function () {
              var nodes = [];
              if (this.rootNodes && this.rootNodes.length > 0) {
                _.each(this.rootNodes, function (rootNode) {
                  nodes.push(rootNode);
                });
                this.updateAncestors = true;
              } else {
                nodes.push(ancestors.first());
              }
              return _.map(nodes, this._createTreeNode);
            },

            init: function (event, data) {
              // Expand tree to current container in doclist
              var self = this;

              function syncTree(firstLoad) {
                self._activateNode(data.tree, self.getUpdatedAncestors(ancestors), undefined,
                    firstLoad);
                !firstLoad && self.updateNodes();
              }

              // Listen to node change in doclist
              this.listenTo(ancestors, 'update reset', function () {
                syncTree(false);
              });
              data.tree.data.firstLoad = true;
              syncTree(true);
            },

            lazyLoad: function (event, data) {
              var deferred = $.Deferred(),
                  treeNode = data.node;
              this._fetchNodeChildren(treeNode, 0, this._getInitialFetchLimit(treeNode)).done(
                  _.bind(function (collection) {
                    treeNode.hasError = false;
                    var limit       = this._getInitialShowLimit(treeNode),
                        result      = _.map(collection.models, this._createTreeNode),
                        allChildren = _.clone(result);
                    treeNode.data.totalCount = collection.totalCount; // store total count info in parent node
                    treeNode.data.allChildren = allChildren;

                    if (treeNode.data.totalCount > limit) {
                      result.splice(limit);
                      this._addPagingNode(result, allChildren, treeNode.data.totalCount, limit);
                    }
                    deferred.resolve(result);
                  }, this)).fail(function (error) {
                treeNode.setStatus("ok");
                if (error.status === 404) {
                  treeNode.hasError = true;
                  this._makeErrorNode(treeNode);
                } else {
                  GlobalMessage.showMessage('error',
                      _.str.sformat(lang.expandNetworkError, treeNode.title));
                }
              }.bind(this));

              data.result = deferred.promise();
            },

            focus: function (event, data) {
              data.node.scrollIntoView(true);
            },

            expand: function () {
              this.trigger('update:scrollbar');
            },

            collapse: function (event, data) {
              this.trigger('update:scrollbar');
              // Reset node on collapse, so that on expand it will fetch children data again
              data.node.resetLazy();
            },

            click: function (event, data) {
              if (_.isEmpty(data.node.data) || !!data.node.hasError ||
                  !!data.node.data.isErrorNode) {
                event.preventDefault();
                event.stopPropagation();
                return false;
              }
              data.tree.activateKey(false, {noEvents: true});
            },

            dblclick: function () {
              return false;
            },

            keydown: function (event, data) {
              if (event.which === 13 || event.which === 32) {
                if(!!data.node.hasError|| !!data.node.data.isErrorNode) {
                  return false;
                }
                data.tree.activateKey(false, {noEvents: true});
              }
            },

            clickPaging: function (event, data) {
              this._clickPagingNode(data.node);
            },

            beforeActivate: function (event, data) {
              if (data.node.isPagingNode()) {
                data.tree.options.clickPaging.apply(this, arguments);
                return false;
              }
              return true;
            },

            activate: function (event, data) {
              var origId = nextNode.get('id').toString();
              if (origId != data.node.key) {
                nextNode.trigger('before:change:id', data.node.data.origNode, this);
                nextNode.set({
                  id: data.node.key
                });
              }
              // Force refresh the list if current node is clicked again
              if (origId === data.node.key && !data.tree.data.firstLoad) {
                this.originatingView.collection.fetch({reload: true});
              }
              data.tree._currActiveNodeKey = data.node.key;
            }

          }, this.options);
      // binding all the callbacks with nodeTreeView
      for (var key in treeOptions) {
        if (_.isFunction(treeOptions[key])) {
          treeOptions[key] = treeOptions[key].bind(this);
        }
      }

      return treeOptions;
    },

    _clickPagingNode: function (node) {
      var deferred = $.Deferred();
      if (!this.lazyLoading) {
        this._clickPagingNodePrefetch(node).done(deferred.resolve);
      } else {
        this._clickPagingNodeLazy(node).done(deferred.resolve);
      }
      return deferred.promise();
    },

    _makeErrorNode: function (treeNode) {
      var errorNode = treeNode.addNode({
        title: lang.nodeDoesNotExistMsg,
        isErrorNode: true
      });
      treeNode.setExpanded(true, {noEvents: true});
    },

    _getInitialFetchLimit: function (node) {
      var initialFetch;
      if (this.lazyLoading) {
        initialFetch = this.showItemsBlockSize;
      } else {
        initialFetch = 2 * this.showItemsBlockSize;

      }
      return initialFetch;
    },

    _getInitialShowLimit: function (node) {
      return this.showItemsBlockSize;
    },

    _createTreeNode: function (node) {
      var isContainer = !!node.get('container');
      return {
        key: node.get('id'),
        origNode: node,
        title: node.get('name'),
        tooltip: node.get('name'),
        folder: isContainer,
        lazy: isContainer
      };
    },

    _fetchNodeChildren: function (node, fetchStartIndex, size) {
      var deferred   = $.Deferred(),
          collection = new NodeChildren2LiteCollection([],
              _.defaults({
                    // Prefer refreshing the entire table to rendering one row after another.
                    autoreset: true,
                    // Minimize the response information; the server adds information with
                    // every update and UI would get slower
                    fields: {
                      properties: []
                    }
                  },
                  {node: node.data.origNode}
              )
          );
      collection.setFilter(-1, 'type', {fetch: false});
      this._setCollectionOptions(collection, node.data.origNode, fetchStartIndex, size);
      collection.fetch().done(function () {
        deferred.resolve(collection);
      }).fail(deferred.reject);
      return deferred.promise();
    },

    _activateNode: function (tree, ancestors, lastNode, firstLoad) {
      var me = this,
          key, treeNode;

      if (ancestors.length > 0) {
        key = ancestors[0].id;

        // If this is first node in ancestor list (root), then try to locate it directly under tree root.
        // If not found then try to locate the node under last expanded node.
        // Finally search throughout the tree
        if (!lastNode) {
          var rootNodes = tree.rootNode.getChildren();
          treeNode = _.find(rootNodes, {key: key});
        }

        if (!treeNode) {
          var lastActedNode = lastNode || tree.activeNode;
          treeNode = lastActedNode && _.find(lastActedNode.getChildren(), function (n) {
            return n.key === key;
          });
        }

        if (!treeNode) {
          treeNode = tree.getNodeByKey(key);
        }

        if (treeNode) {
          // If it is last node, then just activate it
          if (ancestors.length === 1) {
            if (firstLoad === true) {
              treeNode.setExpanded(true).done(function() {
                treeNode.setActive(true);
              });
              tree.data.firstLoad = false;
            } else {
              treeNode.setActive(true);
            }
          } else {
            treeNode.setExpanded(true).done(function () {
              ancestors.splice(0, 1);
              me._activateNode(tree, ancestors, treeNode, firstLoad);
            });
          }
        } else {
          // If "show more" node is there then expand it and try finding again
          if (lastNode) {
            var lastChild = lastNode.getLastChild();
            if (lastChild && lastChild.statusNodeType === 'paging' && lastChild.data.showMore) {
              me._clickPagingNode(lastChild).done(function () {
                me._activateNode(tree, ancestors, lastNode, firstLoad);
              });
              return;
            }
          }
          log.error('Ancestor ' + key + ' not found in the tree, while trying to activate the node')
          && console.error(log.last);
        }
      }
    },

    _addPagingNode: function (output, allChildren, totalCount, currPageListSize) {
      var showMore = currPageListSize < totalCount;
      output.push({
        statusNodeType: 'paging',
        title: showMore ? lang.ShowMore : lang.ShowLess,
        data: {
          allChildren: allChildren,
          currPageListSize: currPageListSize,
          showMore: showMore,
        }
      });
    },

    _displayLoader: function (node) {
      var spanEle        = $(node.span),
          spanElePadding = parseFloat(spanEle.css('padding-left')),
          spanEleWidth   = spanEle.width();
      this.treeView.tree.nodeSetStatus({node: node}, "loading");
      spanEle.find('.fancytree-title').addClass('binf-hidden');
      if(i18n && i18n.settings.rtl) {
        spanEle.css({
          paddingRight: spanElePadding + (spanEleWidth / 2)
        });
      } else {
        spanEle.css({
          paddingLeft: spanElePadding + (spanEleWidth / 2)
        });
      }
    },

    _clickPagingNodeLazy: function (node, collapse) {
      var me               = this,
          deferred         = $.Deferred(),
          parentNode       = node.getParent(),
          allChildren      = node.data.allChildren, // array that contains all the fetched children of a node
          totalCount       = parentNode.data.totalCount,
          currPageListSize = node.getIndex(),//node.data.currPageListSize,
          showMore         = node.data.showMore && collapse !== true,
          newPageListSize,
          newResult;

      if (showMore) {
        newPageListSize = currPageListSize + this.showItemsBlockSize;
        me._displayLoader(node);
        me._fetchNodeChildren(parentNode, currPageListSize, me.showItemsBlockSize).done(
            function (collection) {
              newResult = _.map(collection.models, me._createTreeNode);
              (totalCount > allChildren.length) && allChildren.push.apply(allChildren, newResult);
              me.treeView.tree.nodeSetStatus({node: node}, "ok");
              me._addPagingNode(newResult, allChildren, totalCount, newPageListSize);
              me._replacePagingNodeWithChildren(node, newResult, showMore, collapse).done(
                  deferred.resolve);
            }).fail(function (error) {
          me.treeView.tree.nodeSetStatus({node: node}, "ok");
          GlobalMessage.showMessage('error', _.str.sformat(lang.showMoreNetworkError));
        });
      } else {
        newResult = [];
        newPageListSize = me._getInitialShowLimit(node.parent);
        me._addPagingNode(newResult, allChildren, totalCount, newPageListSize);
        for (var i = parentNode.children.length - 2; i >= newPageListSize; i--) {
          parentNode.removeChild(parentNode.children[i]);
        }
        me._replacePagingNodeWithChildren(node, newResult, showMore, collapse).done(
            deferred.resolve);
      }
      return deferred.promise();
    },

    _clickPagingNodePrefetch: function (node, collapse) {
      var me               = this,
          deferred         = $.Deferred(),
          parentNode       = node.getParent(),
          allChildren      = node.data.allChildren, // array that contains all the fetched children of a node
          totalCount       = parentNode.data.totalCount,
          currPageListSize = node.getIndex(),//node.data.currPageListSize,
          showMore         = node.data.showMore && collapse !== true,
          promise          = parentNode.data.promise, // promise of the previous prefetch
          newPageListSize,
          newResult;

      if (showMore) {  // if user clicked on show more
        newPageListSize = currPageListSize + me.showItemsBlockSize; // calculate the new page size
        if (!promise || promise.finish) { // checking if the previous prefetch call is a success
          // as we are prefetching the nodes, nodes exists in allchildren
          newResult = allChildren.slice(currPageListSize, newPageListSize);
          newPageListSize = allChildren.length < newPageListSize ? allChildren.length :
                            newPageListSize;
          prefetchChildren();
          me._addPagingNode(newResult, allChildren, totalCount, newPageListSize);
          me._replacePagingNodeWithChildren(node, newResult, showMore, collapse).done(
              deferred.resolve);
        }
        // previous prefetch call is still in progress so wait for it
        else if (!promise.finish && !promise.rejected) {
          me._displayLoader(node);
          promise.done(function () {
            me.treeView.tree.nodeSetStatus({node: node}, "ok");
            // as we are prefetching the nodes, nodes exists in allchildren
            newResult = allChildren.slice(currPageListSize, newPageListSize);
            prefetchChildren();
            me._addPagingNode(newResult, allChildren, totalCount, newPageListSize);
            me._replacePagingNodeWithChildren(node, newResult, showMore, collapse).done(
                deferred.resolve);
          }).fail(function () {
            // show the error message
            console.error('Network issue fetching show more results');
          });
        } else if (promise.rejected) {
          GlobalMessage.showMessage('error', _.str.sformat(lang.showMoreNetworkError));
        } else {
          // show the error message
          console.error('Network issue fetching show more results');
        }
      } else {
        newResult = [];
        newPageListSize = me._getInitialShowLimit(node.parent);
        me._addPagingNode(newResult, allChildren, totalCount, newPageListSize);
        for (var i = parentNode.children.length - 2; i >= newPageListSize; i--) {
          parentNode.removeChild(parentNode.children[i]);
        }
        me._replacePagingNodeWithChildren(node, newResult, showMore, collapse).done(
            deferred.resolve);
      }

      function prefetchChildren() {
        var fetchStartIndex = allChildren.length;
        if (totalCount > allChildren.length) {
          promise = me._fetchNodeChildren(parentNode, fetchStartIndex, me.showItemsBlockSize);
          parentNode.data.promise = promise; // storing the promise in parent node
          promise.done(function (collection) {
            var preFetchedNodes = _.map(collection.models, me._createTreeNode);
            promise.finish = true;
            allChildren.push.apply(allChildren, preFetchedNodes);
          }).fail(function () {
            promise.rejected = true;
          });
        }
      }

      return deferred.promise();
    },

    _replacePagingNodeWithChildren: function (node, newResult, showMore, collapse) {
      var parentNode = node.getParent(),
          focusIndex = node.getIndex(),
          deferred   = $.Deferred();
      // replace show more or show less with the nodes
      node.replaceWith(newResult).done(function () {
        this.trigger('update:scrollbar');
        // If "show more" was done, then check if current active node was part of the sathis, and if so, mark it as active
        if (showMore && node.tree._currActiveNodeKey &&
            _.any(newResult, {key: node.tree._currActiveNodeKey})) {
          this._getActiveNode().setActive(true, {noFocus: true, noEvents: true});
        }
        if (collapse !== true) {
          parentNode.children[focusIndex].setFocus(true);
        }
        deferred.resolve();
      }.bind(this)).fail(deferred.reject);

      return deferred.promise();
    },

    _setCollectionOptions: function (collection, node, currPageListSize, showItemsBlockSize) {
      collection.node = node;
      collection.skipCount = currPageListSize;
      collection.topCount = showItemsBlockSize;
    },

    _getActiveNode: function () {
      var tree = this.treeView.tree;
      return tree.getNodeByKey(tree._currActiveNodeKey);
    },

    _addNewNode: function (parentNode, newNode) {
      var lastChild     = parentNode.getLastChild(), pos, addedInMainList,
          hasPagingNode = lastChild && lastChild.statusNodeType === 'paging',
          children      = hasPagingNode ? lastChild.data.allChildren : parentNode.getChildren(),
          childIdNames  = _.map(children, function (item) {
            return {
              key: item.key,
              title: item.title
            };
          });

      // Determine position for new node (sorted by name)
      childIdNames.push(newNode);
      childIdNames = _.sortBy(childIdNames, function (item) {
        return item.title.toLowerCase();
      });
      _.find(childIdNames, function (item, index) {
        if (item.key === newNode.key) {
          pos = index;
          return true;
        }
      });

      // If position is within displayed nodes (not under "Show more"), then insert the node there
      if (pos < parentNode.getChildren().length) {
        parentNode.addChildren([newNode], pos === -1 ? null : pos);
        addedInMainList = true;
      } else if (pos === parentNode.getChildren().length && !hasPagingNode) {
        parentNode.addChildren([newNode]);
        addedInMainList = true;
      }

      // If paging node is there then update "allChildren" attribute for the same
      if (hasPagingNode) {
        lastChild.data.allChildren.splice(pos, 0, newNode);
        if (addedInMainList) {
          lastChild.data.currPageListSize = lastChild.data.currPageListSize + 1;
        }
      }
    },

    _removeNode: function (parentNode, modelId) {
      var nodeToBeRemoved = _.find(parentNode.getChildren(), {key: modelId.toString()});
      if (nodeToBeRemoved) {
        nodeToBeRemoved.remove();
      }
      // If paging node is there then update "allChildren" attribute for the same
      var lastChild = parentNode.getLastChild();
      if (lastChild && lastChild.statusNodeType === 'paging') {
        lastChild.data.allChildren = _.reject(lastChild.data.allChildren, {key: modelId});
        if (nodeToBeRemoved) {
          lastChild.data.currPageListSize = lastChild.data.currPageListSize - 1;
        }
        // If no node is left in "show more" section then remove paging node
        if (lastChild.data.allChildren.length === lastChild.data.currPageListSize) {
          parentNode.removeChild(lastChild);
        }
      }
    },

    _modelAdded: function (model) {
      var me             = this,
          addModelToTree = function (model) {
            var activeNode      = me._getActiveNode(),
                activeNodeKey   = activeNode.key,
                treeParentNodes = me.treeView.tree.findAll(function (node) {
                  return node.isLoaded() && activeNodeKey === node.key;
                });

            _.each(treeParentNodes, function (parentNode) {
              me._addNewNode(parentNode, me._createTreeNode(model));
            });
          };

      // Only folders/cabinets to be added to tree
      if (model.get('container')) {
        // If ID is missing that means that it is an in-process folder creation. We wait for model to be saved
        if (!model.get('id')) {
          me.listenToOnce(model, 'sync', function () {
            addModelToTree(model);
          });
        } else {
          addModelToTree(model);
        }
      }
    },

    _modelRemoved: function (model) {
      var me = this;
      if (model.get('container')) {
        var modelId     = model.get('id'),
            parentNodes = me.treeView.tree.findAll(function (node) {
              if (node.isLoaded() && node.hasChildren()) {
                // If removed node is directly under any node, then include that parent for processing
                if (_.any(node.getChildren(), {key: modelId.toString()})) {
                  return true;
                }
                // If removed node is under some node but is under "Show more" section, then also include that parent
                var lastChild = node.getLastChild();
                if (lastChild.statusNodeType === 'paging') {
                  return _.any(lastChild.data.allChildren, {key: modelId});
                }
              }
              return false;
            });

        _.each(parentNodes, function (parentNode) {
          me._removeNode(parentNode, modelId);
        });
      }
    },

    _modelRenamed: function (model) {
      var me = this;
      if (model.get('container') && !!model.changed.name) {
        var modelId   = model.get('id'),
            treeNodes = me.treeView.tree.findAll(function (node) {
              if (node.statusNodeType === 'paging') {
                _.each(node.data.allChildren, function (child) {
                  // for nodes which are not yet displayed in the tree
                  // but the data is already prefetched and stored.
                  if (child.key === modelId) {
                    child.title = model.get('name');
                  }
                });
                return false;
              } else {
                return modelId.toString() === node.key;
              }
            });

        _.each(treeNodes, function (treeNode) {
          me._updateNodeTitle(treeNode, model.get('name'));
        });
      }
    },

    _updateNodeTitle: function(node, name){
      node.tooltip = name;
      node.setTitle(name);
    }

  });

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/listitem/impl/simpletreelistitem',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <span class=\"csui-button-icon container-icon "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":3,"column":49},"end":{"line":3,"column":57}}}) : helper)))
    + "\"></span>\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(((helper = (helper = lookupProperty(helpers,"tooltip") || (depth0 != null ? lookupProperty(depth0,"tooltip") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"tooltip","hash":{},"loc":{"start":{"line":5,"column":46},"end":{"line":5,"column":57}}}) : helper)));
},"5":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":5,"column":65},"end":{"line":5,"column":73}}}) : helper)));
},"7":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <span class=\"csui-button-icon dropdown-icon icon-expandArrowUp\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"collapseLabel") || (depth0 != null ? lookupProperty(depth0,"collapseLabel") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"collapseLabel","hash":{},"loc":{"start":{"line":7,"column":75},"end":{"line":7,"column":92}}}) : helper)))
    + "\"></span>\r\n";
},"9":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <span class=\"csui-button-icon dropdown-icon icon-expandArrowDown\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"expandLabel") || (depth0 != null ? lookupProperty(depth0,"expandLabel") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"expandLabel","hash":{},"loc":{"start":{"line":9,"column":77},"end":{"line":9,"column":92}}}) : helper)))
    + "\"></span>\r\n";
},"11":function(container,depth0,helpers,partials,data) {
    return " binf-hidden";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"cs-header binf-panel-heading\" tabindex=\"-1\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"ariaName") || (depth0 != null ? lookupProperty(depth0,"ariaName") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"ariaName","hash":{},"loc":{"start":{"line":1,"column":68},"end":{"line":1,"column":80}}}) : helper)))
    + "\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"icon") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":2,"column":2},"end":{"line":4,"column":9}}})) != null ? stack1 : "")
    + "  <div class=\"cs-title\" title=\""
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"tooltip") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"loc":{"start":{"line":5,"column":31},"end":{"line":5,"column":80}}})) != null ? stack1 : "")
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":5,"column":82},"end":{"line":5,"column":90}}}) : helper)))
    + "</div>\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"expand") : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.program(9, data, 0),"loc":{"start":{"line":6,"column":2},"end":{"line":10,"column":9}}})) != null ? stack1 : "")
    + "</div>\r\n\r\n<div class=\"cs-content "
    + ((stack1 = lookupProperty(helpers,"unless").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"expand") : depth0),{"name":"unless","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"loc":{"start":{"line":13,"column":23},"end":{"line":13,"column":64}}})) != null ? stack1 : "")
    + " "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"flatten") : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"loc":{"start":{"line":13,"column":65},"end":{"line":13,"column":99}}})) != null ? stack1 : "")
    + "\">\r\n  <div role=\"group\" class=\"cs-list-group\"></div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_listitem_impl_simpletreelistitem', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/controls/listitem/impl/simpletreelistleaf',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(((helper = (helper = lookupProperty(helpers,"tooltip") || (depth0 != null ? lookupProperty(depth0,"tooltip") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"tooltip","hash":{},"loc":{"start":{"line":3,"column":41},"end":{"line":3,"column":52}}}) : helper)));
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":3,"column":60},"end":{"line":3,"column":68}}}) : helper)));
},"5":function(container,depth0,helpers,partials,data) {
    return "<div class=\"csui-tileview-more-btn\"></div>";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"binf-list-group-item\">\r\n  <span class=\"csui-type-icon "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":2,"column":30},"end":{"line":2,"column":38}}}) : helper)))
    + "\"></span>\r\n  <div role=\"link\" title=\""
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"tooltip") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"loc":{"start":{"line":3,"column":26},"end":{"line":3,"column":75}}})) != null ? stack1 : "")
    + "\"\r\n        class=\"list-item-title\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"itemLabel") || (depth0 != null ? lookupProperty(depth0,"itemLabel") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"itemLabel","hash":{},"loc":{"start":{"line":4,"column":44},"end":{"line":4,"column":57}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":4,"column":59},"end":{"line":4,"column":67}}}) : helper)))
    + "</div>\r\n  "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"showInlineActionBar") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":78}}})) != null ? stack1 : "")
    + "\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_listitem_impl_simpletreelistleaf', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/listitem/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/listitem/impl/nls/root/lang',{
  treeListExpandTooltip: 'Expand',
  treeListCollapseTooltip: 'Collapse',
  itemTitleLabel: '{0}, Press enter to open or right arrow to access other actions',
  typeAndNameAria: '{0} {1}'
});



csui.define('css!csui/controls/listitem/impl/simpletreelistitem',[],function(){});
// Shows a simply tree list of items with scrollbar
csui.define('csui/controls/listitem/simpletreelistitem.view',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/utils/base', 'csui/controls/list/emptylist.view',
  'csui/controls/node-type.icon/node-type.icon.view',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/utils/node.links/node.links', 'csui/behaviors/default.action/default.action.behavior',
  'csui/controls/listitem/impl/inline.menu/inline.menu.view',
  'csui/controls/list/behaviors/list.item.keyboard.behavior',
  'csui/utils/accessibility',
  'hbs!csui/controls/listitem/impl/simpletreelistitem',
  'hbs!csui/controls/listitem/impl/simpletreelistleaf',
  'i18n!csui/controls/listitem/impl/nls/lang',
  'css!csui/controls/listitem/impl/simpletreelistitem'
], function (_, $, Backbone, Marionette, base, EmptyListView, NodeTypeIconView,
    PerfectScrollingBehavior, nodeLinks, DefaultActionBehavior, InlineMenuView,
    ListItemKeyboardBehavior, Accessibility,
    treeListItemTemplate, treeListLeafTemplate, lang) {
  'use strict';

  var accessibleTable = Accessibility.isAccessibleTable();

  // keep the numbers in sequence for value increment/decrement computation
  var TabPosition = {
    none: -1,
    header: 0,
    list: 1
  };

  var SimpleTreeListLeafView = Marionette.ItemView.extend({

    tagName: 'a',

    attributes: function () {
      return {
        role: 'treeitem',
        tabindex: '-1'
      };
    },

    template: treeListLeafTemplate,

    modelEvents: {
      'change': 'render'
    },

    ui: {
      titleName: '.list-item-title',
      moreActions: '.csui-tileview-more-btn'
    },

    events: function () {
      var evts = {'click': 'onExecuteClick'};

      if (!!this.options.toolbarData && !accessibleTable) {
        evts = _.extend(evts, {
          'mouseenter': 'onShowInlineMenu',
          'mouseleave': 'onHideInlineMenu',
          'wheel': 'onWheelEvent'
        });
      }

      return evts;
    },

    behaviors: {
      DefaultAction: {
        behaviorClass: DefaultActionBehavior
      },
      ListItemKeyboardBehavior: {
        behaviorClass: ListItemKeyboardBehavior
      }
    },

    onExecuteClick: function (event) {
      // let's execute the default action.
      if (base.isControlClick(event)) {
        // do nothing, let's execute browser's default behaviour as it is in both ctrl+click and
        // command+click in mac.
      } else {
        event.stopPropagation();
        event.preventDefault();
        this.triggerMethod('click:item', { target: this.model });
      }
    },

    constructor: function SimpleTreeListLeafView(options) {
      options || (options = {});
      this.showInlineActionBar = !!options.toolbarData;
      if (this.showInlineActionBar) {
        this.triggers = {};
        this.tileViewToolbarItems = options.toolbarData.toolbaritems;
      }
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.context = options.context;
      this.listenTo(this, 'doc:preview:generic:actions', this._highlightRow);
    },
    /**
         * This method highlight's the row for which document is getting to be previewed.
         *
         * @param targetRow
         * @private
         */
    _highlightRow: function (targetNode, HIGHLIGHT_CLASS_NAME) {
      $('.' + HIGHLIGHT_CLASS_NAME).removeClass(HIGHLIGHT_CLASS_NAME);
      this.$el.addClass(HIGHLIGHT_CLASS_NAME);
    },
    // To prevent metadata from getting close on recreating the list item (on search refilter etc.)
    cascadeDestroy: function () {
      return false;
    },

    onShowInlineMenu: function (event) {
      var inlineBarElem   = this.$el.find('.csui-tileview-more-btn');
      if(base.isHybrid() && (event || !inlineBarElem.length)){
        return;
      }
      event && event.preventDefault();
      event && event.stopPropagation();
      this.$el.addClass('csui-tile-with-more-btn');
      // Create inline menu view
      this._inlineMenuView = new InlineMenuView({
        context: this.options.context,
        originatingView: this,
        commands: this.defaultActionController.commands,
        model: this.model,
        tileViewToolbarItems: this.tileViewToolbarItems
      });

      var inlineBarRegion = new Marionette.Region({el: inlineBarElem});
      inlineBarRegion.show(this._inlineMenuView);
      this.listenTo(this._inlineMenuView, 'before:execute:command', function(args){
        this.trigger('before:execute:command', args);
      });
      this.listenTo(this._inlineMenuView, 'after:execute:command', function(){
        if(!base.isHybrid()){
          this.onHideInlineMenu();
        }
      });
    },

    onHideInlineMenu: function (event) {
      if(event && base.isHybrid()){
        this._inlineMenuView && this._inlineMenuView.inlineMenuBarView &&
          this._inlineMenuView.inlineMenuBarView.closeDropdownMenuIfOpen();
        return;
      }
      this.$el.removeClass('csui-tile-with-more-btn');
      if (this._inlineMenuView) {
        this._inlineMenuView.destroy();
        this._inlineMenuView = undefined;
        return true;
      }
    },

    onWheelEvent: function (event) {
      this._inlineMenuView && this._inlineMenuView.closeDropdownMenuIfOpen();
    },

    onRender: function () {
      var id = this.model && this.model.get('id');
      if (id != null) {
        this.$el.attr('href', nodeLinks.getUrl(this.model));
      }
      if(this.options.refetchNodeActions && this.model) {
        this.model.refetchNodeActions = true;
      }
      if (this._nodeIconView) {
        this._nodeIconView.destroy();
      }
      this._nodeIconView = new NodeTypeIconView({
        el: this.$('.csui-type-icon').get(0),
        node: this.model,
        size: this.options.iconSize
      });
      this.$el.attr('aria-label',
          _.str.sformat(lang.typeAndNameAria, this._nodeIconView.model.get('title'),
              this.model.get('name')));
      this._nodeIconView.render();

      if (this.model && this.options && this.options.checkDefaultAction) {
        var disabled = this.model.fetched === false ||
                       !this.defaultActionController.hasAction(this.model);
        this.$el[disabled ? 'addClass' : 'removeClass']('inactive');
      }
      if(base.isHybrid()){
        this.onShowInlineMenu();
      }
    },

    onBeforeDestroy: function () {
      if (this._nodeIconView) {
        this._nodeIconView.destroy();
      }
      if (this._inlineMenuView) {
        this._inlineMenuView.destroy();
      }
    }

  });

  var SimpleTreeListItemView = Marionette.CompositeView.extend({

    className: 'cs-simpletreelistitem binf-panel binf-panel-default',

    attributes: function () {
      return {
        role: 'treeitem'
      };
    },

    template: treeListItemTemplate,
    templateHelpers: function () {
      return this._baseTemplateHelpers();
    },

    _baseTemplateHelpers: function () {
      return {
        icon: this.options.model && this.options.model.get('icon'),
        name: this.options.model && this.options.model.get('name'),
        expandLabel: lang.treeListExpandTooltip,
        collapseLabel: lang.treeListCollapseTooltip
      };
    },

    ui: {
      header: '.cs-header',
      headerDropdownIcon: '.cs-header .dropdown-icon',
      content: '> .cs-content',
      contentList: '> .cs-content > .cs-list-group'
    },

    events: {
      'keydown': 'onKeyInView'
    },

    childEvents: {
      'click:item': 'onClickItem',
      'render': '_onChildRender',
      'before:execute:command': 'onBeforeCommandExecution'
    },

    childViewContainer: '.cs-list-group',

    childView: SimpleTreeListLeafView,

    childViewOptions: function () {
      return {
        text: this.options.emptyViewDefaultText,
        checkDefaultAction: this.options.checkDefaultAction,
        template: this.options.childViewTemplate,
        templateHelpers: this.options.childViewTemplateHelpers,
        toolbarData: this.options.toolbarData,
        context: this.options.context,
        iconSize: this.options.iconSize,
        refetchNodeActions: this.options.refetchNodeActions
      };
    },

    emptyView: EmptyListView,

    _onChildRender: function (childView) {
      var $item = childView.$el;
      if ($item.is('[data-csui-active]')) {
        $item.addClass('binf-active');
      }
    },

    onBeforeCommandExecution: function (args) {
      this.trigger('before:execute:command', args);
    },

    constructor: function SimpleTreeListItemView(options) {
      options || (options = {});
      if (options.model && options.model.childrenCollection) {
        options.collection = options.model.childrenCollection;
      } else {
        options.collection = new Backbone.Collection();
      }

      // merge baseTemplateHelpers with options templateHelpers
      if (options.templateHelpers) {
        var self = this;
        var optionsTemplateHelpers = options.templateHelpers;
        options.templateHelpers = function () {
          if (_.isFunction(optionsTemplateHelpers)) {
            return _.extend(self._baseTemplateHelpers(), optionsTemplateHelpers.call(self));
          } else {  // isObject
            return _.extend(self._baseTemplateHelpers(), optionsTemplateHelpers);
          }
        };
      }

      Marionette.CompositeView.call(this, options);
    },

    onRender: function () {
      // if the tree model was specified 'flatten'
      if (this.model && this.model.get('flatten') === true) {
        this.$el.addClass('flatten-tree');
        this.ui.header.addClass('binf-hidden');
        // when the list is empty, don't show the empty list text
        if (this.collection.length > 0) {
          this.ui.content.removeClass('binf-hidden');
        }
        // suppress role=treeitem for the flattened treeitem and role=group for group container
        // this will trick screen readers to see children treeitems as their parent's siblings
        this.$el.removeAttr('role');
        this.ui.contentList.removeAttr('role');
      }

      this.ui.header.on('click', _.bind(this.onClickHeader, this));
      this._setDropdownIconClass();
      this.tabPosition = TabPosition.none;
      this.selectedIndex = -1;
    },

    onClickHeader: function (event) {
      event.preventDefault();
      event.stopPropagation();

      this.ui.content.toggleClass('binf-hidden');
      this._setDropdownIconClass();

      this.$el.trigger('focus');
      this.tabPosition = TabPosition.header;
      this.selectedIndex = -1;

      this.triggerMethod('click:tree:header', this);
    },

    _setDropdownIconClass: function () {
      if (this.ui.content.hasClass('binf-hidden')) {
        this.ui.headerDropdownIcon.removeClass('icon-expandArrowUp');
        this.ui.headerDropdownIcon.addClass('icon-expandArrowDown');
        this.ui.headerDropdownIcon.attr('title', lang.treeListExpandTooltip);
        // set aria-expanded for normal favorite tabs, but not for the ungrouped favorite tab
        if (this.model && this.model.get('flatten') !== true) {
          this.$el.attr('aria-expanded', 'false');
        }
      } else {
        this.ui.headerDropdownIcon.addClass('icon-expandArrowUp');
        this.ui.headerDropdownIcon.removeClass('icon-expandArrowDown');
        this.ui.headerDropdownIcon.attr('title', lang.treeListCollapseTooltip);
        // set aria-expanded for normal favorite tabs, but not for the ungrouped favorite tab
        if (this.model && this.model.get('flatten') !== true) {
          this.$el.attr('aria-expanded', 'true');
        }
      }
    },

    onClickItem: function (src) {
      src.cancelClick = false;
      this.triggerMethod('click:tree:item', src);
      if (src.cancelClick === false) {
        this._setCssItemSelected(src.$el);
        src.$el.trigger('focus');
      }
      this.tabPosition = TabPosition.list;
      this.selectedIndex = src._index ? src._index : -1;
    },

    _setCssItemSelected: function ($item) {
      if (!($item instanceof $)) {
        return;
      }
      // unmark old
      var $active = $item.siblings('[data-csui-active]');
      $active.removeClass('binf-active').removeAttr('data-csui-active');
      // mark new
      $item.addClass('binf-active').attr('data-csui-active', '');

      // for keyboard navigation, set tabindex=-1
      $item.siblings().prop('tabindex', '-1');
    },

    currentlyFocusedElement: function (event) {
      var $elem;
      if (event && !this.ui.content.hasClass('binf-hidden') &&
          (event.keyCode === 34 || event.keyCode === 35 || event.keyCode === 38 ||
           (event.keyCode === 9 && event.shiftKey))) {
        // page down (34), end (35), arrow up (38), or shift-tab(9+shift):
        // return last tree leaf item if found
        var lastIndex = this.collection.length - 1;
        $elem = this.getElementByIndex(lastIndex);
        if ($elem) {
          this.tabPosition = TabPosition.list;
          this.selectedIndex = lastIndex;
          return $elem;
        }
      }

      // if the tree model was specified 'flatten'
      if (this.model && this.model.get('flatten') === true) {
        // return the first tree leaf if there is one
        if (this.collection.length > 0) {
          var index = this.selectedIndex > 0 ? this.selectedIndex : 0;
          (event && event.keyCode === 38 /* arrow up */) && (index = this.collection.length - 1);
          $elem = this.getElementByIndex(index);
          if ($elem) {
            this.tabPosition = TabPosition.list;
            this.selectedIndex = index;
            return $elem;
          }
        }
      } else if (!this.ui.content.hasClass('binf-hidden') && this.selectedIndex >= 0 &&
                 this.collection.length > 0) {
        var selectedIndex = this.selectedIndex;
        $elem = this.getElementByIndex(selectedIndex);
        if ($elem) {
          this.tabPosition = TabPosition.list;
          this.selectedIndex = selectedIndex;
          return $elem;
        }
      } else {  // normal non-flattened tree, return the tree header
        this.tabPosition = TabPosition.header;
        this.selectedIndex = -1;
        return this.$el;
      }

      // nothing found
      this.tabPosition = TabPosition.none;
      this.selectedIndex = -1;
      return undefined;
    },

    _moveTo: function (event, $elem, $preElem) {
      event.preventDefault();
      event.stopPropagation();

      this.trigger('before:keyboard:change:focus');
      $preElem && $preElem.prop('tabindex', '-1');
      $elem.prop('tabindex', '0');
      $elem.trigger('focus');
      this.trigger('changed:focus');
      this.trigger('after:keyboard:change:focus');
    },

    onKeyInView: function (event) {
      var $preElem;
      switch (event.keyCode) {
      case 38: // arrow up
        if (this.tabPosition === TabPosition.list && this.selectedIndex === 0) {
          // if the tree model was specified 'flatten' and the focus is at first element
          if (this.model && this.model.get('flatten') === true) {
            this.tabPosition = TabPosition.none;
            this.selectedIndex = -1;
          } else {  // normal non-flattened tree, return the tree header
            $preElem = this.getElementByIndex(this.selectedIndex);
            this.tabPosition = TabPosition.header;
            this.selectedIndex = -1;
            this._moveTo(event, this.$el, $preElem);
          }
        } else if (this.tabPosition === TabPosition.list && this.selectedIndex > 0) {
          $preElem = this.getElementByIndex(this.selectedIndex);
          this._moveTo(event, this._selectPrevious(), $preElem);
        }
        break;
      case 40: // arrow down
        if (!this.ui.content.hasClass('binf-hidden')) {
          if (this.selectedIndex < this.collection.length - 1) {
            this.tabPosition = TabPosition.list;
            $preElem = this.getElementByIndex(this.selectedIndex);
            this._moveTo(event, this._selectNext(), $preElem);
          }
        }
        break;
      case 33:  // page up
      case 34:  // page down
        this.tabPosition = TabPosition.none;
        this.selectedIndex = -1;
        break;
      case 13:  // enter
      case 32:  // space
        this._clickTargetByKeyboard(event);
        break;
      case 37:  // left arrow
        if (this.tabPosition === TabPosition.header && !this.ui.content.hasClass('binf-hidden')) {
          // left arrow while focus is on the tree header and subtree is open: close the subtree
          this._clickTargetByKeyboard(event);
        } else if (this.tabPosition === TabPosition.list) {
          var flattenTree = this.model && this.model.get('flatten');
          if (!flattenTree) {
            // left arrow while focus is on a tree leaf: move to the tree header
            $preElem = this.getElementByIndex(this.selectedIndex);
            this.tabPosition = TabPosition.header;
            this.selectedIndex = -1;
            this._moveTo(event, this.$el, $preElem);
          }
        }
        break;
      case 39:  // right arrow
        if (this.tabPosition === TabPosition.header) {
          if (this.ui.content.hasClass('binf-hidden')) {
            // right arrow while focus is on the tree header and subtree is close: open the subtree
            this._clickTargetByKeyboard(event);
          } else {
            // right arrow while focus is on tree header and subtree is open: move to 1st tree leaf
            if (this.collection.length > 0) {
              this.tabPosition = TabPosition.list;
              this.selectedIndex = 0;
              this._moveTo(event, this.getElementByIndex(this.selectedIndex), this.$el);
            }
          }
        }
        break;
      }
      return true;
    },

    _clickTargetByKeyboard: function (event) {
      event.preventDefault();
      event.stopPropagation();
      $(event.target).find('.cs-header').trigger('click');
    },

    _selectNext: function () {
      if (this.selectedIndex < this.collection.length - 1) {
        this.selectedIndex++;
      }
      return this.getElementByIndex(this.selectedIndex);
    },

    _selectPrevious: function () {
      if (this.selectedIndex > 0) {
        this.selectedIndex--;
      }
      return this.getElementByIndex(this.selectedIndex);
    },

    // return the jQuery list item element by index for keyboard navigation use
    getElementByIndex: function (index) {
      if (isNaN(index) || (index < 0)) {
        return null;
      }
      var nthChildSel = _.str.sformat('div a:nth-child({0})', index + 1); // index is zero-based
      var $item = this.$(nthChildSel);
      return $($item[0]);
    }
  });

  return SimpleTreeListItemView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/list/impl/simpletreelist',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"cs-list-group\"></div>\r\n";
}});
Handlebars.registerPartial('csui_controls_list_impl_simpletreelist', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/list/impl/simpletreelist',[],function(){});
// Shows a simply tree list of items with scrollbar
csui.define('csui/controls/list/simpletreelist.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/lib/marionette', 'csui/utils/base',
  'csui/controls/listitem/simpletreelistitem.view',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/behaviors/default.action/default.action.behavior',
  'hbs!csui/controls/list/impl/simpletreelist',
  'css!csui/controls/list/impl/simpletreelist'
], function (_, $, Backbone, Marionette, base, SimpleTreeListItemView,
    PerfectScrollingBehavior, DefaultActionBehavior,
    treeListTemplate) {

  var SimpleTreeListView = Marionette.CollectionView.extend({

    constructor: function SimpleTreeListView(options) {
      options || (options = {});

      // Provide the perfect scrollbar to every list view by default
      // (Behaviors cannot be inherited; add the PerfectScrolling
      //  to the local clone of the descendant's behaviors.)
      if (!(this.behaviors && _.any(this.behaviors, function (behavior, key) {
            return behavior.behaviorClass === PerfectScrollingBehavior;
          }))) {
        this.behaviors = _.extend({
          PerfectScrolling: {
            behaviorClass: PerfectScrollingBehavior,
            contentParent: '> .cs-content',
            suppressScrollX: true,
            // like bottom padding of container, otherwise scrollbar is shown always
            scrollYMarginOffset: 15
          }
        }, this.behaviors);
      }

      Marionette.CollectionView.call(this, options);
    },

    ui: {},

    events: {},

    childEvents: {
      'click:item': 'onClickItem',
      'render': '_onChildRender'
    },

    className: 'cs-simpletreelist binf-panel binf-panel-default',
    template: treeListTemplate,

    childViewContainer: '.cs-list-group',
    childView: SimpleTreeListItemView,

    childViewOptions: function () {
      return {
        template: this.options.childViewTemplate
      };
    },

    _onChildRender: function (childView) {
      var $item = childView.$el;
      if ($item.is('[data-csui-active]')) {
        $item.addClass('binf-active');
      }
    },

    onClickItem: function (src) {
      src.cancelClick = false;
      this.trigger('click:item', src);
      if (src.cancelClick === false) {
        this._setCssItemSelected(src.$el);
      }
    },

    _setCssItemSelected: function ($item) {
      if (!($item instanceof $)) {
        return;
      }
      // unmark old
      var $active = $item.siblings('[data-csui-active]');
      $active.removeClass('binf-active').removeAttr('data-csui-active');

      // mark new
      $item.addClass('binf-active').attr('data-csui-active', '');

      // for keyboard navigation, set tabindex=-1
//      $item.siblings().prop('tabindex', '-1');
    }

  });

  return SimpleTreeListView;

});

/**
  * This is proxy to expose ./impl/inline.menu/inline.menu.view as public
 */

csui.define('csui/controls/listitem/inline.menu.view',['module', 'csui/controls/listitem/impl/inline.menu/inline.menu.view',
'css!csui/controls/listitem/impl/inline.menu/inline.menu'
], function (module, InlineMenuViewImpl) {

  //
  // Public: Inline Menu View Class
  // This class is a clean and easy-to-read wrapper to expose as a public interface.
  // See the implementation impl/inline.menu.view.js for more available public methods.
  //
  var InlineMenuView = InlineMenuViewImpl.extend({
    constructor: function InlineMenuView(options) {
        InlineMenuViewImpl.prototype.constructor.apply(this, arguments);
    }
  });

  return InlineMenuView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/listitem/impl/listitemobject',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <img class=\"cs-icon\" src=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":2,"column":28},"end":{"line":2,"column":36}}}) : helper)))
    + "\" alt=\"\">\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <div class=\"cs-key\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"key") || (depth0 != null ? lookupProperty(depth0,"key") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"key","hash":{},"loc":{"start":{"line":7,"column":24},"end":{"line":7,"column":31}}}) : helper)))
    + "</div>\r\n";
},"5":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "      <span class=\"cs-size\"> ("
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"size") || (depth0 != null ? lookupProperty(depth0,"size") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"size","hash":{},"loc":{"start":{"line":12,"column":30},"end":{"line":12,"column":38}}}) : helper)))
    + ")</span>\r\n";
},"7":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <div class=\"cs-stage\">\r\n      <span class=\"cs-label\">"
    + container.escapeExpression((lookupProperty(helpers,"csui-l10n")||(depth0 && lookupProperty(depth0,"csui-l10n"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"stage") : depth0)) != null ? lookupProperty(stack1,"label") : stack1),{"name":"csui-l10n","hash":{},"loc":{"start":{"line":17,"column":29},"end":{"line":17,"column":54}}}))
    + "</span>\r\n      <span class=\"cs-value\">"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"stage") : depth0)) != null ? lookupProperty(stack1,"value") : stack1), depth0))
    + "</span>\r\n    </div>\r\n";
},"9":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <div class=\"cs-price "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"priceClass") || (depth0 != null ? lookupProperty(depth0,"priceClass") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"priceClass","hash":{},"loc":{"start":{"line":25,"column":25},"end":{"line":25,"column":39}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"price") || (depth0 != null ? lookupProperty(depth0,"price") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"price","hash":{},"loc":{"start":{"line":25,"column":41},"end":{"line":25,"column":50}}}) : helper)))
    + "</div>\r\n    <div class=\"cs-currency\">"
    + container.escapeExpression((lookupProperty(helpers,"csui-l10n")||(depth0 && lookupProperty(depth0,"csui-l10n"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"currency") : depth0),{"name":"csui-l10n","hash":{},"loc":{"start":{"line":26,"column":29},"end":{"line":26,"column":51}}}))
    + "</div>\r\n";
},"11":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <div class=\"cs-date\">\r\n      <div class=\"cs-label\">"
    + container.escapeExpression((lookupProperty(helpers,"csui-l10n")||(depth0 && lookupProperty(depth0,"csui-l10n"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"date") : depth0)) != null ? lookupProperty(stack1,"label") : stack1),{"name":"csui-l10n","hash":{},"loc":{"start":{"line":30,"column":28},"end":{"line":30,"column":52}}}))
    + "</div>\r\n      <div class=\"cs-value "
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"date") : depth0)) != null ? lookupProperty(stack1,"class") : stack1), depth0))
    + "\">"
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"date") : depth0)) != null ? lookupProperty(stack1,"value") : stack1), depth0))
    + "</div>\r\n    </div>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"icon") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":7}}})) != null ? stack1 : "")
    + "\r\n<div class=\"cs-left\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"key") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":6,"column":2},"end":{"line":8,"column":9}}})) != null ? stack1 : "")
    + "  <div class=\"cs-title\">\r\n    <span class=\"cs-name\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":10,"column":26},"end":{"line":10,"column":34}}}) : helper)))
    + "</span>\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"size") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"loc":{"start":{"line":11,"column":4},"end":{"line":13,"column":11}}})) != null ? stack1 : "")
    + "  </div>\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"stage") : depth0)) != null ? lookupProperty(stack1,"value") : stack1),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"loc":{"start":{"line":15,"column":2},"end":{"line":20,"column":9}}})) != null ? stack1 : "")
    + "</div>\r\n\r\n<div class=\"cs-right\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"price") : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"loc":{"start":{"line":24,"column":2},"end":{"line":27,"column":9}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"date") : depth0)) != null ? lookupProperty(stack1,"value") : stack1),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"loc":{"start":{"line":28,"column":2},"end":{"line":33,"column":9}}})) != null ? stack1 : "")
    + "</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_listitem_impl_listitemobject', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/listitem/impl/listitemobject',[],function(){});
// Shows a list of workspaces related to the current one
csui.define('csui/controls/listitem/listitemobject.view',[
  'csui/lib/underscore', 'csui/lib/marionette', 'csui/lib/numeral',
  'csui/lib/moment', 'csui/lib/handlebars', 'csui/utils/base',
  'hbs!csui/controls/listitem/impl/listitemobject',
  'csui/utils/handlebars/l10n', // support {{csui-l10n ...}}
  'css!csui/controls/listitem/impl/listitemobject'
], function (_, Marionette, numeral, moment, Handlebars, base, itemTemplate) {

  var ObjectListItem = Marionette.ItemView.extend({

    constructor: function ObjectListItem() {
      Marionette.ItemView.apply(this, arguments);
      this.$el.on("click", _.bind(function (event) {
        if (base.isControlClick(event)) {
          // do nothing, let's execute browser's default behaviour as it is in both ctrl+click and
          // command+click in mac.
        } else {
          event.preventDefault();
          event.stopPropagation();
          this.triggerMethod("click:item");
        }
      }, this));
    },

    className: 'cs-item-object list-group-item binf-clearfix',
    template: itemTemplate,

    templateHelpers: function () {
      // options.data contain a map of property names pointing to expressions
      // computing the property values; evaluate the expressions here
      return this._getObject(this.options.data || {});
    },

    _getObject: function (object) {
      return _.reduce(object, function (result, expression, name) {
        // Primitive values come from string (simple) expressions or objects
        // with the expression property (complex expressions)
        if (typeof expression === 'string') {
          expression = this._getValue(expression);
        } else if (typeof expression === 'object') {
          if (expression.expression !== undefined) {
            expression = this._getValue(expression);
          } else {
            expression = this._getObject(expression);
          }
        }
        result[name] = expression;
        return result;
      }, {}, this);
    },

    _getValue: function (expression) {
      var complexExpression;
      // If the value needs more computing after the placeholder resolution,
      // replace the placeholders with their values first
      if (typeof expression !== 'string') {
        complexExpression = expression;
        expression = expression.expression;
      }
      // Replace the {} parameter placeholders
      expression = this._replacePlaceholders(expression);
      // Update the value if there is a complex expression
      if (complexExpression) {
        expression = this._applyValueRanges(expression, complexExpression);
        expression = this._applyValueMap(expression, complexExpression);
      }
      return expression;
    },

    _replacePlaceholders: function (expression) {
      var parameterPlaceholder = /{([^}]+)}/g,
          match, names, value;
      // Go over every parameter placeholder found
      while ((match = parameterPlaceholder.exec(expression))) {
        names = match[1].split('.');
        value = this.model.attributes;
        // Nested object property names are separated by dots
        _.find(names, function (name) {
          value = value[name];
          if (value == null) {
            value = '';
            return true;
          }
        });
        // Replace the placeholder with the value found
        expression = expression.substring(0, match.index) + value +
                     expression.substring(match.index + match[0].length);
      }
      return expression;
    },

    // Map computed result to one of the specified values
    _applyValueMap: function (value, complexExpression) {
      var valueMap = complexExpression.valueMap;
      if (valueMap) {
        value = valueMap[value];
        if (value == null) {
          value = valueMap['*'];
        }
      }
      return value;
    },

    // Choose a specific value from the result ranges
    _applyValueRanges: function (value, complexExpression) {
      var valueRanges = complexExpression.valueRanges;
      if (valueRanges) {
        var convertValue;
        if (complexExpression.type === 'Date') {
          convertValue = function converDate(value) {
            return base.parseDate(value);
          };
        } else {
          convertValue = function convertNumber(value) {
            return numeral(value).value();
          };
        }
        value = convertValue(value);
        // Find the first range which contains the expression value
        _.find(valueRanges, function (range) {
          var greaterOrEqual = range.greaterOrEqual;
          if (greaterOrEqual !== undefined) {
            greaterOrEqual = convertValue(greaterOrEqual);
            if (greaterOrEqual > value) {
              return false;
            }
          }
          var lessThan = range.lessThan;
          if (lessThan !== undefined) {
            lessThan = convertValue(lessThan);
            if (lessThan <= value) {
              return false;
            }
          }
          value = range.value;
          return true;
        });
      }
      return value;
    }

  });

  return ObjectListItem;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/listitem/impl/listitemstateful',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<span class=\"csui-type-icon "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":2,"column":52},"end":{"line":2,"column":60}}}) : helper)))
    + "\"></span>";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"SLIIcon\">\r\n      "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"enableIcon") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":2,"column":6},"end":{"line":2,"column":76}}})) != null ? stack1 : "")
    + "\r\n</div>\r\n<div class=\"SLIRightDiv\">\r\n  <div class=\"SLITitleDiv\">\r\n    <div class=\"SLITitle\">\r\n      <span title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":7,"column":19},"end":{"line":7,"column":27}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":7,"column":29},"end":{"line":7,"column":37}}}) : helper)))
    + "</span>\r\n    </div>\r\n    <div class=\"SLIDescription\">\r\n      <span title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"description") || (depth0 != null ? lookupProperty(depth0,"description") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"description","hash":{},"loc":{"start":{"line":10,"column":19},"end":{"line":10,"column":34}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"description") || (depth0 != null ? lookupProperty(depth0,"description") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"description","hash":{},"loc":{"start":{"line":10,"column":36},"end":{"line":10,"column":51}}}) : helper)))
    + "</span>\r\n    </div>\r\n  </div>\r\n  <div class=\"SLIInfo SLIInfo"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"infoState") || (depth0 != null ? lookupProperty(depth0,"infoState") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"infoState","hash":{},"loc":{"start":{"line":13,"column":29},"end":{"line":13,"column":42}}}) : helper)))
    + "\">\r\n    <span title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"info") || (depth0 != null ? lookupProperty(depth0,"info") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"info","hash":{},"loc":{"start":{"line":14,"column":17},"end":{"line":14,"column":25}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"info") || (depth0 != null ? lookupProperty(depth0,"info") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"info","hash":{},"loc":{"start":{"line":14,"column":27},"end":{"line":14,"column":35}}}) : helper)))
    + "</span>\r\n  </div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_listitem_impl_listitemstateful', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/controls/listitem/impl/listitemstateful',[],function(){});
// Shows a list of links
csui.define('csui/controls/listitem/listitemstateful.view',['csui/lib/underscore',
  'csui/lib/jquery',
  'csui/lib/marionette',
  'csui/controls/listitem/listitemstandard.view',
  'hbs!csui/controls/listitem/impl/listitemstateful',
  'css!csui/controls/listitem/impl/listitemstateful'
], function (_, $, Marionette, StandardListItem, itemTemplate) {

  var StatefulListItem = StandardListItem.extend({

    className: 'SLI binf-list-group-item',

    template: itemTemplate,

    constructor: function StatefulListItem() {
      StandardListItem.apply(this, arguments);
    }

  });

  return StatefulListItem;

});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/search/category/impl/category.item',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"csui-category-value\" role=\"listitem\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"value","hash":{},"loc":{"start":{"line":1,"column":56},"end":{"line":1,"column":65}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"value","hash":{},"loc":{"start":{"line":1,"column":79},"end":{"line":1,"column":88}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"value","hash":{},"loc":{"start":{"line":1,"column":90},"end":{"line":1,"column":99}}}) : helper)))
    + "</div>";
}});
Handlebars.registerPartial('csui_controls_table_cells_search_category_impl_category.item', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/search/category/category.popover.item.view',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'hbs!csui/controls/table/cells/search/category/impl/category.item'
], function (_, $, Marionette, template) {
  'use strict';
  var CategoryPopverItemView = Marionette.ItemView.extend({
    className: 'csui-category-item',
    tagName: 'li',
    template: template,
    templateHelpers: function () {
      return {
        value: this.model && this.model.has('value_formatted') && this.model.get('value_formatted')
      };
    },

    attributes: {
      role: 'none',
    },

    events: {
      'keydown .csui-category-value': 'accessibility',
    },

    constructor: function CategoryPopverItemView(options) {
      options || (options = {});
      this.options = options;
      Marionette.ItemView.prototype.constructor.call(this, options);
    },

    accessibility: function (event) {
      var el;
      event.preventDefault();
      event.stopPropagation();
      this.$el.find('.csui-category-value').prop('tabindex', -1);
      switch (event.keyCode) {
        case 38:
          if (this.$el.prev().length) {
            this.$el.prev().find('.csui-category-value').prop('tabindex', 0).trigger('focus');
          } else {
            el = this.options.parentView.$el.find('.csui-category-value');
            $(el[el.length - 1]).prop('tabindex', 0).trigger('focus');
          }
          break;
        case 40:
          if (this.$el.next().length) {
            this.$el.next().find('.csui-category-value').prop('tabindex', 0).trigger('focus');
          } else {
            el = this.options.parentView.$el.find('.csui-category-value');
            $(el[0]).prop('tabindex', 0).trigger('focus');
          }
          break;
        case 27:
          var searchMetadata = this.options.originatingView.popoverEl.closest('.csui-search-metadata-value');
          searchMetadata.length ? searchMetadata.trigger('focus') : this.options.originatingView.$el.trigger('focus');
          this.options.originatingView.closePopover();
          break;
      }
    },
  });
  return CategoryPopverItemView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/table/cells/search/category/impl/category.list',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<ul class=\"csui-category-list\" role=\"list\"></ul>";
}});
Handlebars.registerPartial('csui_controls_table_cells_search_category_impl_category.list', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/table/cells/search/category/category.popover.list.view',['csui/lib/underscore', 'csui/lib/marionette',
'csui/controls/table/cells/search/category/category.popover.item.view',
 'csui/controls/tile/behaviors/perfect.scrolling.behavior',
'hbs!csui/controls/table/cells/search/category/impl/category.list'
], function (_, Marionette, CategoryPopverItemView,PerfectScrollingBehavior,template) {
  'use strict';
  var CategoryPopverView = Marionette.CompositeView.extend({
    className: 'csui-category-collection',
    template: template,
    childViewContainer: '.csui-category-list',
    childView: CategoryPopverItemView,

    childViewOptions: function () {
      return {
        collection: this.options.collection,
        originatingView: this.options.originatingView,
        parentView: this,
      };
    },

    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: 'ul.csui-category-list',
        suppressScrollX: true
      }
    },

    constructor: function CategoryPopverView(options) {
      options || (options = {});
      this.options = options;
      this.collection = options.collection;
      this.originatingView = options.originatingView;
      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
    },
  });
  return CategoryPopverView;
});

/* START_TEMPLATE */
csui.define('hbs!csui/controls/toolbar/toolitem',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"hasIcon") : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.program(27, data, 0),"loc":{"start":{"line":3,"column":2},"end":{"line":49,"column":9}}})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"renderIconAndText") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.program(12, data, 0),"loc":{"start":{"line":4,"column":4},"end":{"line":39,"column":11}}})) != null ? stack1 : "");
},"5":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "      <a title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":5,"column":16},"end":{"line":5,"column":25}}}) : helper)))
    + "\" href=\"#\"\r\n                         "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"linkRole") : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"loc":{"start":{"line":6,"column":25},"end":{"line":6,"column":69}}})) != null ? stack1 : "")
    + "\r\n                         class=\"csui-toolitem "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"disabledClass") || (depth0 != null ? lookupProperty(depth0,"disabledClass") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"disabledClass","hash":{},"loc":{"start":{"line":7,"column":46},"end":{"line":7,"column":63}}}) : helper)))
    + " csui-toolitem-icon-text\" data-cstabindex=\"-1\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"iconName") : depth0),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.program(10, data, 0),"loc":{"start":{"line":8,"column":8},"end":{"line":12,"column":15}}})) != null ? stack1 : "")
    + "      </a>\r\n";
},"6":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return " role=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"linkRole") || (depth0 != null ? lookupProperty(depth0,"linkRole") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"linkRole","hash":{},"loc":{"start":{"line":6,"column":48},"end":{"line":6,"column":60}}}) : helper)))
    + "\" ";
},"8":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"on":(depth0 != null ? lookupProperty(depth0,"iconStateIsOn") : depth0),"states":"true","theme":(depth0 != null ? lookupProperty(depth0,"iconTheme") : depth0),"iconName":(depth0 != null ? lookupProperty(depth0,"iconName") : depth0)},"loc":{"start":{"line":9,"column":10},"end":{"line":9,"column":88}}})) != null ? stack1 : "")
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":9,"column":88},"end":{"line":9,"column":96}}}) : helper)))
    + "\r\n";
},"10":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "          <span class=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":11,"column":23},"end":{"line":11,"column":31}}}) : helper)))
    + "\"></span>"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":11,"column":40},"end":{"line":11,"column":48}}}) : helper)))
    + "\r\n";
},"12":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"renderTextOnly") : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.program(16, data, 0),"loc":{"start":{"line":15,"column":6},"end":{"line":38,"column":13}}})) != null ? stack1 : "");
},"13":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <a  href=\"#\"\r\n                          "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"linkRole") : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"loc":{"start":{"line":17,"column":26},"end":{"line":17,"column":70}}})) != null ? stack1 : "")
    + "\r\n                          class=\"csui-toolitem "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"disabledClass") || (depth0 != null ? lookupProperty(depth0,"disabledClass") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"disabledClass","hash":{},"loc":{"start":{"line":18,"column":47},"end":{"line":18,"column":64}}}) : helper)))
    + " csui-toolitem-textonly\"\r\n                          data-cstabindex=\"-1\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":19,"column":47},"end":{"line":19,"column":55}}}) : helper)))
    + "\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"menuWithMoreOptions") : depth0),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"loc":{"start":{"line":20,"column":10},"end":{"line":22,"column":17}}})) != null ? stack1 : "")
    + "        </a>\r\n";
},"14":function(container,depth0,helpers,partials,data) {
    return "            <span class=\"csui-button-icon csui-icon-rightArrow icon-expandArrowUp\"></span>\r\n";
},"16":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <a href=\"#\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":25,"column":27},"end":{"line":25,"column":36}}}) : helper)))
    + "\"\r\n                    "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"linkRole") : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"loc":{"start":{"line":26,"column":20},"end":{"line":26,"column":64}}})) != null ? stack1 : "")
    + "\r\n                    class=\"csui-toolitem "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"disabledClass") || (depth0 != null ? lookupProperty(depth0,"disabledClass") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"disabledClass","hash":{},"loc":{"start":{"line":27,"column":41},"end":{"line":27,"column":58}}}) : helper)))
    + " csui-toolitem-icononly\"\r\n                    data-cstabindex=\"-1\" "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"toolItemAria") : depth0),{"name":"if","hash":{},"fn":container.program(17, data, 0),"inverse":container.program(19, data, 0),"loc":{"start":{"line":28,"column":41},"end":{"line":30,"column":57}}})) != null ? stack1 : "")
    + "\r\n          "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"hasToolItemAriaExpand") : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"loc":{"start":{"line":31,"column":10},"end":{"line":31,"column":85}}})) != null ? stack1 : "")
    + ">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"iconName") : depth0),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.program(25, data, 0),"loc":{"start":{"line":32,"column":10},"end":{"line":36,"column":17}}})) != null ? stack1 : "")
    + "        </a>\r\n";
},"17":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"toolItemAria") || (depth0 != null ? lookupProperty(depth0,"toolItemAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"toolItemAria","hash":{},"loc":{"start":{"line":29,"column":38},"end":{"line":29,"column":54}}}) : helper)))
    + "\" ";
},"19":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "\r\n                           aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":30,"column":39},"end":{"line":30,"column":48}}}) : helper)))
    + "\" ";
},"21":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "aria-expanded=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"toolItemAriaExpand") || (depth0 != null ? lookupProperty(depth0,"toolItemAriaExpand") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"toolItemAriaExpand","hash":{},"loc":{"start":{"line":31,"column":54},"end":{"line":31,"column":76}}}) : helper)))
    + "\" ";
},"23":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"on":(depth0 != null ? lookupProperty(depth0,"iconStateIsOn") : depth0),"states":"true","theme":(depth0 != null ? lookupProperty(depth0,"iconTheme") : depth0),"iconName":(depth0 != null ? lookupProperty(depth0,"iconName") : depth0)},"loc":{"start":{"line":33,"column":12},"end":{"line":33,"column":90}}})) != null ? stack1 : "")
    + "\r\n";
},"25":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <span class=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":35,"column":25},"end":{"line":35,"column":33}}}) : helper)))
    + "\"></span>\r\n";
},"27":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <a href=\"#\"\r\n                    "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"linkRole") : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"loc":{"start":{"line":42,"column":20},"end":{"line":42,"column":64}}})) != null ? stack1 : "")
    + "\r\n                    class=\"csui-toolitem "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"disabledClass") || (depth0 != null ? lookupProperty(depth0,"disabledClass") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"disabledClass","hash":{},"loc":{"start":{"line":43,"column":41},"end":{"line":43,"column":58}}}) : helper)))
    + " csui-toolitem-textonly\"\r\n                    data-cstabindex=\"-1\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":44,"column":41},"end":{"line":44,"column":49}}}) : helper)))
    + "\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"menuWithMoreOptions") : depth0),{"name":"if","hash":{},"fn":container.program(28, data, 0),"inverse":container.noop,"loc":{"start":{"line":45,"column":6},"end":{"line":47,"column":13}}})) != null ? stack1 : "")
    + "    </a>\r\n";
},"28":function(container,depth0,helpers,partials,data) {
    return "        <span class=\"csui-button-icon csui-icon-rightArrow icon-expandArrowUp\"></span>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isSeparator") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"loc":{"start":{"line":1,"column":0},"end":{"line":50,"column":7}}})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_controls_toolbar_toolitem', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/toolbar/toolitem.view',['require', 'i18n',
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/mixins/view.state/toolitems.state.mixin',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'hbs!csui/controls/toolbar/toolitem',
  'csui/controls/icons.v2',
  'csui/lib/binf/js/binf'
], function (require, i18n, $, _, Backbone, Marionette,
    ToolItemsStateMixin, TabableRegionBehavior, template, iconRegistry) {
  'use strict';

  var ToolItemView = Marionette.ItemView.extend({
    tagName: 'li',

    className: function () {
      var className = this.model.get('className') || '';
      if (this.model.isSeparator()) {
        className += ' binf-divider';
      }
      return className;
    },

    attributes: function () {
      var attrs = {};
      if (this.model.isSeparator()) {
        attrs['aria-hidden'] = 'true';
      } else {
        var signature = this.model.get('signature') || '';
        //'data-csui-command' if changed must be updated in toolbar.view._setUnblocked()
        attrs['data-csui-command'] = signature.toLowerCase();
        if (signature.toLowerCase()==='add') {
          attrs['data-csui-addtype'] = this.model.get('commandData').type;
        }

        if (this.options.role) {
          attrs.role = this.options.role;
        } else  {
          attrs.role = 'none';
        }
      }
      return attrs;
    },

    ui: {
      link: 'a'
    },

    template: template,

    templateHelpers: function () {
        var configuredRole = this.model.get('toolItemRole');
        var linkRole = configuredRole ? configuredRole : this.model.isSeparator() ? 'none' : undefined;
        if (!linkRole) {
            linkRole = this.options.noMenuRoles ? undefined : 'menuitem';
        }
        var data = {
        renderIconAndText: this.options.renderIconAndText === true,
        renderTextOnly: this.options.renderTextOnly === true,
        isSeparator: this.model.isSeparator(),
        toolItemAria: this.model.get('toolItemAria'),
        hasToolItemAriaExpand: this.model.get('toolItemAriaExpand') !== undefined,
        toolItemAriaExpand: this.model.get('toolItemAriaExpand'),
        linkRole: linkRole,
        hasIcon: this._hasIcon(),
        icon: this._icon,
        iconName: this._iconName,
        iconStateIsOn: this._stateIsOn,
        iconTheme: this.options.useIconsForDarkBackground ? 'dark' : ''
      },
      command = this.options.command;
      data.disabledClass = command && command.get('selfBlockOnly') && command.get('isExecuting') ?
                           'binf-disabled' : '';
      data.title = !!this.model.get('title') ? this.model.get('title') : this.model.get('name');
      return data;
    },

    events: {
      'click a': '_handleClick',
      'keydown': 'onKeyInView'
    },

    constructor: function ToolItemView(options) {
      this.options = options || {};
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this._calculateIconName();
      this.listenTo(this.model, 'change:stateIsOn', function () {
        this._calculateIconName();
        this.render();
        this.makeFocusable();
      });
    },

    onKeyInView: function (event) {
      var target = $(event.target);
      if (event.keyCode === 32 || event.keyCode === 13) {  // space(32) & enter(13)
        this._handleClick(event, true);
        return false;
      } 
    },

    saveRenderState: function () {
      this._renderState = {};
      _.each(ToolItemView.STATE_PARAMS, function (param) {
        this._renderState[param] = this.options[param];
      }, this);
    },

    restoreRenderState: function () {
      if (this._renderState) {
        _.each(ToolItemView.STATE_PARAMS, function (param) {
          this.options[param] = this._renderState[param];
        }, this);
        this.render();
        delete this._renderState;
      }
    },

    onBeforeRender: function () {
      var hasFocusA = this.$el.find('a:focus');
      this.itemHadFocus = hasFocusA.length===1;
    },

    onRender: function () {
      if (this.itemHadFocus) {
        var theA = this.$el.find('a:visible');
        theA.attr('tabindex', 0);
        theA.addClass([TabableRegionBehavior.accessibilityFocusableClass, TabableRegionBehavior.accessibilityActiveElementClass]);
        theA[0].focus();
        this.itemHadFocus = false;
      }
    }
  }, {
    STATE_PARAMS: ['renderIconAndText', 'renderTextOnly']
  });
  _.extend(ToolItemView.prototype, ToolItemsStateMixin);
  return ToolItemView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/toolbar/impl/flyout.toolitem',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"renderIconAndText") : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(9, data, 0),"loc":{"start":{"line":2,"column":0},"end":{"line":36,"column":7}}})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <a aria-haspopup=\"true\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":3,"column":33},"end":{"line":3,"column":42}}}) : helper)))
    + "\" href=\"#\" "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"linkRole") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":3,"column":53},"end":{"line":3,"column":96}}})) != null ? stack1 : "")
    + "\r\n                     class=\"csui-toolitem csui-toolitem-icon-text\" data-cstabindex=\"-1\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"iconName") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.program(7, data, 0),"loc":{"start":{"line":5,"column":4},"end":{"line":9,"column":11}}})) != null ? stack1 : "")
    + "     <span class=\"csui-caret\"></span>\r\n  </a>\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "role=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"linkRole") || (depth0 != null ? lookupProperty(depth0,"linkRole") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"linkRole","hash":{},"loc":{"start":{"line":3,"column":75},"end":{"line":3,"column":87}}}) : helper)))
    + "\" ";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "      "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"on":(depth0 != null ? lookupProperty(depth0,"iconStateIsOn") : depth0),"states":"true","theme":(depth0 != null ? lookupProperty(depth0,"iconTheme") : depth0),"iconName":(depth0 != null ? lookupProperty(depth0,"iconName") : depth0)},"loc":{"start":{"line":6,"column":6},"end":{"line":6,"column":84}}})) != null ? stack1 : "")
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":6,"column":84},"end":{"line":6,"column":92}}}) : helper)))
    + "\r\n";
},"7":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "      <span class=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":8,"column":19},"end":{"line":8,"column":27}}}) : helper)))
    + "\"></span>"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":8,"column":36},"end":{"line":8,"column":44}}}) : helper)))
    + "\r\n";
},"9":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"renderTextOnly") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.program(13, data, 0),"loc":{"start":{"line":13,"column":2},"end":{"line":35,"column":9}}})) != null ? stack1 : "");
},"10":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <a aria-haspopup=\"true\" href=\"#\" "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"linkRole") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":14,"column":37},"end":{"line":14,"column":80}}})) != null ? stack1 : "")
    + "\r\n                      class=\"csui-toolitem csui-toolitem-textonly\"\r\n                      data-cstabindex=\"-1\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":16,"column":55},"end":{"line":16,"column":64}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":16,"column":66},"end":{"line":16,"column":74}}}) : helper)))
    + "\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"menuWithMoreOptions") : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"loc":{"start":{"line":17,"column":6},"end":{"line":19,"column":13}}})) != null ? stack1 : "")
    + "      <span class=\"csui-caret\"></span>\r\n    </a>\r\n";
},"11":function(container,depth0,helpers,partials,data) {
    return "        <span class=\"csui-button-icon csui-icon-rightArrow icon-expandArrowUp\"></span>\r\n";
},"13":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    <a aria-haspopup=\"true\" href=\"#\" title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":23,"column":44},"end":{"line":23,"column":53}}}) : helper)))
    + "\" "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"linkRole") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":23,"column":55},"end":{"line":23,"column":98}}})) != null ? stack1 : "")
    + "\r\n                       class=\"csui-toolitem "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"disabledClass") || (depth0 != null ? lookupProperty(depth0,"disabledClass") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"disabledClass","hash":{},"loc":{"start":{"line":24,"column":44},"end":{"line":24,"column":61}}}) : helper)))
    + " csui-toolitem-icononly\"\r\n                       data-cstabindex=\"-1\" "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"toolItemAria") : depth0),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.program(16, data, 0),"loc":{"start":{"line":25,"column":44},"end":{"line":27,"column":53}}})) != null ? stack1 : "")
    + "\r\n      "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"hasToolItemAriaExpand") : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0),"inverse":container.noop,"loc":{"start":{"line":28,"column":6},"end":{"line":28,"column":81}}})) != null ? stack1 : "")
    + ">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"iconName") : depth0),{"name":"if","hash":{},"fn":container.program(20, data, 0),"inverse":container.program(22, data, 0),"loc":{"start":{"line":29,"column":6},"end":{"line":33,"column":13}}})) != null ? stack1 : "")
    + "    </a>\r\n";
},"14":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"toolItemAria") || (depth0 != null ? lookupProperty(depth0,"toolItemAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"toolItemAria","hash":{},"loc":{"start":{"line":26,"column":34},"end":{"line":26,"column":50}}}) : helper)))
    + "\" ";
},"16":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "\r\n                       aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":27,"column":35},"end":{"line":27,"column":44}}}) : helper)))
    + "\" ";
},"18":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "aria-expanded=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"toolItemAriaExpand") || (depth0 != null ? lookupProperty(depth0,"toolItemAriaExpand") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"toolItemAriaExpand","hash":{},"loc":{"start":{"line":28,"column":50},"end":{"line":28,"column":72}}}) : helper)))
    + "\" ";
},"20":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"on":(depth0 != null ? lookupProperty(depth0,"iconStateIsOn") : depth0),"states":"true","theme":(depth0 != null ? lookupProperty(depth0,"iconTheme") : depth0),"iconName":(depth0 != null ? lookupProperty(depth0,"iconName") : depth0)},"loc":{"start":{"line":30,"column":8},"end":{"line":30,"column":86}}})) != null ? stack1 : "")
    + "\r\n";
},"22":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <span class=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"icon") || (depth0 != null ? lookupProperty(depth0,"icon") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon","hash":{},"loc":{"start":{"line":32,"column":21},"end":{"line":32,"column":29}}}) : helper)))
    + "\"></span>\r\n";
},"24":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<a  aria-haspopup=\"true\" href=\"#\" "
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"linkRole") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"loc":{"start":{"line":38,"column":34},"end":{"line":38,"column":77}}})) != null ? stack1 : "")
    + "\r\n                   class=\"csui-toolitem "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"disabledClass") || (depth0 != null ? lookupProperty(depth0,"disabledClass") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"disabledClass","hash":{},"loc":{"start":{"line":39,"column":40},"end":{"line":39,"column":57}}}) : helper)))
    + " csui-toolitem-textonly\"\r\n                   data-cstabindex=\"-1\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":40,"column":52},"end":{"line":40,"column":61}}}) : helper)))
    + "\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"loc":{"start":{"line":40,"column":63},"end":{"line":40,"column":71}}}) : helper)))
    + "\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"menuWithMoreOptions") : depth0),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"loc":{"start":{"line":41,"column":2},"end":{"line":43,"column":9}}})) != null ? stack1 : "")
    + "   <span class=\"csui-caret\"></span>\r\n</a>\r\n";
},"25":function(container,depth0,helpers,partials,data) {
    return "    <span class=\"csui-button-icon csui-icon-rightArrow icon-expandArrowUp\"></span>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"hasIcon") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(24, data, 0),"loc":{"start":{"line":1,"column":0},"end":{"line":46,"column":7}}})) != null ? stack1 : "")
    + "<ul class=\"binf-dropdown-menu\" role=\"menu\"></ul>\r\n";
}});
Handlebars.registerPartial('csui_controls_toolbar_impl_flyout.toolitem', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/toolbar/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/toolbar/impl/nls/root/localized.strings',{

  // toolbar.state.view
  loadingActionsMessage: 'Loading actions...',
  failedActionsMessage: 'Loading actions failed.',
  showMoreLabel: 'show more actions'

});


csui.define('csui/controls/toolbar/flyout.toolitem.view',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/controls/toolbar/toolitem.view',
  'csui/utils/base',
  'csui/controls/mixins/view.state/toolitems.state.mixin',
  'hbs!csui/controls/toolbar/impl/flyout.toolitem',
  'i18n!csui/controls/toolbar/impl/nls/localized.strings'
], function (_, $, Marionette, ToolItemView, base, ToolItemsStateMixin, template, lang) {
  'use strict';

  var FlyoutToolItemView = Marionette.CompositeView.extend({
    tagName: 'li',
    className: 'csui-flyout binf-dropdown-submenu binf-pull-down',
    attributes: function () {
      var signature = this.model.get('signature') || '';
      var attrs = {};
      if (this.model.isSeparator()) {
        attrs['aria-hidden'] = 'true';
      }
      else {
        attrs['data-csui-command'] = signature.toLowerCase();
        if (this.options.role) {
          attrs.role = this.options.role;
        } else {
          attrs.role = 'none';
        }
      }
      return attrs;
    },

    onDomRefresh: function () {
      if (this.$el.parent('.csui-toolbar, .csui-table-actionbar > ul.binf-nav').length) {
        this.$el.addClass('binf-pull-down');
      } else {
        this.$el.removeClass('binf-pull-down');
      }
      if (this.$el.hasClass('binf-open')) {
        this.$el.trigger('click'); // Hide dropdown
      }
    },
    template: template,
    templateHelpers: function () {
      var command = this.options.command;
      return {
        name: this.model.get('name'),
        renderIconAndText: this.options.renderIconAndText === true,
        renderTextOnly: this.options.renderTextOnly === true,
        expandTitle: lang.showMoreLabel,
        toolItemAria: this.model.get("toolItemAria"),
        hasToolItemAriaExpand: this.model.get("toolItemAriaExpand") !== undefined,
        toolItemAriaExpand: this.model.get("toolItemAriaExpand"),
        hasIcon: this._hasIcon(),
        icon: this._icon,
        iconName: this._iconName,
        iconStateIsOn: this._stateIsOn,
        iconTheme: this.options.useIconsForDarkBackground ? 'dark' : '',
        disabledClass: command && command.get('selfBlockOnly') && command.get('isExecuting') ?
        'binf-disabled' : '',
        title: !!this.model.get('title') ? this.model.get('title') : this.model.get('name'),
        linkRole: this.options.noMenuRoles ? undefined : 'menuitem'
      };
    },

    childViewContainer: '.binf-dropdown-menu',

    getChildView: function (item) {
      return item.toolItems && item.toolItems.length ? FlyoutToolItemView : ToolItemView;
    },

    childViewOptions: function () {
      return {
       renderTextOnly:true
      };
    },

    childEvents: {
      'toolitem:action': function (childView, args) {
        this.triggerMethod('toolitem:action', args);
        this.$el.data('binf.dropdown.submenu') && this.$el.data('binf.dropdown.submenu').hide();
      }
    },

    ui: {
      link: 'a.csui-toolitem'
    },

    events: {
      'click @ui.link': 'activeSubmenu'
    },

    onRender: function () {
      this.$el.binf_dropdown_submenu();
      this.$el.off('dom:refresh').on('dom:refresh', _.bind(this.onDomRefresh, this));
      this.$el.off('binf.dropdown.submenu.after.show')
        .on('binf.dropdown.submenu.after.show', _.bind(function (event) {
          if (this.$el.parent().hasClass('csui-toolbar') || !(this.$el.hasClass('binf-pull-down'))) {
            var $dropdownMenu = this.$el.children().last();
            base.alignDropDownSubMenus({ targetEl: this.$el, dropdownMenu: $dropdownMenu });
          }
        },this));
    },

    constructor: function FlyoutToolItemView(options) {
      this.options = options || {};
      this.collection = options.collection || (options.model && options.model.toolItems);
      this.model = this.options.model;
      this._calculateIconName();
      Marionette.CompositeView.prototype.constructor.apply(this, arguments);
      this.listenTo(this.collection, 'add change reset', function (models) {
        if(this.el && this.el.offsetWidth > 0 && this.el.offsetHeight > 0){
          return;
        } else{
          this._calculateIconName();
          this.render();
        }
      });
    },
    onKeyInView: function (event) {
      var target = $(event.target);
      if (event.keyCode === 13) {
        this._handleClick(event);
        return false;
      }
    },

    activeSubmenu: function (event) {
      if (base.isAppleMobile()) {
        var active = $(event.target).attr('aria-expanded') === 'true' ? true : false,
          submenuParent = this.$el.parent('ul.binf-dropdown-menu');
        if (!active) {
          submenuParent.addClass('csui-submenu-active');
        } else {
          submenuParent.removeClass('csui-submenu-active');
        }
      }
    },

    saveRenderState: function () {
      this._renderState = {};
      _.each(FlyoutToolItemView.STATE_PARAMS, function (param) {
        this._renderState[param] = this.options[param];
      }, this);
    },

    restoreRenderState: function () {
      if (this._renderState) {
        _.each(FlyoutToolItemView.STATE_PARAMS, function (param) {
          this.options[param] = this._renderState[param];
        }, this);
        this.render();
        delete this._renderState;
      }
    },
  },
  {
    STATE_PARAMS: ['renderIconAndText', 'renderTextOnly']
  });
  _.extend(FlyoutToolItemView.prototype, ToolItemsStateMixin);
  return FlyoutToolItemView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/toolbar/impl/toolitem.custom',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class='custom-view-region'></div>\r\n";
}});
Handlebars.registerPartial('csui_controls_toolbar_impl_toolitem.custom', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/toolbar/toolitem.custom.view',[
  'module', 'csui/lib/underscore', 'csui/lib/marionette', 'csui/utils/commandhelper',
  'csui/controls/mixins/layoutview.events.propagation/layoutview.events.propagation.mixin',
  'hbs!csui/controls/toolbar/impl/toolitem.custom', 'csui/utils/log', 'csui/lib/binf/js/binf'
], function (module, _, Marionette, CommandHelper, LayoutViewEventsPropagationMixin, template, log) {
  'use strict';

  log = log(module.id);

  //
  // Special ToolItemCustomView that shows a dynamic custom view (not a regular toolbar icon)
  //
  var ToolItemCustomView = Marionette.LayoutView.extend({

    tagName: 'li',

    attributes: function () {
      var attrs = {id: _.uniqueId(this.model.get("signature"))};
      if (this.options.role) {
        attrs.role = this.options.role;
      } else {
        attrs.role = 'none';
      }
      return attrs;
    },

    template: template,

    regions: {
      customViewRegion: '.custom-view-region'
    },

    ui: {
      customViewDiv: '.custom-view-region'
    },

    events: {
      'keydown': 'onKeyInView',
      'click': '_clickToolItem'
    },

    destroy: function() {
      if (!this.customViewRegion || !this.customViewRegion.currentView) {
        this.customView && this.customView.destroy();
      }

      return Marionette.LayoutView.prototype.destroy.apply(this, arguments);
    },

    constructor: function ToolItemCustomView(options) {
      options || (options = {});
      Marionette.LayoutView.prototype.constructor.apply(this, arguments);
      this.propagateEventsToRegions();
    },

    className: function () {
      var className = this.model.get("className") || '';
      return className;
    },

    _disable: function () {
      this._wasFocusable = this._wasFocusable || this.ui.customViewDiv.hasClass('csui-acc-focusable');
      this.$el.addClass('binf-hidden');
      this.ui.customViewDiv.removeClass('csui-acc-focusable');
    },

    _enable: function () {
      this.$el.removeClass('binf-hidden');
      if (this._wasFocusable) {
        this.ui.customViewDiv.addClass('csui-acc-focusable');
      }
    },

    onRender: function () {
      var customViewClass = this.model.get('viewClass');
      if (customViewClass) {
        var model;
        var status = this.model.status;
        var commandData = this.model.get('commandData');
        if (commandData && commandData.useContainer === true) {
          model = status && status.container;
        } else {
          model = status && CommandHelper.getJustOneNode(status);
        }
        var context = this.options.context || (status && status.context);
        var options = {
          model: model,
          context: context,
          status: status,
          toolbarCommandController: this.options.toolbarCommandController,
          toolbarItemsMask: this.options.toolbarItemsMask,
          originatingView: this.options.originatingView,
          blockingParentView: this.options.blockingParentView,
          useIconsForDarkBackground: this.options.useIconsForDarkBackground
        };
        if (commandData && commandData.viewOptions) {
          _.extend(options, commandData.viewOptions);
        }
        this.customView = new customViewClass(options);
        if (this.customView.enabled) {
          // customView has the enabled() method, call it first to check
          try {
            if (this.customView.enabled()) {
              this.customViewRegion.show(this.customView);
            } else {
              this._disable();
            }
          } catch (error) {
            log.warn('Rendering an custom toolitem view failed.\n{0}',
                error.message) && console.warn(log.last);
          }
        } else {
          // customView does not implement the enabled() method
          this.customViewRegion.show(this.customView);
        }
      } else {
        this._disable();
      }
    },

    onShow: function () {
      _.each(this.regionManager._regions, function (region) {
        if (region.currentView) {
          region.currentView.triggerMethod('show');
        }
      });
    },

    onAfterShow: function () {
      _.each(this.regionManager._regions, function (region) {
        if (region.currentView) {
          region.currentView.triggerMethod('after:show');
        }
      });
    },

    _clickToolItem: function (e) {
      e.preventDefault();
      this.ui.customViewDiv.prop('tabindex', '0');
      this.ui.customViewDiv.trigger('focus');
      this._closeDropdownToggleOnClick();
      // only trigger click on customView if the event was not propagated from customView
      if (this.customView.el !== e.target && this.customView.$el.find(e.target).length === 0) {
        this.customView.$el.trigger('click');
      }
    },

    _closeDropdownToggleOnClick: function () {
      var dropdownEl = this.$el.closest('li.binf-dropdown.binf-open');
      var dropdownToggleEl = dropdownEl.find('.binf-dropdown-toggle');
      dropdownToggleEl.binf_dropdown('toggle');  // close the dropdown menu before triggering the event
    },

    onKeyInView: function (event) {
      if (event.keyCode === 32 || event.keyCode === 13) {  // space (32) or enter (13)
        this._clickToolItem(event);
      }
    },

    onUpdateEnabled: function () {
      // A custom tool item view without a custom view to host is always empty.
      var customViewClass = this.model.get('viewClass');
      if (customViewClass) {
        // Custom views without an enabling method are always shown during
        // the first rendering.
        if (this.customView.enabled) {
          if (this.customView.enabled()) {
            this._enable();
            // If the initial state was disabled during the first rendering,
            // The custom view was not rendered and attached to DOM.
            if (!this.customViewRegion.currentView) {
              this.customViewRegion.show(this.customView);
            }
          } else {
            this._disable();
          }
        }
      }
    }
  });

  _.extend(ToolItemCustomView.prototype, LayoutViewEventsPropagationMixin);

  return ToolItemCustomView;
});

csui.define('csui/controls/toolbar/toolitems.view',[
  'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/toolbar/toolitem.view',
  'csui/controls/toolbar/flyout.toolitem.view',
  'csui/controls/toolbar/toolitem.custom.view'
], function (Backbone, Marionette, ToolItemView, FlyoutToolItemView,
    ToolItemCustomView) {
  'use strict';

  var ToolItemsView = Marionette.CollectionView.extend({
    tagName: "ul",

    attributes: function () {
      var attrs = {};
      if (this.options.role) {
        attrs.role = this.options.role;
      } else if (this.options.noMenuRoles) {
        attrs.role = 'none';
      } else {
        attrs.role = 'menu';
      }
      return attrs;
    },

    getChildView: function (item) {
      // Choose which view class to render, depending on the properties of the item model
      var customView = item.get('customView');

      // dynamic user-defined custom view
      var viewClass = item.get('viewClass');
      if (customView === true && viewClass && viewClass.prototype instanceof Backbone.View) {
        return ToolItemCustomView;
      }

      if (customView) {
        if (customView === true) {
          // TODO: Deprecate this. Commands cannot resolve view modules
          // synchronously in the enable method.
          return item.get('commandData').customView || ToolItemView;
        }
        if (customView.prototype instanceof Backbone.View) {
          return customView;
        }
        if (typeof customView === 'string') {
          // TODO: handle unresolvable tool item
        }
      }

      return item.get('flyout') ? FlyoutToolItemView : ToolItemView;
    },

    childViewOptions: function (model) {
      return {
        toolbarCommandController: this.options.toolbarCommandController,
        toolbarItemsMask: this.options.toolbarItemsMask,
        originatingView: this.options.originatingView,
        blockingParentView: this.options.blockingParentView,
        noMenuRoles: this.options.noMenuRoles,
        useIconsForDarkBackground: this.options.useIconsForDarkBackground
      };
    },

    collectionEvents: {
      remain: '_updateCustomViews'
    },

    constructor: function ToolItemsView(options) {
      Marionette.CollectionView.prototype.constructor.apply(this, arguments);
    },

    _updateCustomViews: function () {
      // Only custom tool item views can be shown/hidden dynamically. Normal
      // tool item views are driven by command-enabling and adding/removing
      // of tool items. No need for triggering update events on them.
      this.children
          .filter(function (view) {
            return view instanceof ToolItemCustomView;
          })
          .forEach(function (view) {
            view.triggerMethod('update:enabled');
          });
    }
  });

  return ToolItemsView;
});

csui.define('csui/controls/toolbar/toolitem.model',[
  'csui/lib/underscore', 'csui/lib/backbone'
], function (_, Backbone) {
  'use strict';

  var ToolItemModel = Backbone.Model.extend({
    idAttribute: null,

    isSeparator: function () {
      return this.get('signature') == ToolItemModel.separator_signature;
    }
  });

  ToolItemModel.createSeparator = function () {
    return new ToolItemModel({signature: ToolItemModel.separator_signature});
  };

  ToolItemModel.separator_signature = '-';

  return ToolItemModel;
});

csui.define('csui/controls/toolbar/toolitems.factory',[
  'csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/utils/base', 'csui/controls/toolbar/toolitem.model'
], function (_, Backbone, Marionette, base, ToolItemModel) {
  'use strict';

  // ToolItemCollection to be filled on the first usage, preventing circular
  // dependency between ToolItemCollection and ToolItemModel.
  var ToolItemsFactory = Marionette.Object.extend({
    constructor: function ToolItemsFactory(toolItemDefinitions, options) {
      this.collection = new Backbone.Collection([], {model: ToolItemModel});
      this.runsInTouchBrowser = options && options.runsInTouchBrowser !== undefined ?
                                options.runsInTouchBrowser : base.isTouchBrowser();
      if (toolItemDefinitions instanceof ToolItemsFactory) { // cloning
        this.collection.reset(toolItemDefinitions.collection.toJSON());
      } else {
        this.set(toolItemDefinitions);
      }
      Marionette.Object.prototype.constructor.call(this, options);
    },

    clone: function () {
      return new ToolItemsFactory(this, this.options);
    },

    set: function (tooItemDefinitions) {
      if (_.isArray(tooItemDefinitions)) {
        _.each(tooItemDefinitions, function (toolItemDefinition) {
          this._setToolItemDefinition(toolItemDefinition);
        }, this);
      } else {
        this._setToolItemDefinition(tooItemDefinitions);
      }
    },

    addItem: function (newToolItem) {
      var group = newToolItem.get('group');
      var foundGroup = false;
      var prevToolItemIndex;

      if (newToolItem.get('onlyInTouchBrowser')) {
        // toolbar item is marked to be enabled only if running in touch browser ->
        if (this.runsInTouchBrowser) {
          // not adding the toolbar item, because running in touch browser
          return;
        }
      }

      this.collection.find(function (toolItem, index) {
        if (toolItem.get('group') === group) {
          //prevToolItemIndex = index;
          foundGroup = true;
        } else {
          if (foundGroup) {
            prevToolItemIndex = index;
            return true;  // stop loop because we found it and now it's different again
          }
        }
      });

      if (foundGroup && prevToolItemIndex) {
        this.collection.add(newToolItem, {at: prevToolItemIndex});
      } else {
        this.collection.add(newToolItem);
      }
    },

    reset: function (models) {
      this.collection.reset(models);
      //_.each(models, function(model){
      //  this.collection.add(model);
      //}, this);
    },

    getCollection: function () {
      return this.collection;
    },

    // merge with existing items by group
    _setToolItemDefinition: function (toolItemDefinition) {
      var runsInTouchBrowser = this.runsInTouchBrowser;
      if (this.collection.length === 0) {
        var toolItemsFlat = [];
        _.each(toolItemDefinition, function (toolItems, key) {
          // TODO: Pin the tool item group to its position without an artificial disabled tool item.
          // Start the group with an invisible (always disabled) item. If it
          // is empty, or no item will be added below, its order among other
          // groups would not be preserved.
          toolItemsFlat.push({
            signature: 'disabled',
            group: key
          });
          _.each(toolItems, function (toolItem) {
            if (!toolItem.onlyInTouchBrowser || runsInTouchBrowser) {
              // toolbar item is marked to be enabled only if running in touch browser ->
              // adding the toolbar item, because NOT running in touch browser
              if (!toolItem.group) {
                _.extend(toolItem, {group: key});
              }
              toolItemsFlat.push(toolItem);
            }
          });
        });
        this.collection.reset(toolItemsFlat);
      } else {
        // todo: merge with existing collection
      }
    }
  }, {
    cloneToolbarItems: function (toolbarItems) {
      return Object
        .keys(toolbarItems)
        .filter(function (toolbarName) {
          return toolbarName !== 'clone';
        })
        .reduce(function (result, toolbarName) {
          result[toolbarName] = toolbarItems[toolbarName].clone();
          return result;
        }, {});
    }
  });

  return ToolItemsFactory;
});

csui.define('csui/controls/toolbar/toolitems.filtered.model',[
  'module', 'require', 'csui/lib/underscore', 'csui/lib/jquery',
  'csui/lib/backbone', 'csui/controls/toolbar/toolitem.model',
  'csui/controls/toolbar/toolitems.factory', 'csui/utils/commands',
  'csui/utils/log'
], function (module, require, _, $, Backbone, ToolItemModel, ToolItemsFactory,
    commands, log) {
  'use strict';

  log = log(module.id);

  var FilteredToolItemsCollection = Backbone.Collection.extend({
    constructor: function FilteredToolItemsCollection(models, options) {
      if (_.isArray(models)) {
        this.unfilteredModels = models; // save for re-filter
      } else {
        if (models instanceof ToolItemsFactory) {
          var collection = models.getCollection();
          this.unfilteredModels = collection.models;
          this.listenTo(collection, 'add', this.refilter, this)
          .listenTo(collection, 'remove', this.refilter, this)
          .listenTo(collection, 'reset', function () {
            this.unfilteredModels = collection.models;
            this.refilter();
          }, this);
        } else {
          if (models instanceof Backbone.Collection &&
              models.model instanceof ToolItemModel) {
            this.unfilteredModels = models.models;
          }
        }
      }

      options || (options = {});
      this.commands = options.commands || commands;
      this.addTrailingDivider = models.options ? models.options.addTrailingDivider :
                                options.addTrailingDivider;
      this.addGroupSeparators = models.options ? models.options.addGroupSeparators !== false :
                                options.addGroupSeparators !== false;
      this.suppressGroupSeparators = models.options ? models.options.suppressGroupSeparators :
                                     options.suppressGroupSeparators;
      this.setStatus(options.status);
      this.delayedActions = options.delayedActions;
      this.mask = options.mask;
      this._filtering = 0;

      Backbone.Collection.prototype.constructor.call(this,
          this.unfilteredModels, options);

      if (this.delayedActions) {
        this.listenTo(this.delayedActions, 'sync', this.refilter)
        .listenTo(this.delayedActions, 'error', this.refilter);
      }
      if (this.mask) {
        this.listenTo(this.mask, 'update', this.refilter);
      }
    },

    sort: function (options) {
      options || (options = {});
      var array = this.models,
          comparator = function (leftIndex, rightIndex) {
            var thisLazy = !!array[leftIndex].get('csuiNonPromotedItem'),
                otherLazy = !!array[rightIndex].get('csuiNonPromotedItem');
            if (!thisLazy && otherLazy) {
              return -1;
            } else if (thisLazy && !otherLazy) {
              return 1;
            }
            return (leftIndex - rightIndex);
          };
      this.models = array
      .map(function (item, index) {
        return index;
      })
      .sort(comparator)
      .map(function (index) {
        return array[index];
      });
      if (!options.silent) {
        this.trigger('sort', this, options);
      }
      return this;
    },

    destroy: function () {
      this.stopListening();
    },

    refilter: function () {
      if (this._isActive === false) {
        // Collection set to be inactive, no filtering required.
        return;
      }
      // A tool item can be changed during collection filtering;
      if (!this._filtering) {
        ++this._filtering;
        // Make sure, that custom view classes have been resolved,
        // before the tool items are added to the collection
        var resolving = this._resolveCustomViews();
        if (resolving) {
          resolving.always(updateCollection.bind(this));
        } else {
          updateCollection.call(this);
        }
      }

      function updateCollection() {
        var filteredModels = this.filterModels(this.unfilteredModels);
        var doReset = this.length !== filteredModels.length || this._forceResetOnNextRefilter;
        if (!doReset) {
          doReset = this.some(function (exCommand, index) {
            var newCommand = filteredModels[index];
            return (!_.isEqual(exCommand.attributes, newCommand.attributes)
                    || !_.isEqual(exCommand.toolItems, newCommand.toolItems));
          });
        }
        if (doReset) {
          var resetOptions = (!!this.silentFetch && !this._forceResetOnNextRefilter) ?
              {silent: true} : undefined;
          this.reset(filteredModels, resetOptions);
          delete this._forceResetOnNextRefilter;
        } else {
          // Although no tool item changed since the last re-filtering, custom
          // tool item views amy need an update. (Normal tool item views are
          // added and removed together with their tool item models. Custom
          // tool item views may be always enabled and show/hide themselves
          // during the first rendering or when they get notified by this.
          this.trigger('remain', this);
        }
        this.silentFetch = false;
        --this._filtering;
      }
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function (models, options) {
      if (!this._filtering) {
        models = this.filterModels(models);
      }
      // call the original set with the filtered list of models
      return Backbone.Collection.prototype.set.call(this, models, options);
    },

    setStatus: function (status) {
      if (status) {
        if (this.status) {
          if (this.status.nodes) {
            this.status.nodes.remove(this.status.container);
            this.stopListening(this.status.nodes);
          }
          this.status.container && this.stopListening(this.status.container);
        }
        this.status = status;

        if (status.nodes) {
          var listenEvents = ['change', 'reset'];
          listenEvents = _.union(listenEvents, status.listenEvents);
          var events = listenEvents.join(' ');

          this.listenTo(status.nodes, events, this.refilter);
        }
        if (status.container) {
          this.listenTo(status.container, 'change', this.refilter);
        }
      }
    },

    updateStatus: function (updates) {
      this.status = _.extend({}, this.status, updates);
    },

    setActive: function (isActive) {
      if (this._isActive === false && this._isActive !== isActive) {
        // Viewport may be changed after last active state of commands.
        // Hence force reset on next refilter even though commands not changed.
        this._forceResetOnNextRefilter = true;
      }
      this._isActive = isActive;
    },

    filterModels: function (models) {
      // Prevent re-entering of the tool item filtering code
      ++this._filtering;
      // FIlter and adapt tool item models to back up a toolbar view
      var filteredModels = this._filterToolItems(models);
      // Make subitems and remove empty flyouts
      filteredModels = _.reject(filteredModels, function (model) {
        if (model.toolItems) {
          var subItems = this._makeSubItems(model.toolItems);
          if (subItems.length) {
            subItems = removeExtraGroupSeparators.call(this, subItems);
            model.toolItems.set(subItems, {silent: true});
          } else {
            return this._checkCommandEnableOrDisable(model);
          }
        }
      }, this);

      filteredModels = removeExtraGroupSeparators.call(this, filteredModels);

      --this._filtering;
      return filteredModels;

      function removeExtraGroupSeparators(allModels) {
        //After removing empty submenus, remove extra group sepeartors
        var previousModelisSeperator,
            filterdItems = _.reject(allModels, function (model) {
              if (model.isSeparator()) {
                if (!!previousModelisSeperator) {
                  return true;
                } else {
                  previousModelisSeperator = true;
                }
              } else {
                previousModelisSeperator = false;
              }
            }, this);
        //Remove if last item was separator from filtered Items.
        filterdItems.length && filterdItems[filterdItems.length - 1].isSeparator() &&
        filterdItems.pop();
        return filterdItems;
      }
    },

    // check whether the command is enabled or disabled
    _checkCommandEnableOrDisable: function (model) {
      var signature = model.get('signature'),
          command = signature && this.commands.get(signature);
      if (command) {
        var data = _.extend({}, this.status.data, model.get('commandData')),
            status = _.defaults({
              toolItem: model,
              data: data
            }, this.status);
        return isCommandDisabled(model, command, status);
      } else {
        return true;
      }
    },

    // Make subitems and remove disabled flyout and its subitem
    _makeSubItems: function (toolitems) {
      var subItems = _.reject(toolitems.models, function (flyout) {
        if (flyout.get('subItemOf')) {
          var flyoutitem = toolitems.find({signature: flyout.get('subItemOf')});
          if (flyoutitem !== undefined) {
            flyoutitem.toolItems.push(flyout);
            return true;
          }
        }
      }, this);

      return _filterSubMenuToolItems.call(this, subItems);

      // Iterate till the last subitem
      // Check whether it is enabled or disable based on it
      // It will disable the parents item
      function _filterSubMenuToolItems(subToolitems) {
        return _.reject(subToolitems, function (model) {
          if (!model.toolItems || (model.toolItems && model.toolItems.length === 0)) {
            if (!model.isSeparator()) {
              return this._checkCommandEnableOrDisable(model);
            }
          } else {
            var sublevelItems = _filterSubMenuToolItems.call(this, model.toolItems.models);
            
              sublevelItems.length && sublevelItems[0].isSeparator() && sublevelItems.shift();
              sublevelItems.length && sublevelItems[sublevelItems.length - 1].isSeparator() && sublevelItems.pop();
              if(sublevelItems.length) {
                model.toolItems.set(sublevelItems, {silent: true});
              }else {
                return true;
              }
          }
        }, this);
      }
    },

    _filterToolItems: function (models) {
      var filteredModels = new Backbone.Collection(undefined,
          {model: ToolItemModel});
      _.each(models, function (model) {
        if (this.mask && !this.mask.passItem(model)) {
          return;
        }
        model = model.clone();
        var flyout = model.get('flyout'),
            toolItems = filteredModels;
        // Redirect flyout items
        if (flyout) {
          var flyoutItem = filteredModels.findWhere({flyout: flyout});
          if (flyoutItem) {
            toolItems = flyoutItem.toolItems;
          }
          model.toolItems = new Backbone.Collection(undefined,
              {model: ToolItemModel});
        }
        var command = this.commands.get(model.get('signature')),
            // TODO: Remove this. Custom views should be either non-enablable,
            // or support a static enabling method, or use always a command for it.
            forceEnabled = model.get('enabled');
        if (command) {
          var data = _.extend({}, this.status.data, model.get('commandData')),
              status = _.defaults({
                toolItem: model,
                data: data
              }, this.status);
          if (command.isNonPromoted && !!command.isNonPromoted(status)) {
            model.set('csuiNonPromotedItem', true);
          }
          if (isCommandDisabled(model, command, status) && !forceEnabled) {
            // Reject the action if the command is disabled
            model = null;
          } else if (flyout) {
            // Populate sub-actions of dynamic flyouts
            var actions = model.get('actions');
            if (actions) {
              actions = new Backbone.Collection(actions,
                  {model: ToolItemModel});
              actions = this._filterToolItems(actions.models);
              model.toolItems.reset(actions);
            }
          }
        } else if (!model.toolItems && !forceEnabled) {
          // Reject the action without an command. If this item is the main
          // flyout item, do not reject it; it may be populated later.
          model = null;
        }
        if (model) {
          // Place the item correctly to its group
          var group = model.get('group'),
              subItem = model.get('subItemOf'),
              index = toolItems.findLastIndex(function (model) {
                return model.get('group') === group;
              });

          if (index < 0) {
            if (toolItems.length > 0 && this.addGroupSeparators &&
                !this.suppressGroupSeparators) {
              var separator = ToolItemModel.createSeparator();
              !!subItem && (separator.set({'subItemOf': subItem, silent: true}));
              toolItems.push(separator);
            }
            toolItems.push(model);
          } else {
            toolItems.add(model, {at: index + 1});
          }
          // TODO: Remove this as soon as custom views tool items are improved.
          model.status = this.status;
        }

      }, this);
      return filteredModels.models;
    },

    _resolveCustomViews: function () {
      var customToolItems = this.unfilteredModels.filter(function (toolItem) {
        return typeof toolItem.get('customView') === 'string';
      });
      if (!customToolItems.length) {
        return;
      }
      var customModules = customToolItems.map(function (toolItem) {
            return toolItem.get('customView');
          }),
          deferred = $.Deferred();
      require(customModules,
          function () {
            for (var i = 0, count = customModules.length; i < count; ++i) {
              customToolItems[i].set('customView', arguments[i]);
            }
            deferred.resolve();
          }, function (error) {
            for (var i = 0, count = customModules.length; i < count; ++i) {
              customToolItems[i].set('customView', error);
            }
            deferred.reject(error);
          });
      return deferred.promise();
    }
  });

  function isCommandDisabled(model, command, status) {
    try {
      return command.enabled && !command.enabled(status, {
        data: model.get('commandData')
      });
    } catch (error) {
      log.warn('Evaluating the command "{0}" failed.\n{1}',
          command.get('signature'), error.message) && console.warn(log.last);
      // Disable commands, that failed their validation.
      return true;
    }
  }

  return FilteredToolItemsCollection;
});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/toolbar/impl/lazy.loading.template',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<li role=\"none\" class=\"csui-loading-parent-wrapper binf-disabled\">\r\n  <span class=\"csui-loading-dots-wrapper\">\r\n    <span class=\"csui-loading-dot\"></span>\r\n    <span class=\"csui-loading-dot\"></span>\r\n    <span class=\"csui-loading-dot\"></span>\r\n  </span>\r\n</li>";
}});
Handlebars.registerPartial('csui_controls_toolbar_impl_lazy.loading.template', t);
return t;
});
/* END_TEMPLATE */
;
/**
 * This class will be removed as soon as SVF-1020 got resolved.
 * For the respective document, please do follow smart/utils/high.contrast/doc/detector.md file.
 */


csui.define('csui/utils/high.contrast/detector',[],function () {
  'use strict';

  var highContrast;

  function detectHighContrast() {
    // See https://github.com/hanshillen/HCMDS
    var testBackgroundColor = "rgb(127, 127, 127)";
    var lightBackgroundColor = "rgb(255, 255, 255)";
    // var darkBackgroundColor = "rgb(0, 0, 0)";
    var div = document.createElement('div');
    var style = div.style;
    style.backgroundColor = testBackgroundColor;
    style.borderWidth = '1px';
    style.borderStyle = 'solid';
    style.borderTopColor = '#ff0000';
    style.borderRightColor = '#00ffff';
    style.position = 'absolute';
    style.left = '-9999px';
    style.width = div.style.height = '2px';
    var body = document.body;
    body.appendChild(div);
    style = window.getComputedStyle(div);
    var backgroundColor = style.backgroundColor;
    if (backgroundColor === testBackgroundColor) {
      highContrast = 0;
    } else {
      if (backgroundColor === lightBackgroundColor) {
        highContrast = 2; // dark on light
      } else {
        highContrast = 1; // light on dark
      }
    }

    //    highContrast = style.borderTopColor === style.borderRightColor;
    body.removeChild(div);
    var method = highContrast ? 'add' : 'remove';
    var hcMode = 'csui-highcontrast-light-on-dark';
    if (highContrast === 2) {
      hcMode = 'csui-highcontrast-dark-on-light';
    }
    document.documentElement.classList[method]('csui-highcontrast');
    document.documentElement.classList[method](hcMode);
  }

  return {
    load: function (name, _require, onLoad, config) {
      function ensureHighContrastDetection() {
        if (document.readyState === 'complete') {
          if (highContrast === undefined) {
            detectHighContrast();
          }
          onLoad(highContrast);
          return true;
        }
      }

      if (config.isBuild) {
        onLoad(null);
      } else {
        if (!ensureHighContrastDetection()) {
          document.addEventListener('readystatechange',
              ensureHighContrastDetection);
        }
      }
    }
  };
});



csui.define('css!csui/controls/toolbar/impl/toolbar',[],function(){});
csui.define('csui/controls/toolbar/toolbar.view',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/lib/marionette', 'csui/controls/toolbar/toolitem.view',
  'csui/controls/toolbar/flyout.toolitem.view',
  'csui/controls/toolbar/toolitem.custom.view',
  'csui/controls/toolbar/toolitems.view',
  'csui/models/nodes',
  'csui/controls/toolbar/toolitems.filtered.model',
  'hbs!csui/controls/toolbar/impl/lazy.loading.template',
  "csui/controls/tile/behaviors/perfect.scrolling.behavior",
  'csui/utils/base',
  'csui/utils/high.contrast/detector!',
  'csui/controls/globalmessage/globalmessage',
  'csui/controls/icons.v2',
  'css!csui/controls/toolbar/impl/toolbar'
], function (_, $, Backbone, Marionette, ToolItemView, FlyoutToolItemView,
    ToolItemCustomView, ToolItemsView, NodeCollection, FilteredToolItemsCollection,
    lazyloadingTemplate,
    PerfectScrollingBehavior, base, highContrast,
    GlobalMessage, iconRegistry) {
  'use strict';

  var ToolBarView = ToolItemsView.extend({
    parentScrollElement: '.csui-metadata-myattachments',
    className: function () {
      var cssClassForNavigationBar = "binf-nav binf-nav-pills ";
      var cssClassForAlignment = "csui-align-left";
      if (this.options.hAlign) {
        if (this.options.hAlign === "right") {
          cssClassForAlignment = "csui-align-right";
        } else if (this.options.hAlign === "none") {
          cssClassForAlignment = '';
        }
      }
      return "csui-toolbar " + cssClassForNavigationBar + cssClassForAlignment;
    },

    events: {"keydown": "onKeyInView"},

    childViewOptions: function (model) {
      return _.extend(ToolItemsView.prototype.childViewOptions.call(this, model), {
        collection: model.toolItems,
        command: this.collection.commands &&
                 this.collection.commands.findWhere({signature: model.get('signature')}),
        useIconsForDarkBackground: this._useIconsForDarkBackground
      });
    },

    constructor: function ToolBarView(options) {
      options || (options = {});
      this.parentScrollElement = options.parentScrollElement || this.parentScrollElement;

      ToolBarView.__super__.constructor.apply(this, arguments);

      // Passing the el to the ctor prevents creating an own el, including
      // setting its attributes.  The caller must ensure the right tag.
      if (options.el) {
        $(options.el).addClass(_.result(this, "className"));
      }

      // highContrast is 1 for white on dark and 2 for dark on white background
      // show the "dark" icon only when background is dark due to high contrast setting or
      // explicitly enabled by setting useIconsForDarkBackground in options to true and high contrast is not opposite
      this._useIconsForDarkBackground = (options.useIconsForDarkBackground && highContrast !== 2) || highContrast === 1;

      this.listenTo(this, 'dom:refresh', this._onDomRefresh)
          .listenTo(this, 'before:execute:command', this._setBlocked)
          .listenTo(this, 'after:execute:command', this._setUnblocked);

      if (options.keyboardNavigationEnabled) {
        this._keyboardNavigationEnabled = true;

        this.listenTo(this.collection, 'remove', function () {
          if (this._accFocusedToolbarItemIndex > this.collection.length - 1) {
            this._accFocusedToolbarItemIndex = this.collection.length - 1;
          }
        });
        this.listenTo(this.collection, 'reset', function () {
          this._accFocusedToolbarItemIndex = this.collection.length > 0 ? 0 : -1;
        });

        this._accFocusedToolbarItemIndex = this.collection.length > 0 ? 0 : -1;
      }
      this.fetchingNonPromotedActions = false;

      $(window).on('resize.' + this.cid, this._handleWindowResize.bind(this));
    },

    filter: function (model) {
      return model;
    },

    _onDomRefresh: function () {
      if (!this._adjusting) {
        this._adjustToFit();
      }
    },

    onBeforeRender: function () {
      this._unwrapDropDown();
    },

    onRender: function () {
      if (this._toolbarBlocked && !this._isSingleCommandBlocked) {
        this.$el.addClass('binf-disabled');
      }
    },

    onDestroy: function () {
      $(window).off('resize.' + this.cid);
    },

    _getFocusedElementByIndex: function (index) {
      var nth = index + 1;
      var el = this.$el.find('>li:nth-child(' + nth + ')>a.csui-acc-focusable');
      return el;
    },

    getVisibleToolitemsCount: function () {
      var el = this.$el.find('>li>a.csui-acc-focusable');
      return el.length;
    },

    currentlyFocusedElement: function () {
      if (this._keyboardNavigationEnabled && this._accFocusedToolbarItemIndex >= 0) {
        return this._getFocusedElementByIndex(this._accFocusedToolbarItemIndex);
      } else {
        return $();
      }
    },

    /* set the focus to a childview identified by its index */
    setFocusByIndex: function (index) {
      this._getFocusedElementByIndex(index).trigger('focus');
    },

    letRightmostItemGetFocus: function () {
      this._accFocusedToolbarItemIndex = this.collection.length - 1;
    },

    closeDropdown: function () {
      this.children.call('closeDropdown');
    },

    onKeyInView: function (event) {
      if (!this._keyboardNavigationEnabled) {
        return; // skip keyboard navigation (to prevent interference with tabletoolbar
      }
      if (this.collection.length === 0) {
        return; // skip keyboard if no toolbar items are here
      }
      switch (event.keyCode) {
      case 37:
        // left arrow

        event.stopPropagation();

        if (this._accFocusedToolbarItemIndex > 0) {
          this._accFocusedToolbarItemIndex = this._accFocusedToolbarItemIndex - 1;
          this.triggerMethod('changed:focus');
        } else {
          this._accFocusedToolbarItemIndex = 0; // stay at first item
          this.triggerMethod('focusout', {direction: 'left'});
        }
        break;
      case 39:
        // right arrow:

        event.stopPropagation();

        if (this._accFocusedToolbarItemIndex < this.collection.length - 1) {
          this._accFocusedToolbarItemIndex = this._accFocusedToolbarItemIndex + 1;
          this.triggerMethod('changed:focus');
        } else {
          this._accFocusedToolbarItemIndex = this.collection.length - 1; // stay at last item
          this.triggerMethod('focusout', {direction: 'right'});
        }
        break;
      }
    },

    _handleWindowResize: function () {
      if (this._handleWindowResizeTimeout) {
        clearTimeout(this._handleWindowResizeTimeout);
      }
      if (!this.isDestroyed) {
        var self = this;
        this._handleWindowResizeTimeout = setTimeout(function () {
          self._handleWindowResizeTimeout = undefined;
          var checkNodesTableVisibility = self.options.originatingView === undefined ? true :
                                          self.options.originatingView.isDisplayed;
          if (!self.isDestroyed && checkNodesTableVisibility) {
            self.render(); // note: _adjustToFit is called from onDomRefresh
          }
        }, 100);
        this._adjustToFit();
      }
    },

    _setBlocked: function (eventArgs) {
      var self = this,
          command = eventArgs.command,
          toolItemView = eventArgs.status && eventArgs.status.toolItemView,
          $el = command && command.get('selfBlockOnly') && toolItemView ?
                toolItemView.$el.find('a') : this.$el;
      // Do not disable toolbar if user is allow to trigger multiple instances of command
      if (!command.get('allowMultipleInstances')) {
        this._blockedTimer = setTimeout(function () {
          // if in the meanwhile _setUnblock was called, then do the unblocking now after the delay
          if (self._toolbarBlocked === false) {
            $el.removeClass('binf-disabled');
          }
          self._blockedTimer = undefined;
        }, 500);

        this._toolbarBlocked = true;
        this._isSingleCommandBlocked = !$el.is(this.$el);
        $el.addClass('binf-disabled');
      }
    },

    _setUnblocked: function (eventArgs) {
      this._toolbarBlocked = false;
      var command = eventArgs.command,
          toolItemView = eventArgs.status && eventArgs.status.toolItemView,
          $el = command && command.get('selfBlockOnly') && toolItemView ?
                toolItemView.$el.find('a') : this.$el;
      if (!this._blockedTimer) {
        // unblock immediately if delay is already over
        $el.removeClass('binf-disabled');
        if (eventArgs && eventArgs.cancelled) {
          //tool item
          var targetToolItem = this.$el.find('[data-csui-command=' +
                                             eventArgs.commandSignature.toLowerCase() + '] a'),
              //check if the tool item is inside drop down
              isUnderDropDown = targetToolItem.length ?
                                targetToolItem.closest('ul.csui-more-dropdown-menu') : {};
          if (isUnderDropDown.length) {
            //focus on drop down icon
            isUnderDropDown.siblings('a.binf-dropdown-toggle').trigger('focus');
          } else {
            //focus on tool item
            targetToolItem.trigger('focus');
          }
        }
      }
    },

    _adjustToFit: function () {
      // What it does:
      // Iterate through all toolbar items and compare the vertical position with the vertical
      // position of the first item. If it changes it is the toolbar item the browser wrapped
      // into the next line because of lack of horizontal width.
      // The toolbar item before, which is still rendered correctly and all following toolbar
      // items are moved into an inserted dropdown menu.
      if (this._isActive === false) {
        return;
      }

      this.trigger('before:adjust');
      var itemViews = _.filter(this.children.toArray(), function (view) {
        return view instanceof ToolItemView || view instanceof FlyoutToolItemView;
      });
      //In IE11 the iteration order for this.children.each is always in descending order. This is the
      //due to the native Object.keys functionality set by the browser. In order to keep the toolbar
      //display order consistent between browser, the sort order is set using underscore sortBy.
      itemViews = _.sortBy(itemViews, 'cid');
      if (!_.isUndefined(this.options.maxItemsShown)) {
        this._unwrapDropDown(); // revert already wrapped toolbar items
        this._adjusting = true;
        this.el.classList.add('csui-measuring');  // makes ul to overflow:hidden
        if (this.children.length > 0) {
          this._doAdjustToFit(itemViews);

          // todo: the following is wrong, because the toolbar.view must not differentiate where
          // it is used:
          //To differentiate "tableHeader" with other table toolbars like filter, add, captions
          // etc, Declared option as "lazyActions" in toolbarItems.js(nodestable, favorites,
          // search results)
          this.options.lazyActions && this._loadLazyActions();
        }
        this.el.classList.remove('csui-measuring'); // use overflow style only during measuring
        this._adjusting = false;
      } else {
        this._makeItemsFocusable(itemViews);
      }
      this.trigger('after:adjust');
    },

    _makeItemsFocusable: function (items) {
      _.each(items, function (toolItemView, index) {
        toolItemView.makeFocusable();
      }, this);
    },
    _doAdjustToFit: function (itemViews) {
      // Skip empty (state) view
      var firstOffsetY = Math.round(this.$el.offset().top),
          //getBoundingClientRect: To get width in floating points
          rightMost = Math.round(this.el.getBoundingClientRect() ?
                                 this.el.getBoundingClientRect().width : this.$el.width()),
          condensedIconWidth = this.$el.parents('.csui-table-rowselection-toolbar-view') ? this.$el.parents('.csui-table-rowselection-toolbar-view').find('.csui-condensed-header-toggle-container').width() : 0;
          rightMost = base.isIE11() ? rightMost - condensedIconWidth : rightMost;
      this.options.toolbarItemViewOptions = {
        toolItemCounter: 0,
        pEl: undefined,
        pIsSeparator: undefined,
        ppEl: undefined,
        dropDownMenuEl: undefined,
        currentRight: 0,
        rightMost: rightMost,
        firstOffsetY: firstOffsetY,
        index: 0,
        separatorView:undefined
      };

      if (itemViews.length > 1 || this.options.maxItemsShown === 0) {
        _.each(itemViews, function (toolItemView, index) {
          this.options.toolbarItemViewOptions.index = index;
          this._wrapToolItemView(toolItemView);
        }, this);
      } else {
        this._makeItemsFocusable(itemViews);
      }

    },

    _loadLazyActions: function () {
      var lazyActionsRetrieved = true;
      var isLocallyCreatedNode = true;
      var nonPromotedActionCommands = [];

      // 1. lazy actions fetched or not for selected nodes from tableView,
      // 2. is selected node gets created locally ,
      // 3. at least one of the selected nodes have nonPromoted commands(nonPromoted
      // commands set to model in delayed commandable mixin).

      var selectedNodes;
      if (this.collection.status.nodes instanceof NodeCollection) {
        selectedNodes = this.collection.status.nodes;
      } else {
        if (this.collection.status.nodes instanceof Backbone.Collection) {
          selectedNodes = new NodeCollection(this.collection.status.nodes.models);
        } else {
          if (_.isArray(this.collection.status.nodes)) {
            selectedNodes = new NodeCollection(this.collection.status.nodes);
          } else {
            selectedNodes = new NodeCollection();
          }
        }
      }
      if (!selectedNodes.connector) {
        selectedNodes.connector = this.collection.status.collection.connector;
      }

      selectedNodes.each(function (selectedNode) {
        lazyActionsRetrieved = lazyActionsRetrieved &&
                               selectedNode.get('csuiLazyActionsRetrieved');
        isLocallyCreatedNode = isLocallyCreatedNode && selectedNode.isLocallyCreated;
        nonPromotedActionCommands = nonPromotedActionCommands.length ?
                                    nonPromotedActionCommands :
                                    selectedNode.nonPromotedActionCommands;
      });

      selectedNodes.nonPromotedActionCommands = nonPromotedActionCommands;
      selectedNodes.lazyActionsRetrieved = lazyActionsRetrieved;

      if (!lazyActionsRetrieved && !isLocallyCreatedNode &&
          nonPromotedActionCommands.length) { //Lazy actions are not
        // retrieved for at-leasst one of the selected nodes and
        if (!this.fetchingNonPromotedActions) { //fetching nonpromoted actions not yet started
          this._renderLazyActions(selectedNodes);
        }
        if (!this.$el.find('.csui-loading-parent-wrapper').length &&
            this.fetchingNonPromotedActions) {
          if (this.$el.find('.csui-more-dropdown-menu').length) {//hide dropdown with loading
            this.$el.find('.binf-dropdown.csui-more-dropdown-wrapper').addClass(
                'csui-toolbar-hide-child');
          } else { //no 3 dots dropdown
            if (this.options.toolbarItemViewOptions) {
              var loadingAnimationWidth = 46,
                  loadingAnimationRight = this.options.toolbarItemViewOptions.currentRight +
                                          10 + loadingAnimationWidth;
              if (this.options.toolbarItemViewOptions.toolItemCounter ===
                  this.options.maxItemsShown || loadingAnimationRight >
                  this.options.toolbarItemViewOptions.rightMost) {
                this.$el.find('li:last').addClass('csui-toolbar-hide-child');
              }
            }
          }
          this.$el.append(lazyloadingTemplate);
        }
      }
    },

    _wrapToolItemView: function (toolItemView) {
      var isSeparator = toolItemView.model.isSeparator();
      if (!isSeparator) {
        this.options.toolbarItemViewOptions.toolItemCounter++;
      }
      if (this.options.toolbarItemViewOptions.dropDownMenuEl) {
        // move the remaining toolbar items into the ul of the dropdown menu
        // but not the last item if it is a separator
        if (!(isSeparator &&
              this.options.toolbarItemViewOptions.index + 1 === this.children.length)) {
          toolItemView.$el.attr('role', 'none');
          //If flyout item wraps into drop down then made it as normal toolItem
          toolItemView.$el.find(
              '.csui-flyout-arrow .csui-button-icon.icon-expandArrowDown').addClass('binf-hidden');
          toolItemView.$el.find('.csui-toolitem.csui-flyout-arrow').removeClass(
              'csui-flyout-arrow');
          _.isFunction(toolItemView.renderTextOnly) && toolItemView.renderTextOnly(true);
          this.options.toolbarItemViewOptions.dropDownMenuEl.append(toolItemView.$el);
          toolItemView.triggerMethod('dom:refresh');
          if (this.usePerfectScrollbar()) {
            this.options.toolbarItemViewOptions.dropDownMenuEl.perfectScrollbar('update');
          }
        }
      } else {
        if (isSeparator) {
          this.options.toolbarItemViewOptions.separatorView = toolItemView;
        }
        else {
          var currentOffsetY = Math.round(base.getOffset(toolItemView.$el).top),
              currElementWidth = Math.round(toolItemView.$el[0].getBoundingClientRect() ?
                                            toolItemView.$el[0].getBoundingClientRect().width :
                                            toolItemView.$el.width());
          this.options.toolbarItemViewOptions.currentRight = this.options.toolbarItemViewOptions.currentRight +
                                                             parseInt(currElementWidth, 10);
          // check if element already wrapped because not enough space to render it in one line
          if (currentOffsetY !== this.options.toolbarItemViewOptions.firstOffsetY ||
              this.options.toolbarItemViewOptions.currentRight >
              this.options.toolbarItemViewOptions.rightMost ||
              (this.options.toolbarItemViewOptions.toolItemCounter > this.options.maxItemsShown)) {
            // the previous toolbar item will be replaced by dropdown menu and moved into it
            if (this.options.toolbarItemViewOptions.pIsSeparator) {
              if (this.options.toolbarItemViewOptions.ppEl) {
                // Move pre-previous element and the current element to the dropdown
                this.options.toolbarItemViewOptions.ppEl.$el.attr('role', 'none');
                this.options.toolbarItemViewOptions.dropDownMenuEl = this._wrapWithDropDown(
                    this.options.toolbarItemViewOptions.ppEl, toolItemView);
                // Insert the previous separator between the pre-previous element
                // and the current element in the dropdown
                this.options.toolbarItemViewOptions.dropDownMenuEl.children().first().after(
                    this.options.toolbarItemViewOptions.pEl.$el);
              }
            } else {
              if (this.options.toolbarItemViewOptions.pEl) {
                // Move the previous element to the dropdown
                this.options.toolbarItemViewOptions.pEl.$el.attr('role', 'none');
                this.options.toolbarItemViewOptions.dropDownMenuEl = this._wrapWithDropDown(
                    this.options.toolbarItemViewOptions.pEl, toolItemView);
              } else {
                // there is no previous toolbar item -> wrap the current toolbar item into a
                // dropdown menu at the beginning of the toolbar
                this.options.toolbarItemViewOptions.dropDownMenuEl = this._wrapWithDropDown(
                    toolItemView, toolItemView);
              }
            }
          } else {
            toolItemView.makeFocusable();
          }
        }
        this.options.toolbarItemViewOptions.ppEl = this.options.toolbarItemViewOptions.pEl;
        this.options.toolbarItemViewOptions.pEl = toolItemView;
        this.options.toolbarItemViewOptions.pIsSeparator = isSeparator;
      }
    },

    _wrapWithDropDown: function (pItem, toolItemView) {
      _.isFunction(pItem.renderTextOnly) && pItem.renderTextOnly(true);
      var pEl = pItem.$el;
      pEl.wrap(
          '<li role="none" class="binf-dropdown csui-wrapper csui-more-dropdown-wrapper"><ul class="binf-dropdown-menu csui-more-dropdown-menu" role="menu"></ul></li>');
      var e = this._makeDropDown();
      var dropDownEl = this.$('li.csui-wrapper');

      dropDownEl.prepend(e);
      var dropDownMenuEl = dropDownEl.find('> ul.binf-dropdown-menu');
      //If flyout item wraps into drop down then make it as normal toolItem
      pEl.find('.csui-flyout-arrow .csui-button-icon.icon-expandArrowDown').addClass('binf-hidden');
      pEl.find('.csui-toolitem.csui-flyout-arrow.csui-acc-focusable').removeClass(
          'csui-flyout-arrow');
      _.isFunction(toolItemView.renderTextOnly) && toolItemView.renderTextOnly(true);
      toolItemView.$el.find('.csui-flyout-arrow .csui-button-icon.icon-expandArrowDown').addClass(
          'binf-hidden');
      toolItemView.$el.find('.csui-toolitem.csui-flyout-arrow').removeClass('csui-flyout-arrow');
      dropDownMenuEl.append(toolItemView.$el); // move current toolitem into dropdown
      toolItemView.triggerMethod('dom:refresh');
      pEl.trigger('dom:refresh');
      var that = this;
      this.$el.off("show.binf.dropdown." + this.cid).on("show.binf.dropdown." + this.cid,
          _.bind(function () {

            var scrollableParent = dropDownMenuEl.closest(that.parentScrollElement);
            if (!!scrollableParent && scrollableParent.length > 0) {
              var scrollableParentHeight = scrollableParent.height(),
                  elementSetBacks = parseInt(scrollableParent.css("margin-top")) +
                                    parseInt(scrollableParent.css("margin-bottom"));
              // check whether dropdown menu overlaps on it's parent scrollable element.
              if (dropDownMenuEl.height() + elementSetBacks > scrollableParentHeight) {
                var heightOfDD = scrollableParentHeight - elementSetBacks;
                dropDownMenuEl.css({
                  "overflow": "hidden",
                  "padding": "0",
                  "max-height": heightOfDD + "px"
                });
                //bug with perfect-scrollbar that does not show bar for the first time
                setTimeout(function () {
                  dropDownMenuEl.perfectScrollbar({suppressScrollX: true});
                  dropDownMenuEl.perfectScrollbar("update");
                }, 1);
              }
            }
          }, that));
      this.$el.off('binf.dropdown.after.show.' + this.cid).on(
          'binf.dropdown.after.show.' + this.cid, function (event) {
            if (that.usePerfectScrollbar()) {
              dropDownMenuEl.addClass('csui-perfect-scrolling');
              dropDownMenuEl.perfectScrollbar({
                suppressScrollX: true,
                includePadding: true
              });
            } else {
              dropDownMenuEl.addClass('csui-normal-scrolling csui-no-scroll-x');//normal-scrolling for touch devices
            }
            base.alignDropDownMenu({targetEl: $(event.target)});
            that.trigger('toolbar.show');

           if (base.isAppleMobile() && dropDownMenuEl.hasClass('csui-submenu-active')) {
            dropDownMenuEl.removeClass('csui-submenu-active');
            }            
          });          
      return dropDownMenuEl;
    },

    _unwrapDropDown: function () {
      // remove dropdown menu
      var dropDownEl = this.$('li.csui-wrapper'),
          dropDownMenuEl = dropDownEl.find('> ul.binf-dropdown-menu'),
          loadDotsElem = this.$el.find('.csui-loading-parent-wrapper');
      loadDotsElem && loadDotsElem.remove();
      if (dropDownMenuEl.length > 0) {
        var menuItems = dropDownMenuEl.children('li');
        menuItems.each(function (index, menuitem) {
          dropDownEl.before(menuitem);
          $(menuitem).trigger('dom:refresh');
        });
        dropDownEl.remove();
      }

      //adding the flyout wrapper to the flyout item
      var flyouts = this.$el.find('.csui-flyout.binf-dropdown');
      if (flyouts.length) {
        _.each(flyouts, function (flyout) {
          //find sub children of flyout
          var flyoutDdItems = $(flyout).find('ul li');
          if (flyoutDdItems.length >= 1) {
            $(flyout).find('> .csui-toolitem').addClass('csui-flyout-arrow');
            $(flyout).find('.csui-flyout-arrow .csui-button-icon.icon-expandArrowDown').removeClass(
                'binf-hidden');
          }
        });
      }

      this.children.forEach(function (item) {
        _.isFunction(item.restoreRenderState) && item.restoreRenderState();
      });
    },

    // creates the toggle button only
    _makeDropDown: function () {
      var cssClass = "binf-dropdown-toggle csui-acc-focusable";
      var e = '<a href="#" role=' +(this.options.noMenuRoles ? '"button"' : '"menuitem"') + ' class="' + cssClass +
              ' " data-binf-toggle="dropdown" aria-expanded="false" aria-haspopup="true"';
      // TODO handle the aria-expanded state
      if (this.options.dropDownText) {
        e += ' title="' + this.options.dropDownText + '" aria-label="' + this.options.dropDownText +
             '">';
      } else {
        e += '>';
      }
      if (this.options.dropDownIconName) {
        e += iconRegistry.getIconByNameWithOptions(
            {
              iconName: this.options.dropDownIconName,
              theme: this._useIconsForDarkBackground ? 'dark' : '',
              states: true
            });
      } else {
        if (this.options.dropDownIcon) {
          e += '<span class="' + this.options.dropDownIcon + '"></span>';
        } else {
          if (this.options.dropDownText) {
            e += this.options.dropDownText;
            // TODO might be duplicate with the aria-label above?
          }
        }
      }
      e += "</a>";
      return e;
    },

    appendLazyActions: function () {
      var self = this,
          existingchildViews = _.sortBy(self.children.toArray(), 'cid'),
          index = 0,
          actionItems = _.filter(self.collection.models,
              function (model) { return model});
      _.each(actionItems, function (model) {
        var existingChildView = existingchildViews[index],
            itemName = model.get('name');
        if (existingChildView && existingChildView.model.get('name') === itemName) { //re-render flyout toolitem view,
          // if child flyout toolitems count is different
          if (model.get('flyout') && model.toolItems.length !==
              existingChildView.model.toolItems.length) {
            existingChildView.collection.reset(model.toolItems.models);
          }
          index++;
        } else {
          if (self.options.toolbarItemViewOptions) {
            self.options.toolbarItemViewOptions.index++;
            var childViewClass = model.get('flyout') ? FlyoutToolItemView : ToolItemView,
                lazyToolItemView = self.addChild(model, childViewClass,
                    self.options.toolbarItemViewOptions.index);
            self._wrapToolItemView(lazyToolItemView);
            existingChildView && self.removeChildView(existingChildView);
            index++;
          }
        }
      });
    },

    startLazyLoading: function () {
      this.options.toolbarItemViewOptions.dropDownMenuEl.append(lazyloadingTemplate);
    },

    stopLazyLoading: function () {
      var blockingEle = this.$el.find('.csui-loading-parent-wrapper');
      blockingEle.remove();
    },

    _renderLazyActions: function (selectedNodes) {
      if (!selectedNodes.lazyActionsRetrieved) {
        var self = this;
        this.fetchingNonPromotedActions = true;

        selectedNodes.setEnabledLazyActionCommands(
            true).done(_.bind(function () {
          self.fetchingNonPromotedActions = false;
          //Validate lazy actions are  permitted actions or not
          var blockingEle = self.$el.find('.csui-loading-parent-wrapper');
          //As per UX review comments, 300 ms given before rendering lazy actions
          blockingEle.animate("width: 0", 300, function () {
            blockingEle.remove();
            self.$el.find('.csui-toolbar-hide-child').removeClass('csui-toolbar-hide-child');
            self.collection.silentFetch = true; //to stop re-rendering tableheader-toolbar
            self.collection.refilter();
            self.appendLazyActions();
            self.triggerMethod('dom:refresh');
            self.trigger('render:lazy:actions');
          });

        }), this).fail(function (request) {
          self.fetchingNonPromotedActions = false;
          var blockingEle = self.$el.find('.csui-loading-parent-wrapper'),
              error = new base.Error(request);
          blockingEle.length && blockingEle.remove();
          GlobalMessage.showMessage('error', error.message);
        });
      }
    },

    usePerfectScrollbar: function () {
      return PerfectScrollingBehavior.usePerfectScrollbar();
    },

    setActive: function (isActive) {
      this._isActive = isActive;
    }

  });

  return ToolBarView;
});

csui.define('csui/controls/toolbar/toolbar.command.controller',[
  'module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/log', 'csui/utils/commandhelper', 'csui/utils/commands'
], function (module, _, Backbone, log, CommandHelper, commands) {
  'use strict';

  log = log(module.id);

  function ToolbarCommandController(options) {
    options || (options = {});
    this.commands = options.commands || commands;
    this.nameAttribute = options.nameAttribute;
  }

  _.extend(ToolbarCommandController.prototype, Backbone.Events, {
    toolitemClicked: function (toolItem, status) {
      var signature = toolItem.get("signature");
      var command = this.commands.get(signature);

      var addableTypeName = toolItem.get("name");
      var addableType = toolItem.get("type");

      // Special toolbars, like the "Add" toolbar pre-populate
      // the command data with additional information; addable types,
      // for example. The data from the tool item have to be merged
      // with them. One level should be enough; the same property
      // should be better replaced, than deeply merged without knowing
      // its semantics on this code level.
      var data = _.extend({}, status.data, toolItem.get('commandData'));
      status = _.defaults({
        toolItem: toolItem,
        data: data
      }, status);
      var eventArgs = {
        status: status,
        commandSignature: signature,
        addableType: addableType,
        addableTypeName: addableTypeName,
        command: command
      };

      if (toolItem.get('execute') === false || !command.execute) {
        eventArgs.execute = false;
        eventArgs.toolItem = toolItem;
        // Trigger before: and after: execution events in addition for compatibility.
        this.trigger('before:execute:command', eventArgs);
        this.trigger('click:toolitem:action', eventArgs);
        return this.trigger('after:execute:command', eventArgs);
      }

      this.trigger('before:execute:command', eventArgs);

      // TODO: Don't copy this to newer code! Each new control cannot just
      // modify this or other controllers, which have nothing in common with
      // it to fix their problems.
      // A better solution would be to let click events propagate so that binf
      // gets the event and closes open dropdown lists without using a global
      // Backbone event, for example.
      Backbone.trigger('closeToggleAction');

      var self = this;
      self.commandSignature = signature;

      var executeOptions = {
        context: status.context,
        // TODO: Move all this single command specific attributes
        // to the data above
        addableType: addableType,
        addableTypeName: addableTypeName,
        nameAttribute: self.nameAttribute
      };

      var promiseFromCommand;
      try {
        // If the command was not found and the toolitem is executable, it is
        // a developer's mistake.
        if (!command) {
          throw new Error('Command "' + signature + '" not found.');
        }

        // command could defer resolving until something is done (like a modal dialog,...)
        promiseFromCommand = command.execute(status, executeOptions);
      } catch (error) {
        log.warn('Executing the command "{0}" failed.\n{1}',
            command.get('signature'), error.message) && console.warn(log.last);
        // If command.execute throws and error during execute, let the listeners handle execution.
        eventArgs.error = error;
        return this.trigger('after:execute:command', eventArgs);
      }

      // If the command does not return anything, no common success or error
      // handling will be provided.
      if (!promiseFromCommand) {
        return this.trigger('after:execute:command', eventArgs);
      }

      // the command execution was responsible to set status.formwardToTable = true in case of
      // inline forms should handle further processing
      return CommandHelper
          .handleExecutionResults(promiseFromCommand, {
            command: command,
            suppressSuccessMessage: status.forwardToTable || status.suppressSuccessMessage,
            suppressFailMessage: status.suppressFailMessage
          })
          .done(function (nodes) {
            if (nodes && !nodes[0].cancelled) {
              // allow any listeners to continue with something after the command was executed
              // for example the nodestable.view would create an inline form for newly created nodes
              eventArgs.newNodes = nodes;
              self.trigger('after:execute:command', eventArgs);
            }
          })
          .fail(function (error) {
            // in case the command was cancelled, error is undefined
            if (error === undefined) {
              error = {
                cancelled: true,
                command: command,
                status: status,
                commandSignature: self.commandSignature
              };
            }
            self.trigger('after:execute:command', error);
          });
    }
  });

  ToolbarCommandController.extend = Backbone.View.extend;

  return ToolbarCommandController;
});

csui.define('csui/controls/toolbar/toolitems.mask',['csui/lib/underscore', 'csui/lib/backbone'
], function (_, Backbone) {
  'use strict';

  // Masks tool items.
  // mask: {blacklist, whitelist}
  // simple by signatures: ['Copy', 'Delete']
  // complex by other properties: [
  //   {signature: 'AddVersion'},
  //   {signature: 'Add', commandData: {type: 144}}
  // ]
  function ToolItemsMask(mask, options) {
    options || (options = {});
    if (options.normalize !== false) {
      mask = this._normalizeMask(mask);
    }
    this.blacklist = mask.blacklist;
    this.whitelist = mask.whitelist;
    this.storeMask();
  }

  _.extend(ToolItemsMask.prototype, Backbone.Events, {

    toJSON: function () {
      return {
        blacklist: _.clone(this.blacklist),
        whitelist: _.clone(this.whitelist)
      };
    },

    clone: function () {
      return new this.constructor(this);
    },

    clearMask: function (options) {
      var modified = this.blacklist.length || this.whitelist.length;
      this.blacklist.splice(0);
      this.whitelist.splice(0);
      if (modified && !(options && options.silent)) {
        this.trigger('update', this);
      }
      return modified;
    },

    extendMask: function (mask, options) {
      options || (options = {});
      if (options.normalize !== false) {
        mask = this._normalizeMask(mask);
      }
      var modified = this._extendList(this.blacklist, mask.blacklist);
      modified = this._extendList(this.whitelist, mask.whitelist) || modified;
      if (modified && !options.silent) {
        this.trigger('update', this);
      }
      return modified;
    },

    resetMask: function (mask, options) {
      options || (options = {});
      if (options.normalize !== false) {
        mask = this._normalizeMask(mask);
      }
      var modified = this._replaceList(this.blacklist, mask.blacklist);
      modified = this._replaceList(this.whitelist, mask.whitelist) || modified;
      if (modified && !options.silent) {
        this.trigger('update', this);
      }
      return modified;
    },

    storeMask: function () {
      this.originalBlacklist = _.clone(this.blacklist);
      this.originalWhitelist = _.clone(this.whitelist);
    },

    restoreMask: function (options) {
      options || (options = {});
      return this.resetMask({
        blacklist: this.originalBlacklist,
        whitelist: this.originalWhitelist
      }, {
        silent: options.silent,
        normalize: false
      });
    },

    restoreAndResetMask: function (mask, options) {
      options || (options = {});
      if (options.normalize !== false) {
        mask = this._normalizeMask(mask);
      }
      var modified = this.restoreMask({silent: true});
      modified = this.extendMask(mask, {
        silent: true,
        normalize: false
      }) || modified;
      if (modified && !options.silent) {
        this.trigger('update', this);
      }
      return modified;
    },

    maskItems: function (items) {
      if (items instanceof Backbone.Collection) {
        items = items.models;
      }
      return _.filter(items, this.passItem, this);
    },

    passItem: function (item) {
      if (item instanceof Backbone.Model) {
        item = item.attributes;
      }
      // Never pass blacklisted items. If there is a whitelist,
      // pass only whitelisted items.
      return !this._containsRule(item, this.blacklist) &&
          (!this.whitelist.length || this._containsRule(item, this.whitelist));
    },

    _containsRule: function (item, rules) {
      return _.any(rules, _.bind(this._matchesRule, this, item));
    },

    _matchesRule: function (item, rule) {
      if (item.signature != rule.signature) {
        return false;
      }
      var commandData = item.commandData || {};
      return _.all(rule.commandData, function (value, name) {
        return value == commandData[name];
      });
    },

    _extendList: function (target, source) {
      return _.reduce(source, function (modified, sourceRule) {
        if (!_.any(target, function (targetRule) {
          return _.isEqual(sourceRule, targetRule);
        })) {
          target.push(sourceRule);
          modified = true;
        }
        return modified;
      }, false);
    },

    _reduceList: function (target, source) {
      var indexes = _
              .chain(target)
              .map(function (targetRule, index) {
                return !_.any(source, function (sourceRule) {
                  return _.isEqual(targetRule, sourceRule);
                }) && index + 1;
              })
              .compact()
              .value();
      _.each(indexes, function (index, order) {
        target.splice(index - order - 1, 1);
      });
      return !!indexes.length;
    },

    _replaceList: function (target, source) {
      var modified = this._reduceList(target, source);
      return this._extendList(target, source) || modified;
    },

    _normalizeMask: function (mask) {
      mask || (mask = {});
      return {
        blacklist: this._normalizeList(mask.blacklist),
        whitelist: this._normalizeList(mask.whitelist)
      };
    },

    _normalizeList: function (rules) {
      return rules ? _.map(rules, this._normalizeRule, this) : [];
    },

    // Possible inputs:
    //   'signature'             (signature as string)
    //   {signature: '...', ...} (object with 'signature' and other properties)
    // Output:
    //   {signature: '...', ...} (object with 'signature' and other properties)
    _normalizeRule: function (rule) {
      if (_.isObject(rule)) {
        return rule;
      }
      return {signature: rule};
    }

  });

  ToolItemsMask.extend = Backbone.Model.extend;

  return ToolItemsMask;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/toolbar/impl/toolbar.state',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<p>"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"message") || (depth0 != null ? lookupProperty(depth0,"message") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"message","hash":{},"loc":{"start":{"line":1,"column":3},"end":{"line":1,"column":14}}}) : helper)))
    + "</p>\r\n";
}});
Handlebars.registerPartial('csui_controls_toolbar_impl_toolbar.state', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/toolbar/toolbar.state.view',['csui/lib/underscore', 'csui/lib/marionette',
  'hbs!csui/controls/toolbar/impl/toolbar.state',
  'i18n!csui/controls/toolbar/impl/nls/localized.strings'
], function (_, Marionette, template, lang) {
  'use strict';

  var ToolbarStateView = Marionette.ItemView.extend({

    tagName: 'li',

    className: 'csui-toolbar-state',

    template: template,

    constructor: function ToolbarStateView() {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.listenTo(this.model, 'change', function () {
        // TODO: Find out, why a destroyed inline action bar still
        // get this event triggered on the action state model
        if (!this.isDestroyed) {
          this.render();
        }
      });
      this.statusMessages = {
        loading: lang.loadingActionsMessage,
        failed: lang.failedActionsMessage
      };
    },

    serializeData: function () {
      // Show the message only if there are items to handle by actions
      var message = this.model.get('showMessage') ? // empty, loading, failed
                    this.statusMessages[this.model.get('state')] : undefined;
      return _.extend(this.model.toJSON(), {
        message: message
      });
    }

  });

  return ToolbarStateView;

});

csui.define('csui/controls/toolbar/toolbar.state.behavior',['csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/marionette',
  'csui/controls/toolbar/toolbar.state.view'
], function (_, Backbone, Marionette, ToolbarStateView) {
  'use strict';

  var ToolbarStateBehavior = Marionette.Behavior.extend({

    constructor: function ToolbarStateBehavior(options, view) {
      Marionette.Behavior.prototype.constructor.apply(this, arguments);

      this.view = view;

      // Behaviors are created before the collection is stored in view
      var collection     = view.collection || view.options.collection,
          delayedActions = this.getOption('delayedActions');
      if (_.isFunction(delayedActions) &&
          !(delayedActions instanceof Backbone.Collection)) {
        delayedActions = delayedActions.call(view);
      }
      if (!delayedActions && collection) {
        delayedActions = collection.delayedActions;
      }
      if (delayedActions) {
        this
            .listenTo(delayedActions, 'request', this._fetchingActionsStarted)
            .listenTo(delayedActions, 'sync', this._fetchingActionsSucceeded)
            .listenTo(delayedActions, 'error', this._fetchingActionsFailed);
      }
      this.listenTo(collection, 'reset change', this._fetchingActionsSucceeded);

      view.actionState = new Backbone.Model({
        state: delayedActions && (delayedActions.fetching ? 'loading' :
                                  delayedActions.error ? 'failed' :
                                  collection.length ? 'full' : 'empty'),
        showMessage: true
      });

      view.emptyView = ToolbarStateView;
      view.emptyViewOptions = {
        model: view.actionState,
        toolbarView: view
      };

      this.listenTo(view, 'render', this._updateClasses);
    },

    _fetchingActionsStarted: function () {
      this.view.actionState.set('state', 'loading');
      this._updateClasses();
    },

    _fetchingActionsSucceeded: function (collection) {
      this.view.actionState.set('state', collection.length ? '' : 'emptyfull');
      this._updateClasses();
    },

    _fetchingActionsFailed: function () {
      this.view.actionState.set('state', 'failed');
      this._updateClasses();
    },

    _updateClasses: function () {
      this.view.$el
          .removeClass('csui-state-empty csui-state-loading csui-state-failed')
          .addClass('csui-state-' + this.view.actionState.get('state'));
    }

  });

  return ToolbarStateBehavior;

});

csui.define('csui/controls/toolbar/delayed.toolbar.view',['csui/controls/toolbar/toolbar.view',
  'csui/controls/toolbar/toolbar.state.behavior',
], function (ToolbarView, ToolbarStateBehavior) {
  'use strict';

  var DelayedToolbarView = ToolbarView.extend({

    behaviors: {

      ToolbarState: {
        behaviorClass: ToolbarStateBehavior,
        delayedActions: function () {
          return this.options.delayedActions;
        }
      }

    },

    constructor: function DelayedToolbarView(options) {
      ToolbarView.prototype.constructor.apply(this, arguments);
    }

  });

  return DelayedToolbarView;

});

csui.define('csui/controls/fileupload/impl/upload.controller',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/utils/base', 'csui/utils/taskqueue', 'csui/utils/contexts/factories/task.queue.factory', 'csui/utils/contexts/factories/connector',
  'csui/models/version', "csui/utils/url",
  'csui/utils/commandhelper', 'csui/lib/underscore.deepExtend'
], function (module, _, $, Backbone, base, TaskQueue, TaskQueueFactory, ConnectorFactory, VersionModel, URL, CommandHelper) {
  'use strict';

  var config = module.config();
  _.defaults(config, {
    parallelism: 3

  });

  function UploadController(options) {
    options || (options = {});
    this.options = options;
    var context = this.options.context;
    this.connector = context.getObject(ConnectorFactory);
    this.container = options.container ? options.container.clone() : null;
    this.originatingView = options.originatingView ? options.originatingView : null; 
    if (options.context) {
      this.queue = options.context.getCollection(TaskQueueFactory, {
        options: {
          parallelism: options.parallelism || config.parallelism,
          permanent: true //To retain task queue collection while switching between folders
        }
      });
    } else {
      this.queue = new TaskQueue({
        parallelism: options.parallelism || config.parallelism
      });
    }
    // TODO create only if large file is available
    this.chunkQueue = new TaskQueue({
      parallelism: options.parallelism || config.parallelism
    });
  }

  _.extend(UploadController.prototype, Backbone.Events, {

    scheduleFileForUpload: function (fileUpload) {
      this.queue.pending.add({
        worker: _.bind(this._uploadFile, this, fileUpload)
      });
    },

    _uploadFile: function (fileUpload) {
      var container = fileUpload.container || this.container, jqxhr,
        deferred = fileUpload.deferred,
        node = fileUpload.node,
        // TODO: Enable switching between newName and newVersion during
        // the life of this model by some better interface
        version = fileUpload.version || fileUpload.get('newVersion'),
        file = fileUpload.get("file"),
        extendedData = fileUpload.get('extended_data'),
        data;

      if (_.isArray(node.get('versions'))) {
        !!node.attributes && !!node.attributes.versions &&
          node.attributes.versions.push(version.attributes);

      }
      // Enable switching among new node and new version modes during
      // the lifetime of this model; an interface would be better, not
      // no have upload.controller knowing the difference
      if (version) {
        if (!node.has('id')) {
          node.set('id', fileUpload.get('id'));
        }
        if (!(version instanceof VersionModel)) {
          version = new VersionModel({
            id: node.get('id')
          });
        }
        data = {};
        fileUpload.get('add_major_version') && (data.add_major_version = fileUpload.get('add_major_version'));
      } else {
        if (!container) {
          throw new Error('Container node is missing.');
        }
        data = {
          name: fileUpload.get('newName') || file.name,
          type: node.get('type') !== undefined ? node.get('type') : fileUpload.get('type') !== undefined ? fileUpload.get('type') : 144,
          parent_id: container.get('id'),
          advanced_versioning: !!container.get('versions_control_advanced')
        };
      }
      var mlDataEnabled = base.getMetadataLanguageInfo().enabled;
      if (mlDataEnabled && !!fileUpload.get('multilingual_provided')) {
        _.extend(data, {
          name_multilingual: fileUpload.get('name_multilingual')
        });
      }
      // additional attributes may come from metadata entered by the user
      if (extendedData) {
        _.deepExtend(data, extendedData);
      }
      if (container && container.get('type') === 136 && !!fileUpload.get('order_new')) {
        data.order_new = fileUpload.get('order_new');
      }
      if (data.type === 144 || version) {
        // passing external modifed date to display source information of document
        data.external_modify_date = fileUpload.get('file').lastModifiedDate;
        if (data.external_modify_date === undefined) {
          // as specific browsers like firefox do not get last modifed date explictly we get the date using lastModified
          data.external_modify_date = new Date(fileUpload.get('file').lastModified);
        }
      }

      // FileUploadModel should be created with a container or connector
      // to make its node cloneable right away and other components could
      // refer to it.  But if not needed, use the default container of the
      // upload controller to provide the connector.
      if (!node.connector) {
        if (!container) {
          throw new Error('Either node or container have to be connected.');
        }
        container.connector.assignTo(node);
      }
      if (version && !version.connector) {
        node.connector.assignTo(version);
      }

      var self = this;
      // TODO min large file size to be fetched from config for which we need backend changes
      // TODO backend changes needs to be fixed and hence keeping the code disabled inorder not to break anything
      config.largeFileSettings = this.originatingView && this.originatingView.largeFileSettingsModel &&
      this.originatingView.largeFileSettingsModel.get('largeFileSettings');
      if ((config.largeFileSettings && config.largeFileSettings.is_enabled
        && (file.size > config.largeFileSettings.min_size) && (file.size < config.largeFileSettings.max_size))) {
        jqxhr = this.getUploadId(file).done(function (data) {
          var state = fileUpload.get('state');
          if ((state !== 'aborted') && (state !== 'stopped')) {
            self.uploadAllParts(data, file, fileUpload).done(function () {
              var state = fileUpload.get('state');
              if ((state !== 'aborted') && (state !== 'stopped')) {
                self.completeUpload(fileUpload).done(function () {
                  var state = fileUpload.get('state');
                  if ((state !== 'aborted') && (state !== 'stopped')) {
                    if (node.get('id')) {
                      var id = node.get('id');

                      self.createVersion(id, fileUpload).done(function (versionResponse) {
                        var sizeinbytes = versionResponse.results.data.versions['file_size'],
                          sizeinkb = base.formatFileSize(sizeinbytes);
                        version.set('file_size_formatted', sizeinkb);
                        version.isLocallyCreated = true;
                        if( versionResponse.results &&  versionResponse.results.data && versionResponse.results.data.properties
                          && versionResponse.results.data.versions) {
                            _.extend(version.attributes,versionResponse.results.data.properties, versionResponse.results.data.versions);
                          }
                        self.fetchNode(versionResponse, node).done(function () {
                          deferred.resolve(fileUpload);
                          return deferred.promise();
                        }).catch(function (errorObj) {
                          var error = new base.RequestErrorMessage(errorObj);
                          deferred.reject(fileUpload, error);
                        });
                      }).catch(function (errorObj) {
                        self.handleCatch(errorObj, fileUpload);
                      });
                    } else {
                      self.createNode(file, fileUpload).done(function (nodeResponse) {
                        self.fetchNode(nodeResponse, node).done(function () {
                          deferred.resolve(fileUpload);
                          return deferred.promise();
                        }).catch(function (errorObj) {
                          var error = new base.RequestErrorMessage(errorObj);
                          deferred.reject(fileUpload, error);
                        });
                      }).catch(function (errorObj) {
                        self.handleCatch(errorObj, fileUpload);
                      });
                    }
                  }
                  else {
                    deferred.reject(fileUpload);
                  }


                }).catch(function (errorObj) {
                  self.handleCatch(errorObj, fileUpload);
                });
              }
              else {
                deferred.reject(fileUpload);
              }
            }).catch(function (errorObj) {
              var chunkRequest;
              for (var index = 0; index < errorObj.length; index++) {
                if (errorObj[index].length > 1) {
                  chunkRequest = errorObj[index][1];
                }
              }
              self.handleCatch(chunkRequest, fileUpload);
            });
          }
          else {
            deferred.reject(fileUpload);
          }
        }).fail(function (errorObj) {
          self.handleCatch(errorObj, fileUpload);
        });
        deferred.fail(function (model, error) {
          // we interpret a reject called without an error object as an abort.
          if (!error) {
           jqxhr.abort();
          }
        });

      } else {
        jqxhr = (version || node).save(data, {
          data: data,
          files: { file: file }
        });
        jqxhr.progress(function (event, request) {
          deferred.notify(fileUpload, event);
        })
          .then(function (data, result, request) {
            if (node) {
              node = self.checkAndGetIfExistingNode(node);
              return node.fetch({ collection: node.collection, refreshCache: true });
            }
          })
          .done(function (data, result, request) {
            deferred.resolve(fileUpload);
          })
          .fail(function (request, message, statusText) {
            var error = new base.RequestErrorMessage(request);
            deferred.reject(fileUpload, error);
          });
        deferred.fail(function (model, error) {
          // we interpret a reject called without an error object as an abort.
          if (!error) {
            deferred.reject(fileUpload);
          }
        });
      }

      // Send the creation data in the extra options instead of setting
      // them to the module attributes.  Node URL is computed according
      // to its attributes - missing ID means trying a volume by its type.
      // This may be changed to use different initialization parameters
      // than the node properties for decreased convenience.  When you
      // change this, code, check out the controller/createobject too.
      // The attributes should be set correctly anyways when the server
      // returns the attributes of the new node, they'll be merged into
      // the node model.

      return fileUpload.promise();
    },

    checkAndGetIfExistingNode: function (node) {
      // If a node with the same id exists in the currently displayed container items,
      // we find the existing node in the collection and return it here, so that things like fetch can be /// called on the existing node and the views that are displaying the information of this existing
      // node can re-render and display the updated information.
      var nodeId = node.get('id');
      if(!nodeId) {
        // return if this is a newly created node.
        return node;
      }
      var existingNode = node.collection && node.collection.findWhere({id: nodeId});
      return existingNode ? existingNode : node;
    },

    getUploadId: function (file) {
      var url = this.connector.getConnectionUrl().getApiBase('v2'),
        formData = {
          'file_size': file.size,
          'file_name': file.name,
          'mime_type': file.type
        },
        ajaxOptions = {
          url: URL.combine(url, 'multipart'),
          type: 'POST',
          data: formData,
          contentType: 'application/x-www-form-urlencoded'
        };


        return this.connector.makeAjaxCall(ajaxOptions);
    },

    uploadAllParts: function (results, file, fileUpload) {
      var data = results.results.data, self = this,
        partSize = data.part_size;
      var largeFile = fileUpload.get('largeFile');
      largeFile.uploadKey = data.upload_key;
      largeFile.maxRetries = data.max_retries;
      largeFile.fileChunks.total = data.num_parts;
      fileUpload.set({ state: "processing" });
      largeFile.state = "processing";

      if (!(largeFile.slicedFiles)) {
        for (var partNumber = 0; partNumber < data.num_parts; partNumber++) {
          largeFile.fileChunks.slicedFiles[partNumber] = file.slice((partNumber) * partSize, (partNumber + 1) * partSize, "application/octet-stream");

        }
      }

      fileUpload.set('largeFile', largeFile);
      fileUpload.attributes.upload_key = data.upload_key;
      var promises = self.uploadChunk(fileUpload);
      return $.whenAll.apply($, promises);

    },
    uploadChunk: function (fileUpload) {
      var largeFile = fileUpload.get('largeFile'), self = this,
      url = this.connector.getConnectionUrl().getApiBase('v2') + "multipart/" + largeFile.uploadKey;

      var promises = largeFile.fileChunks.slicedFiles.map(function (fileChunk, index) {
        var fd = new FormData();
        var deferred = $.Deferred();

        fd.append('part_content', fileChunk);
        var url1 = url + '/' + (index + 1),
          ajaxOptions = {
            'url': url1,
            'method': 'POST',
            'data': fd,
            "processData": false,
            "contentType": false
          };

        self.chunkQueue.pending.add({
          worker: _.bind(function () {
            var promise = self.connector.makeAjaxCall(ajaxOptions)
              .done(function () {
                var size = fileUpload.get('count');
                largeFile = fileUpload.get('largeFile', largeFile);
                fileUpload.set({ count: fileChunk.size + size });
                fileUpload.set('largeFile', largeFile);
                deferred.resolve(fileChunk);
              })
              .catch(function (errorObj) {

                deferred.reject(fileChunk, errorObj);


              });
              var state = fileUpload.get('state');
              if ((state !== 'aborted') && (state !== 'stopped')) {
                return deferred.promise();
              }  
              else{
                deferred.reject(fileUpload);
              }
            
          }, self, ajaxOptions)
        });


        return deferred.promise(promises);
      });
      return promises;
    },

    completeUpload: function (fileUpload) {
      var largeFile = fileUpload.get('largeFile');
      var url = this.connector.getConnectionUrl().getApiBase('v2') + "multipart/" + largeFile.uploadKey;
      var ajaxOptions = {
        url: url,
        type: 'POST',
        contentType: 'application/x-www-form-urlencoded'
      };
      return this.connector.makeAjaxCall(ajaxOptions);
    },

    createNode: function (file, fileUpload) {
      var largeFile = fileUpload.get('largeFile');
      var url = this.connector.getConnectionUrl().getApiBase('v2') + "nodes",
        formData = {
          parent_id: this.container.get('id'),
          type: 144,
          name: file.name,
          upload_key: largeFile.uploadKey,
        },
        ajaxOptions = {
          url: url,
          type: 'POST',
          data: formData,
          contentType: 'application/x-www-form-urlencoded'
        };
        return this.connector.makeAjaxCall(ajaxOptions);
    },

    createVersion: function (nodeId, fileUpload) {
      var largeFile = fileUpload.get('largeFile');
      var url = this.connector.getConnectionUrl().getApiBase('v2') + "nodes/" + nodeId + "/versions",
        formData = {
          upload_key: largeFile.uploadKey,
        },
        ajaxOptions = {
          url: url,
          type: 'POST',
          data: formData,
          contentType: 'application/x-www-form-urlencoded'
        };
        return this.connector.makeAjaxCall(ajaxOptions);
    },


    fetchNode: function (data, node) {
      if (node) {
        node = this.checkAndGetIfExistingNode(node);
        node.attributes = data.results.data.properties;
        data.results.data.versions && node.set('versions', data.results.data.versions);
        return node.fetch({ collection: node.collection, refreshCache: true });
      }
    },
    handleCatch: function (errorObj, fileUpload) {
      var deferred = fileUpload.deferred;
      if (errorObj.status >= 400) {
        var error = new base.RequestErrorMessage(errorObj);
        deferred.reject(fileUpload, error);
      }
      else {
        this.isRetry = true;
        this.retryUpload(fileUpload);
      }

    },
    retryUpload: function (fileUpload) {
      var deferred = fileUpload.deferred;
      var value = navigator.onLine;
      var self = this;
      if (!value) {
        var offlineTimer = setInterval(function () {
          if (navigator.onLine) {
            clearInterval(offlineTimer);
            self.retryUpload(fileUpload);
          }
        }, 2000);
      }
      else {

        if (this.isRetry) {
          this.isRetry = false;
          this.queue = new TaskQueue({
            parallelism: this.options.parallelism || config.parallelism
          });
        }

        var file = fileUpload.get("file");
        var size = file.size;
        var oldLargeFile = fileUpload.get('largeFile');
        var largeFile = {
          size: size,
          uploadKey: "",
          state: "pending",
          fileChunks: {
            slicedFiles: [],
            total: 0
          }
        };
        largeFile.retryCount = oldLargeFile.retryCount;
        largeFile.maxRetries = oldLargeFile.maxRetries;
        fileUpload.set({ count: 0 });
        fileUpload.attributes.upload_key = "";

        fileUpload.set('largeFile', largeFile);
        // var largeFile = fileUpload.get('largeFile');
        var state = fileUpload.get('state');
        if ( (!(largeFile.maxRetries) && (state === 'pending')) 
        ||(((state !== 'aborted') && (state !== 'stopped')) && (largeFile.retryCount < largeFile.maxRetries))) {
          largeFile.retryCount = largeFile.retryCount + 1;
          fileUpload.set('largeFile', largeFile);
          this.scheduleFileForUpload(fileUpload);
        }
        else {
          deferred.reject(fileUpload);
        }

      }


    },


  });
  UploadController.extend = Backbone.View.extend;

  return UploadController;


});

csui.define('csui/controls/disclosure/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/disclosure/impl/nls/root/lang',{
  ariaLabel: 'Information disclosure',
  titleDisclosed: 'See all',
  titleExpanded: 'See less'
});



/* START_TEMPLATE */
csui.define('hbs!csui/controls/disclosure/impl/disclosure.view',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"size":"xsmall","iconName":"csui_caret_up"},"loc":{"start":{"line":4,"column":4},"end":{"line":4,"column":56}}})) != null ? stack1 : "")
    + "\r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "    "
    + ((stack1 = (lookupProperty(helpers,"icon-v2")||(depth0 && lookupProperty(depth0,"icon-v2"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"icon-v2","hash":{"size":"xsmall","iconName":"csui_caret_down"},"loc":{"start":{"line":6,"column":4},"end":{"line":6,"column":58}}})) != null ? stack1 : "")
    + "\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<button class=\"csui-control csui-disclosure\" aria-expanded=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"ariaExpanded") || (depth0 != null ? lookupProperty(depth0,"ariaExpanded") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"ariaExpanded","hash":{},"loc":{"start":{"line":1,"column":60},"end":{"line":1,"column":76}}}) : helper)))
    + "\"\r\n        aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"ariaLabel") || (depth0 != null ? lookupProperty(depth0,"ariaLabel") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"ariaLabel","hash":{},"loc":{"start":{"line":2,"column":20},"end":{"line":2,"column":33}}}) : helper)))
    + "\" "
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"disabled") || (depth0 != null ? lookupProperty(depth0,"disabled") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"disabled","hash":{},"loc":{"start":{"line":2,"column":35},"end":{"line":2,"column":47}}}) : helper)))
    + " title=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":2,"column":55},"end":{"line":2,"column":64}}}) : helper)))
    + "\">\r\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"ariaExpanded") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"loc":{"start":{"line":3,"column":2},"end":{"line":7,"column":9}}})) != null ? stack1 : "")
    + "</button>";
}});
Handlebars.registerPartial('csui_controls_disclosure_impl_disclosure.view', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/disclosure/disclosure.icons.v2',[
  'csui/controls/icons.v2',
], function (iconRegistry) {
  iconRegistry.registerIcons(
      {
        "csui_caret_up": '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"' +
                         ' class="csui-icon-v2' +
                         ' csui-impl-icon-v2__caret_up"' +
                         ' xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 18' +
                         ' 18" xml:space="preserve"> <polyline' +
                         ' fill="none" stroke="#333333" stroke-width="2" stroke-linecap="round"' +
                         ' stroke-miterlimit="10" points="4,12 9,7 14,12 "/></svg>',
        "csui_caret_down": '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" class="csui-icon-v2' +
                           ' csui-impl-icon-v2__caret_down"' +
                           ' xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0' +
                           ' 18 18" xml:space="preserve"> <polyline' +
                           ' fill="none" stroke="#333333" stroke-width="2" stroke-linecap="round"' +
                           ' stroke-miterlimit="10" points="14,7 9,12 4,7 "/></svg>'
      }
  );
});

csui.define('css!csui/controls/disclosure/impl/disclosure.view',[],function(){});
csui.define('csui/controls/disclosure/disclosure.view',['csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/behaviors/keyboard.navigation/retainfocus.behavior',
  'i18n!csui/controls/disclosure/impl/nls/lang',
  'hbs!csui/controls/disclosure/impl/disclosure.view',
  'csui/controls/disclosure/disclosure.icons.v2',
  'css!csui/controls/control/impl/control',
  'css!csui/controls/disclosure/impl/disclosure.view'
], function ($, _, Backbone, Marionette, RetainFocusBehavior, lang, template, iconRegistry) {
  'use strict';

  return Marionette.ItemView.extend({

    // all controls should have csui-control-view for applying common css */
    className: 'csui-control-view csui-disclosure-view',
    template: template,

    templateHelpers: function () {
      var expanded = this.model.get("expanded");
      return {
        disabled: this.model.get('disabled') ? 'disabled' : '',
        ariaExpanded: expanded,
        title: expanded ? (this.titleExpanded ? this.titleExpanded : lang.titleExpanded) :
               (this.titleDisclosed ? this.titleDisclosed : lang.titleDisclosed),
        ariaLabel: expanded ? (this.ariaLabelExpanded ? this.ariaLabelExpanded : lang.ariaLabel) :
                   (this.ariaLabelDisclosed ? this.ariaLabelDisclosed : lang.ariaLabel)
      };
    },

    modelEvents: {
      'change:disabled': 'render',
      'change:expanded': 'render'
    },

    events: {
      'click': '_toggleExpanded'
    },

    behaviors: {
      RetainFocusBehavior: {behaviorClass: RetainFocusBehavior}
    },

    constructor: function Disclosure(options) {
      options || (options = {});

      this.ariaLabelDisclosed = options.ariaLabelDisclosed;
      this.ariaLabelExpanded = options.ariaLabelExpanded;
      this.titleDisclosed = options.titleDisclosed;
      this.titleExpanded = options.titleExpanded;

      if (!options.model) {

        options.model = new Backbone.Model(
            {
              disabled: options.disabled === undefined ? false : options.disabled
            });

      }
      Marionette.ItemView.prototype.constructor.call(this, options);
      this.setExpanded(options.expanded);
    },

    setDisabled: function (d) {
      this.model.set('disabled', !!d);
    },

    setExpanded: function (expanded) {
      var options = {silent: false};
      if (this.model.get('disabled')) {
        options.silent = true;
      }
      switch (expanded) {
      case 'true':
      case true:
        this.model.set('expanded', true, options);
        break;
      default:
        this.model.set('expanded', false, options);
        break;
      }
    },

    _toggleExpanded: function () {
      if (this.model.get('disabled')) {
        return; // don't change checkbox and don't fire events, because it's disabled
      }

      // first trigger a clicked event and if no listener set cancel=true on the event args toggle
      // the expanded state
      var currentState = this.model.get('expanded');
      var args = {sender: this, model: this.model};
      this.triggerMethod('clicked', args);

      if (!args.cancel) {
        this.model.set('expanded', !currentState);  // toggle expanded state
      }
    }

  });
});
csui.define('csui/models/appliedcategory',['csui/lib/underscore', 'csui/lib/backbone',
  'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/uploadable/uploadable.mixin'
], function (_, Backbone, ConnectableMixin, UploadableMixin) {

  var AppliedCategoryModel = Backbone.Model.extend({

    constructor: function AppliedCategoryModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);

      this.makeConnectable(options)
          .makeUploadable(options);
    },

    isNew: function () {
      // New category is assigned by POSTing the object with 'category_id';
      // when fetched in the collection, the identifier comes in 'id'.
      return !!this.get('category_id');
    },

    parse: function (response, options) {
      // POST returns no attributes now.  If it did, there'd be 'id', 'name'
      // etc.  Ensure that at least the 'id' is set correctly to indicate that
      // the category assignment is not new anymore.  (Creating a new category
      // assignment is done by POSTing the object with 'category_id'; when
      // fetched in the collection, the identifier comes in 'id'.)
      var attributes = this.attributes;
      if (attributes.category_id) {
        response.id = attributes.category_id;
        delete attributes.category_id;
      }
      return response;
    }

  });

  UploadableMixin.mixin(AppliedCategoryModel.prototype);
  ConnectableMixin.mixin(AppliedCategoryModel.prototype);

  return AppliedCategoryModel;

});

csui.define('csui/models/appliedcategories/server.adaptor.mixin',[
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/utils/url'
], function ($, _, Url) {
  'use strict';

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makeServerAdaptor: function (options) {
          return this;
        },

        url: function () {
          return Url.combine(this.node.urlBase(), 'categories');
        },

        parse: function (response, options) {
          return this.sortInitially(response.data);
        },

        sortInitially: function (data) {
          //default initial sort (only on arrays) is based on `name`.
          return _.isArray(data) ? _.sortBy(data, function (ele) {return ele.name.toLowerCase()}) :
                 data;
        }
      });
    }
  };


  return ServerAdaptorMixin;
});

csui.define('csui/models/appliedcategories',['csui/lib/underscore', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/mixins/node.resource/node.resource.mixin',
  'csui/models/appliedcategory', 'csui/models/appliedcategories/server.adaptor.mixin'
], function (_, Backbone, Url, NodeResourceMixin, AppliedCategoryModel, ServerAdaptorMixin) {
  'use strict';

  var AppliedCategoryCollection = Backbone.Collection.extend({

    model: AppliedCategoryModel,

    constructor: function AppliedCategoryCollection(models, options) {
      options || {};

      //let the caller override default sorting.
      this.sortInitially = !!options.sortInitially ? options.sortInitially :
                           this.sortInitially;

      Backbone.Collection.prototype.constructor.apply(this, arguments);

      this.makeNodeResource(options);
    },

    clone: function () {
      return new this.constructor(this.models, {node: this.node});
    }

  });

  NodeResourceMixin.mixin(AppliedCategoryCollection.prototype);
  ServerAdaptorMixin.mixin(AppliedCategoryCollection.prototype);

  return AppliedCategoryCollection;

});

csui.define('csui/models/fileupload',['module', 'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/utils/log', 'csui/models/node/node.model', 'csui/models/version'
], function (module, _, $, Backbone, log, NodeModel, VersionModel) {
  'use strict';

  var config = _.extend({
    idAttribute: null
  }, module.config());

  // {
  //   file:       File object to upload
  //   state:      upload progress state: pending, processing, resolved, rejected
  //   newName:    Overrides file name if new document is to be created
  //   newVersion: Forces a new version to be created instead of a new document
  //   id:         Provide node ID for new version creation if the existing node
  //               was not specified in the constructor
  // }

  // TODO: Enable switching from upload renamed file to upload new version
  // by some interface, so that the version property can be used and not
  // the additional boolean

  var FileUploadModel = Backbone.Model.extend({

    defaults: {
      state: "pending",
      count: 0,
      total: 0,
      errorMessage: "",
      sequence: 0
    },

    idAttribute: config.idAttribute,

    constructor: function FileUploadModel(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);

      options || (options = {});
      this.node = options.node;

      // Uploading a file as a new version takes place on an existing
      // node, otherwise a new document will be created
      if (this.node) {
        this.setVersion(options);
      }
      else {
        this.setNode(options);
      }

      this.deferred = $.Deferred();
      this.deferred
        .progress(_.bind(this.onStateChange, this))
        .done(_.bind(this.onStateChange, this))
        .fail(_.bind(this.onStateChange, this));

      this._updateFileAttributes(true);
      this.listenTo(this, 'change:file',
        _.bind(this._updateFileAttributes, this, false));
    },

    setVersion: function (options) {
      // Stay compatible with conflict resolution, which controls
      // this model by newName and newVersion attributes
      this.set('newVersion', true, {silent: true});
      this.version = new VersionModel({
        id: this.node.get('id')
      }, {
        connector: options.connector || this.node.connector
      });
    },

    setNode: function (options) {
      this.container = options.container;
      this.node = new NodeModel(undefined, _.extend({
        connector: options.connector ||
                   this.container && this.container.connector
      }, options, {
        collection: this.get('collection')
      }));
    },

    abort: function (reason) {
      this.deferred.reject(this, reason);
    },

    promise: function () {
      return this.deferred.promise();
    },

    onStateChange: function (fileUpload, options) {
      var state = this.deferred.state();
      // A promise can be in the states: pending, resolved or rejected.  A file
      // upload defined an additional state - processing.
      if (state == "pending") {
        state = "processing";
      } else if (state === "rejected") {
        fileUpload && fileUpload.get('file') && 
        this.set({count : fileUpload.get('file').size, silent: true}); // count rejected file size for progress percentage calculation
        if (options && options.message) {
          this.set("errorMessage", options.message);// Rejecting with a message is error
          if (options.statusCode >= 500) {
            // Setting serverFailure to true whenever there's server side error which
            // is used to enable retry button extended in progress panel view 
            this.set({serverFailure : true}); 
          }
        } else if(options && options.state) {
          state = options.state;                     // Rejecting with a state
        } else {
          state = "aborted";                         // Rejecting without any error is aborted
        }
      }
      // we get progress events with loaded larger than the total file size
      // also we get a progress event at the end with a very small number for loaded
      var values = {state: state};
      if (options && options.type === "progress") {
        var loaded = options.loaded,
            total = this.get("total");
        if (options.lengthComputable && options.total > total) {
          total = options.total;
          values.total = total;
        }
        if (this.get("count") < loaded && loaded <= total) {
          values.count = loaded;
        }
      }
      this.set(values);
    },

    _updateFileAttributes: function (silent) {
      var file = this.get("file");
      if (file) {
        this.set({
          name: file.name,
          total: file.size
        }, silent ? {silent: true} : {});
      }
    }

  });

  return FileUploadModel;

});

csui.define('csui/models/fileuploads',["module", "csui/lib/underscore", "csui/lib/jquery", "csui/lib/backbone", "csui/utils/log",
  "csui/models/fileupload"
], function (module, _, $, Backbone, log, FileUploadModel) {

  var FileUploadCollection = Backbone.Collection.extend({

    model: FileUploadModel,

    constructor: function FileUploadCollection(models, options) {
      Backbone.Collection.prototype.constructor.apply(this, arguments);
    },

    state: function () {
      var failed = false,
          processing = false,
          processed = this.all(function (fileUpload) {
            var state = fileUpload.get("state"),
                rejected = state == "rejected";
            failed = failed || rejected;
            processing = processing || state == "processing";
            return rejected || state == "resolved";
          });
      return processed ?
             failed ? "rejected" : "resolved" :
             processing ? "processing" : "pending";
    },

    abort: function (state) {
      this.forEach(function (fileUpload) {
        var abortState = fileUpload.get('abortState');
        if (abortState) {
          fileUpload.abort();
          fileUpload.set('state', state);
        }
      });
    }

  });

  FileUploadCollection.version = '1.0';

  return FileUploadCollection;

});

csui.define('csui/models/namequery/server.adaptor.mixin',[
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/utils/url', 'csui/models/fileupload'
], function ($, _, Url, FileUploadModel) {
  'use strict';

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makeServerAdaptor: function (options) {
          return this;
        },

        url: function () {
          return Url.combine(this.connector.connection.url, 'validation/nodes');
        },

        queryNames: function (files) {
          var containerId = this.get('containerId'),
              deferred    = $.Deferred();
          this.fileGroups = this._getFileNameGroups(files);

          if (this.fileGroups.length === 0) {
            deferred.reject();
          }
          else {
            this._runQuery(0, containerId, deferred);
          }

          return deferred.promise();
        },

        runQuery: function (parentId, queryName) {
          var data = {
            'parent_id': parentId,
            'names': queryName
          };

          return this._jqxhr(data);
        },

        _jqxhr: function (data) {
          var deferred = $.Deferred();

          this.save(data, {data: data})
              .done(deferred.resolve)
              .fail(deferred.reject);

          return deferred.promise();
        },

        _runQuery: function (index, parentId, deferred) {
          var self       = this,
              fileGroups = this.fileGroups;

          //run separate queries for each group of files.
          if (fileGroups && fileGroups[index]) {
            var data = {
              'parent_id': parentId,
              'names': this._getFileNames(fileGroups[index])
            };

            this._jqxhr(data)
                .done(function (data, result, request) {
                  self._addResults(data, fileGroups[index]);
                  //Run query on next file grouping
                  if (fileGroups[++index]) {
                    self._runQuery(index, parentId, deferred);
                  }
                  else {
                    deferred.resolve(self.cleanFiles, self.conflictFiles);
                  }
                })
                .fail(function (request, message, statusText) {
                  deferred.reject(request);
                });

          }

        },

        _addResults: function (data, fileGroup) {
          _.each(fileGroup, function (groupFile) {
            var name = groupFile.newName || groupFile.name ||
                       groupFile.get('newName') || groupFile.get('name'),
                item = _.find(data.results, function (item) {
                      return item.name === name;
                    }) || {}; // Old API did not send anything in case of no conflict
            // if type ids already there for item take that.

            if (groupFile instanceof FileUploadModel) {
              var groupFileSubtype = groupFile.get('subType');
              if (groupFileSubtype === 0) { // for newly created folders
                item.type = 0;
              }
            } else if (groupFile.type === 0) { // after renaming folder, set the type to 0.
              item.type = 0;
            }
            updateGroupFile.call(this, groupFile, item);
            if (item.id) {
              this.conflictFiles.push(groupFile);
            } else {
              this.cleanFiles.push(groupFile);
            }
          }, this);

          function updateGroupFile(groupFile, item) {
            if (groupFile instanceof FileUploadModel) {
              groupFile.set({
                // first let's try to obtain type from item which is being set by "/validation" REST API response.
                type: (item.type !== undefined && item.type !== null) ? item.type : groupFile.get('subType'),
                versioned: item.versioned
              });
              item.id && groupFile.set('id', item.id);
            } else {
              _.extend(groupFile, {
                id: item.id,
                type: item.type,
                versioned: item.versioned
              });
            }
          }
        },

        _getFileNames: function (files) {
          var names = [];
          _.each(files, function (file) {
            var name = '';
            if (file instanceof FileUploadModel) {
              name = file.get('newName') || file.get('name');
            }
            else {
              name = file.newName || file.name;
            }
            names.push(name);
          });
          return names;
        },

        _getFileNameGroups: function (files) {
          var fileArray       = $.isArray(files) ? files : files.models,
              i               = 0, counter = 1,
              numFiles        = fileArray.length,
              fileQueryGroups = [];

          while (i < numFiles) {
            var group = [],
                limit = this.config.filesPerQuery * counter++;

            for (; i < numFiles && i < limit; i++) {
              fileArray[i].index = i;
              group.push(fileArray[i]);
            }
            fileQueryGroups.push(group);
          }

          return fileQueryGroups;
        }

      });
    }
  };
  return ServerAdaptorMixin;
});
csui.define('csui/models/namequery',['module', 'csui/lib/jquery', 'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/uploadable/uploadable.mixin',
  'csui/models/namequery/server.adaptor.mixin'
], function (module, $, _, Backbone,
    ConnectableMixin, UploadableMixin, ServerAdaptorMixin) {
  'use strict';

  var config = module.config();
  _.defaults(config, {
    filesPerQuery: 10
  });

  var NameQuery = Backbone.Model.extend({

    constructor: function NameQuery(attributes, options) {
      Backbone.Model.prototype.constructor.apply(this, arguments);

      this.conflictFiles = [];
      this.cleanFiles = [];
      this.config = config;

      this.makeConnectable(options)
          .makeUploadable(options);
    }
  });

  UploadableMixin.mixin(NameQuery.prototype);
  ConnectableMixin.mixin(NameQuery.prototype);
  ServerAdaptorMixin.mixin(NameQuery.prototype);

  return NameQuery;

});

csui.define('csui/models/versions',["module", "csui/lib/backbone", "csui/utils/log", "csui/models/version"
], function (module, Backbone, log, VersionModel) {
  'use strict';

  var VersionCollection = Backbone.Collection.extend({

    model: VersionModel,

    constructor: function VersionCollection(models, options) {
      Backbone.Collection.prototype.constructor.apply(this, arguments);
      this.options = options || {};
      if (this.options.connector) {
        this.options.connector.assignTo(this);
      }
    },

    setOrder: function (attributes, fetch) {
      if (this.orderBy !== attributes) {
        this.orderBy = attributes;
        //this._runAllOperations();
        return true;
      }
    },

    resetOrder: function (fetch) {
      if (this.orderBy) {
        this.orderBy = undefined;
        if (fetch !== false) {
          this.fetch();
        }
        return true;
      }
    },

    setLimit: function (skip, top, fetch) {
      if (this.skipCount !== skip || this.topCount !== top) {
        this.skipCount = skip;
        this.topCount = top;
        if (fetch !== false) {
          this.fetch();
        }
        return true;
      }
    },

    resetLimit: function (fetch) {
      if (this.skipCount) {
        this.skipCount = 0;
        if (fetch !== false) {
          this.fetch();
        }
        return true;
      }
    }

  });
  VersionCollection.version = '1.0';

  return VersionCollection;

});

csui.define('csui/models/server.adaptors/nodeversions.mixin',[
  'csui/lib/underscore', 'csui/utils/url'
], function (_, Url) {
  'use strict';

  var ServerAdaptorMixin = {

    mixin: function (prototype) {

      return _.extend(prototype, {
        makeServerAdaptor: function (options) {
          return this;
        },

        url: function () {
          return this.options.useV2RestApi ? _useV2Url.call(this) : _useV1Url.call(this);
        },

        parse: function (response) {
          return this.options.useV2RestApi ?
                 _parseV2Response.call(this, response) :
                 _parseV1Response.call(this, response);
        },

        getColumnModels: function (columnKeys, definitions) {
          var columns = _.reduce(columnKeys, function (colArray, column) {
            if (column.indexOf('_formatted') >= 0) {
              var shortColumnName = column.replace(/_formatted$/, '');
              if (definitions[shortColumnName]) {
                // there is also the column without the trailing _formatted: skip this and use this
                // instead
                return colArray;
              }
            } else {
              // copy the definitions_order from the *_formatted column to the non-formatted column
              // because it is assumed that the attributes form *_formatted column are more important
              var definition_short = definitions[column];
              if (!definition_short.definitions_order) {
                var definition_formatted = definitions[column + '_formatted'];
                if (definition_formatted && definition_formatted.definitions_order) {
                  definition_short.definitions_order = definition_formatted.definitions_order;
                }
              }
            }
            var definition = definitions[column];

            switch (column) {
              case "name":
                definition = _.extend(definition, {
                  default_action: true,
                  contextual_menu: false,
                  editable: true,
                  filter_key: "name"
                });
                break;
            }

            definition.sort = true;

            colArray.push(_.extend({column_key: column}, definition));
            return colArray;
          }, []);
          return columns;
        }

      });
    }
  };

  // TODO: Remove this, as soon as the version REST API returns actions
  // (Another workaround could be loading all versions anew)
  function fakeActions(node, version) {
    var actions = [];
    if (node.actions.findRecursively('download') || node.actions.findRecursively('Download')) {
      actions.push({signature: 'versions_download'}, {signature: 'versions_open'});
    }
    if (node.actions.findRecursively('delete') || node.actions.findRecursively('Delete')) {
      actions.push({signature: 'versions_delete'});
    }
    if (node.actions.findRecursively('properties') || node.actions.findRecursively('Properties')) {
      actions.push({signature: 'versions_properties'});
    }
    version.actions = actions;
  }

  // used to form RestApi URL for V2 request
  function _useV2Url() {
    return Url.combine(this.connector.getConnectionUrl().getApiBase('v2'),
        '/nodes/' + this.node.get("id"),
        '/versions?expand=' + encodeURIComponent('versions{owner_id}') +
        '&metadata&actions');
  }

  // used to form RestApi URL for V1 request
  function _useV1Url() {
    var query = Url.combineQueryString(
        this.getExpandableResourcesUrlQuery(),
        {
          extra: false,
          commands: this.options.commands || []
        }
    );
    return Url.combine(this.node.urlBase(), '/versions?' + query);

  }

  // parsing V1 response for V1 RESTAPI
  function _parseV1Response(response) {
    // parse column data
    var definitions = response.definitions;
    var columnKeys = _.keys(definitions);  // use all columns not only those in definitions_order

    if (!this.options.onlyClientSideDefinedColumns) {
      // merge definitions_order into definitions as definitions_order attribute
      if (response.definitions_order) {
        for (var idx = 0; idx < response.definitions_order.length; idx++) {
          var column_key = response.definitions_order[idx];
          definitions[column_key].definitions_order = 500 + idx;
        }
      }
    }

    this.columns.reset(this.getColumnModels(columnKeys, definitions));

    if (response.data) {
      _.each(response.data, function (version) {
        // Instead of fetch extra node type info for version collection, assign it here from node
        version.id_expand = {};
        version.id_expand.type = this.node.get('type');
        // TODO: Remove this, as soon as the version REST API returns actions
        if (!(version.commands || version.actions)) {
          fakeActions(this.node, version);
        }
      }, this);
    }

    return response.data;
  }

  //Parsing V2 response for V2 RESTAPI
  function _parseV2Response(response) {
    var definitions = response.results[0].metadata.versions,
        finalresponse = [],
        columnKeys = _.keys(definitions);  // use all columns not only those in definitions_order

    this.columns.reset(this.getColumnModels(columnKeys, definitions));

    if (response.results) {

      _.each(response.results, function (version) {

        version.data.versions.id_expand = {};
        version.data.versions.id_expand.type = this.node.get('type');
        _parseActions(version.actions, version.data.versions);
        finalresponse.push(version.data.versions);
      }, this);
    }

    return finalresponse;
  }

  // parsing actions and adding singature for existing actions
  function _parseActions(actions, version) {
    version.actions = [];
    _.each(actions.data, function (action) {
      action.signature = action.name;
      version.actions.push(action);
    });

  }

  return ServerAdaptorMixin;
});

csui.define('csui/models/nodeversions',['module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/base', 'csui/utils/log', 'csui/utils/url',
  'csui/models/versions', 'csui/models/actions', 'csui/models/columns',
  'csui/models/mixins/node.resource/node.resource.mixin',
  'csui/models/mixins/expandable/expandable.mixin',
  'csui/models/browsable/client-side.mixin',
  'csui/models/server.adaptors/nodeversions.mixin',
  'csui/utils/deepClone/deepClone'
], function (module, _, Backbone, base, log, Url,
    VersionCollection, ActionCollection,
    NodeColumnCollection, NodeResourceMixin,
    ExpandableMixin, ClientSideBrowsableMixin, ServerAdaptorMixin) {
  'use strict';

  var NodeVersionCollection = VersionCollection.extend({

    // TODO: Once MetadataNavigation allows setting title, you are free
    // to modify the name of the constructor.  For the time being, it
    // is used as an interface to recognize object of this class.
    constructor: function NodeVersionCollection(models, options) {
      VersionCollection.prototype.constructor.apply(this, arguments);

      this.makeNodeResource(options)
          .makeExpandable(options)
          .makeClientSideBrowsable(options)
          .makeServerAdaptor(options);

      this.columns = new NodeColumnCollection();
    },

    clone: function () {
      return new this.constructor(this.models, {
        node: this.node,
        skip: this.skipCount,
        top: this.topCount,
        filter: _.deepClone(this.filters),
        orderBy: _.clone(this.orderBy),
        expand: _.clone(this.expand),
        // TODO: Use commandable mixin.
        commands: _.clone(this.options.commands)
      });
    }

  });

  ClientSideBrowsableMixin.mixin(NodeVersionCollection.prototype);
  ExpandableMixin.mixin(NodeVersionCollection.prototype);
  NodeResourceMixin.mixin(NodeVersionCollection.prototype);
  ServerAdaptorMixin.mixin(NodeVersionCollection.prototype);

  // override setOrder function of mixin to replace version_number_name by version_number for
  // ordering with this column
  var originalSetOrder = NodeVersionCollection.prototype.setOrder;
  NodeVersionCollection.prototype.setOrder = function (attributes, fetch) {
    if (attributes) {
      // attributes = attributes.replace(/version_number_name/, 'version_number');
    }
    return originalSetOrder.call(this, attributes, fetch);
  };

  return NodeVersionCollection;

});

csui.define('csui/models/node.facets/facet.query.mixin',[
  'csui/lib/underscore', 'csui/lib/jquery'
], function (_, $) {
  'use strict';

  var FacetQueryMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makeFacetQuery: function (options) {
          return this;
        },
        /**
         * returns params in the form of object which can be used for POST requests.
         * @param {facet filters} filters
         */
        getFilterParam: function (filters) {
          return getFilterParam(filters || this.filters,
              this.filterQueryParameterName);
        },

        getFilterQuery: function (filters) {
          return getFilterQuery(filters || this.filters,
              this.filterQueryParameterName);
        },

        getFilterQueryValue: function (filters) {
          return getFilterQueryValue(filters || this.filters);
        }
      });
    }
  };

  function getFilterParam(filters, parameterName) {
    var value = getFilterQueryValue(filters), parameters = {};
    if (value.length) {
      parameters[parameterName] = value;
    }
    return parameters;
  }

  function getFilterQuery(filters, parameterName) {
    var parameters = getFilterParam(filters, parameterName);
    return $.param(parameters, true);
  }

  function getFilterQueryValue(filters) {
    return filters && _.map(filters, getFilterValue) || [];
  }

  function getFilterValue(filter) {
    return filter.id + ':' +
           _.reduce(filter.values, function (result, value) {
             if (result) {
               result += '|';
             }
             return result + value.id.toString();
           }, '');
  }

  return FacetQueryMixin;
});

csui.define('csui/models/widget/search.results/search.facet.query.mixin',[
  'csui/lib/underscore', 'csui/lib/jquery'
], function (_, $) {
  'use strict';

  var FacetQueryMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makeFacetQuery: function (options) {
          return this;
        },
        /**
         * returns params in the form of object which can be used for POST requests.
         * @param {facet filters} filters
         */
        getFilterParam: function (filters) {
          return getFilterParam(filters || this.filters,
              this.filterQueryParameterName);
        },

        getFilterQuery: function (filters) {
          return getFilterQuery(filters || this.filters,
              this.filterQueryParameterName);
        },

        getFilterQueryValue: function (filters) {
          return getFilterQueryValue(filters || this.filters);
        }
      });
    }
  };

  function getFilterParam(filters, parameterName) {
    var value = getFilterQueryValue(filters), parameters = {};
    if (value.length) {
      parameters[parameterName] = value;
    }
    return parameters;
  }

  function getFilterQuery(filters, parameterName) {
    var parameters = getFilterParam(filters, parameterName);
    return $.param(parameters, true);
  }

  function getFilterQueryValue(filters) {
    return filters && _.map(filters, getFilterValue) || [];
  }

  function getFilterValue(filter) {
    return filter.id + ':{' +
           _.reduce(filter.values, function (result, value) {
             if (result) {
               result += ',';
             }
             return result + value.id.toString();
           }, '')
           + '}';
  }

  return FacetQueryMixin;
});

csui.define('csui/models/node.facets/server.adaptor.mixin',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/utils/url',
  'csui/models/node.facets/facet.query.mixin'
], function (_, $, Url, FacetQueryMixin) {
  'use strict';

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      var originalFetch = prototype.fetch;

      FacetQueryMixin.mixin(prototype);

      return _.extend(prototype, {
        filterQueryParameterName: 'where_facet',

        makeServerAdaptor: function (options) {
          return this.makeFacetQuery(options);
        },

        isFetchable: function () {
          var node = this.node,
              type = node.get('type'),
              locationId = node.get('location_id');
          //Location id === 0 means the VF is empty, and in the eyes of CS invalid, so
          //no need to burden server with a request that will only return an error result.
          if (type === 899 && locationId === 0) {
            return false;
          }
          return true;
        },

        url: function () {
          var nodeId = this.node.get(this.node.get('type') === 899 ? 'location_id' : 'id'),
              filters = _.union(getNodeFilters(this.node), this.filters),
              filter = this.getFilterQuery(filters),
              url = Url.combine(this.connector.connection.url, 'nodes', nodeId, '/facets');
          if (filter) {
            url += '?' + filter;
          }
          return url;
        },

        parse: function (response, options) {
          var topics = response.facets || {},
              facets = topics.properties || {},
              selected = topics.selected_values || [],
              available = topics.available_values || [];
          selected.forEach(markSelectedTopics.bind(null, true));
          available.forEach(markSelectedTopics.bind(null, false));
          if (this.node.get('type') === 899) {
            var nodeFacets = this.node.get('selected_facets') || [];
            nodeFacets = nodeFacets.map(function (facet) {
              return facet[0];
            });
            selected = selected.filter(function (facet) {
              var id = _.keys(facet)[0];
              return !_.contains(nodeFacets, id);
            });
          }
          return selected
              .concat(available)
              .map(mergeFacetTopics.bind(null, facets));
        }
      });
    }
  };

  function markSelectedTopics(selected, facet) {
    // topics are nested by the facet id as the key property
    var id = _.keys(facet)[0],
        topics = facet[id];
    _.each(topics, function (topic) {
      // Convert the ID always to string to be able to use Backbone
      // searching methods like where(), which compare by ===.
      topic.value = topic.value.toString();
      topic.selected = selected;
    });
  }

  function mergeFacetTopics(facets, facet) {
    // topics are nested by the facet id as the single key property
    var id = _.keys(facet)[0],
        topics = facet[id],
        properties = facets[id] || {};
    // merge topics with the facet information
    return _.extend({
      items_to_show: 5,
      select_multiple: true,
      topics: topics
    }, properties, {
      // Convert the ID always to string to be able to use Backbone
      // searching methods like where(), which compare by ===.
      id: id.toString()
    });
  }

  function getNodeFilters(node) {
    var selectedFacets = [];
    if (node.get('type') === 899) {
      //selected_facets format = [['61033', [140]], ['61032', ['1000', '64039']]];
      var virtualFacets = node.get('selected_facets');
      selectedFacets = _.map(virtualFacets, function (item) {
        var facetGroup = {'id': item[0], 'values': []};
        item[1].forEach(function (id) {
          facetGroup.values.push({'id': id});
        });
        return facetGroup;
      });
    }
    return selectedFacets;
  }

  return ServerAdaptorMixin;
});

csui.define('csui/models/nodefacets',[
  'csui/lib/underscore', 'csui/models/facets',
  'csui/models/mixins/node.resource/node.resource.mixin',
  'csui/models/node.facets/server.adaptor.mixin',
  'csui/utils/deepClone/deepClone'
], function (_, FacetCollection, NodeResourceMixin, ServerAdaptorMixin) {
  'use strict';

  var NodeFacetCollection = FacetCollection.extend({
    constructor: function NodeFacetCollection(models, options) {
      FacetCollection.prototype.constructor.apply(this, arguments);
      this.makeNodeResource(options)
          .makeServerAdaptor(options);
    },

    clone: function () {
      return new this.constructor(this.models, {
        node: this.node,
        filters: _.deepClone(this.filters)
      });
    }
  });

  NodeResourceMixin.mixin(NodeFacetCollection.prototype);
  ServerAdaptorMixin.mixin(NodeFacetCollection.prototype);

  return NodeFacetCollection;
});

csui.define('csui/models/node/node.facet.factory',['module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/contexts/factories/factory', 'csui/utils/contexts/factories/node',
  'csui/models/nodefacets'
], function (module, _, Backbone, CollectionFactory, NodeModelFactory, NodeFacetCollection) {

  var FacetCollectionFactory = CollectionFactory.extend({

    propertyPrefix: 'facets',

    constructor: function FacetCollectionFactory(context, options) {
      CollectionFactory.prototype.constructor.apply(this, arguments);

      var facets = this.options.facets || {};
      if (!(facets instanceof Backbone.Collection)) {
        var node = facets.options && facets.options.node ||
                   context.getModel(NodeModelFactory, options),
            config = module.config();
        facets = new NodeFacetCollection(facets.models, _.defaults(
            config.options,
          facets.options,
            {
              // Prefer refreshing the entire collection after re-fetching it
              // to improve rendering performance
              autoreset: true
            },
            // node is intentionally listed at the end to give previous options preference
            {node: node}
        ));
      }
      this.property = facets;
    },

    fetch: function (options) {
      return this.property.fetch(options);
    }

  });

  return FacetCollectionFactory;

});

csui.define('csui/models/node/node.facet2.factory',['module', 'nuc/lib/underscore', 'nuc/lib/backbone',
  'csui/utils/contexts/mixins/clone.and.fetch.mixin',
  'csui/utils/contexts/factories/factory',
  'csui/utils/contexts/factories/node',
  'csui/models/nodefacets2'
], function (module, _, Backbone,
    CloneAndFetchMixin,
    CollectionFactory,
    NodeModelFactory,
    NodeFacet2Collection) {

  var Facet2CollectionFactory = CollectionFactory.extend({

    propertyPrefix: 'facets2',

    constructor: function Facet2CollectionFactory(context, options) {
      CollectionFactory.prototype.constructor.apply(this, arguments);

      var facets = this.options.facets2 || {};
      if (!(facets instanceof Backbone.Collection)) {
        var node = facets.options && facets.options.node ||
                   context.getModel(NodeModelFactory, options),
            config = module.config();
        facets = new NodeFacet2Collection(facets.models, _.defaults(
            config.options,
            facets.options,
            {
              // Prefer refreshing the entire collection after re-fetching it
              // to improve rendering performance
              autoreset: true
            },
            // node is intentionally listed at the end to give previous options preference
            {node: node}
        ));
      }
      this.property = facets;

      this.makeCloneAndFetch(options);
    },

    isFetchable: function () {
      return this.property.isFetchable();
    },

    fetch: function (options) {
      return this.property.fetch(options);
    }

  });

  CloneAndFetchMixin.mixin(Facet2CollectionFactory.prototype);

  return Facet2CollectionFactory;
});

csui.define('csui/models/widget/search.results/search.response.mixin',[
    'csui/lib/underscore', 'csui/utils/base', 'csui/utils/accessibility',
    'csui/models/ancestor', 'csui/models/node/node.model'
], function (_, base, Accessibility, AncestorModel, NodeModel) {
  'use strict';
  var accessibleTable = Accessibility.isAccessibleTable();
  var SearchResponseMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makeSearchResponse: function (options) {
          return this;
        },

        /**
         * This method update the response data for the following fields....
         * creation date, modification date, file sizes, previousquery etc.,
         * @param resp
         * @param options
         */
        parseSearchResponse: function (resp, options) {
          var sorting = resp.collection.sorting;
          if (sorting) {
            this.previousQuery = this.options.query.attributes.where;
          }
          this.orderBy = (this.orderBy) ? this.orderBy : sorting && sorting.sort && sorting.sort[0];
          this.previousOrderBy = this.orderBy;
          this.excludeSelectedAndInvalidFacets(resp);
          var jsonResponse = resp.results;
          if (jsonResponse) {
            for (var response in jsonResponse) {
              if (jsonResponse.hasOwnProperty(response)) {
                if (!!jsonResponse[response].data && !!jsonResponse[response].data.properties) {
                  if (!!jsonResponse[response].bestbet) {
                    jsonResponse[response].data.properties.bestbet = jsonResponse[response].bestbet;
                  }
                  if (!!jsonResponse[response].nickname) {
                    jsonResponse[response].data.properties.nickname = jsonResponse[response].nickname;
                  }
                  if (!!jsonResponse[response].data.versions &&
                      !!jsonResponse[response].data.versions.file_size) {
                    jsonResponse[response].data.properties.size = jsonResponse[response].data.versions.file_size;
                  }
                  if (!!jsonResponse[response].data.versions &&
                      !!jsonResponse[response].data.versions.version_id) {
                    jsonResponse[response].data.properties.version_id = jsonResponse[response].data.versions.version_id;
                  }
                  if (!!jsonResponse[response].data.properties &&
                      !!jsonResponse[response].data.properties.container &&
                      jsonResponse[response].data.properties.container) {
                    jsonResponse[response].data.properties.size = jsonResponse[response].data.properties.container_size;
                  }
                  if (!!jsonResponse[response].data.properties.summary) {
                    var summary = jsonResponse[response].data.properties.summary;
                    jsonResponse[response].data.properties.stringifiedSummary = this.jsonToStringTokenizer(summary);
                    //incase of no summary , REST API sends response as summary = [""]
                    if(accessibleTable){
                      jsonResponse[response].data.properties.summary = jsonResponse[response].data.properties.stringifiedSummary;
                    }
                    else{
                      jsonResponse[response].data.properties.summary = Array.isArray(summary) && summary.length > 1 ? summary : summary.length === 1 && summary[0].length ? summary : undefined;
                    }
                    
                  }
                  if (!!jsonResponse[response].data.properties.reserved_user_id_expand) {
                    jsonResponse[response].data.properties.reserved_user_id = jsonResponse[response].data.properties.reserved_user_id_expand;
                  }
                }

                if (!!jsonResponse[response].links && !!jsonResponse[response].links.ancestors) {
                  var breadcrumbsObj = [],
                      ancestors      = jsonResponse[response].links.ancestors,
                      ancestorIds    = [];
                  if (ancestors) {
                    for (var breadcrumbIdx in ancestors) {
                      if (ancestors.hasOwnProperty(breadcrumbIdx)) {
                        var ancestorModel = new AncestorModel();
                        var breadcrumbIndex = parseInt(breadcrumbIdx, 10),
                            breadcrumbItem  = {};
                        var currentObject = ancestors[breadcrumbIndex];
                        breadcrumbItem.id = currentObject.href.substring(
                            currentObject.href.lastIndexOf("/") + 1,
                            currentObject.href.length);
                        breadcrumbItem.volume_id = breadcrumbIndex === 0 ?
                                                   breadcrumbItem.id : ancestorIds[0];
                        breadcrumbItem.parent_id = breadcrumbIndex === 0 ? '-1' :
                                                   ancestorIds[breadcrumbIndex - 1];
                        if (NodeModel.usesIntegerId) {
                          breadcrumbItem.id = parseInt( breadcrumbItem.id );
                          breadcrumbItem.volume_id = parseInt(breadcrumbItem.volume_id);
                          breadcrumbItem.parent_id = parseInt(breadcrumbItem.parent_id);
                        }
                        ancestorIds.push(breadcrumbItem.id);
                        breadcrumbItem.name = currentObject.name;
                        breadcrumbItem.showAsLink = true;
                        ancestorModel.attributes = breadcrumbItem;
                        breadcrumbsObj.push(ancestorModel);
                      }
                    }
                  }
                  jsonResponse[response].data.properties.ancestors = breadcrumbsObj;
                }
                //Regions
                for (var region in jsonResponse[response].data.regions) {
                  if (jsonResponse[response].data.regions.hasOwnProperty(region)) {
                    jsonResponse[response].data.properties[region] = jsonResponse[response].data.regions[region];

                  }
                }
                // copy version details to properties
                if (!!jsonResponse[response].search_result_metadata) {
                  jsonResponse[response].data.properties.search_result_metadata = jsonResponse[response].search_result_metadata;
                }
              }
            }
          }
        },

        jsonToStringTokenizer: function (jsonSummary) {
          var highlightedSummary = "";
          for (var summary in jsonSummary) {
            if (jsonSummary.hasOwnProperty(summary)) {
              highlightedSummary += !!jsonSummary[summary].type ? jsonSummary[summary].text : jsonSummary[summary];
            }
          }
          return highlightedSummary;
        },

        parseBrowsedItems: function (response, options) {
          return response.results;
        },

        /* This function will exclude size facet and all selected facets and sub facets that are
         already selected */
        excludeSelectedAndInvalidFacets: function (response) {
          var searching = response.collection.searching;
          if (!!searching && !!searching.facets && !!searching.facets.available) {
            var availableFacets = searching.facets.available;
            if (!!searching.facets.selected) {
              var selectedFacets = searching.facets.selected;
              var len1 = selectedFacets.length;
              for (var i = 0; i < len1; i++) {
                var len2 = availableFacets.length;
                for (var j = 0; j < len2; j++) {
                  var availableName = availableFacets[j].name;
                  if (availableName === 'OTObjectSize') {
                    availableFacets.splice(j, 1);
                    len2 = availableFacets.length;
                    j--;
                  } else if (availableName === selectedFacets[i].name) {
                    var len3 = selectedFacets[i].facet_items.length;
                    for (var k = 0; k < len3; k++) {
                      var len4 = availableFacets[j].facet_items.length;
                      for (var l = 0; l < len4; l++) {
                        if (availableFacets[j].facet_items[l].display_name ===
                            selectedFacets[i].facet_items[k].display_name) {
                          availableFacets[j].facet_items.splice(l, 1);
                          l--;
                          len4 = availableFacets[j].facet_items.length;
                        }

                      }
                    }
                  } else if (availableFacets[j].facet_items.length === 0) {
                    availableFacets.splice(j, 1);
                    len2 = availableFacets.length;
                    j--;
                  }

                }
              }
            }
          }
        }
      });
    }
  };

  return SearchResponseMixin;
});

csui.define('csui/models/widget/search.results/server.adaptor.mixin',[
  'csui/lib/underscore', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/widget/search.results/search.facet.query.mixin', 'csui/models/node.columns2'
], function (_, Backbone, Url, FacetQueryMixin, NodeColumn2Collection) {
  'use strict';

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      FacetQueryMixin.mixin(prototype);
      var originalSync = prototype.sync;

      return _.extend(prototype, {
        filterQueryParameterName: 'filter',

        makeServerAdaptor: function (options) {
          return this.makeFacetQuery(options);
        },

        cacheId: '',

        url: function () {
          var url = this.connector.getConnectionUrl().getApiBase('v2');
          return Url.combine(url, 'search');
        },

        sync: function (method, model, options) {
          var queryData  = this.options.query.toJSON(),
              urlOptions = this.options.urlOptions || ["\'highlight_summaries\'"];

          if (options.fetchFacets !== undefined) {
            this.fetchFacets = options.fetchFacets;
          }    
          if (this.fetchFacets) {
            urlOptions.push("\'facets\'");
          }
          //Global Search
          if (!!this.options.query.resetDefaults) {
            // The code in the search resets the resetDefaults by clicking on the search icon. The logic does not
            // make any sense. Someone needs to fix the resetting the defaults properly. For now the orderBy needs
            // to honor what is in the url parameters and the viewState. Do not reset it here.
            //this.orderBy = "";
            this.skipCount = 0;
            this.options.query.resetDefaults = false;
          } else {
            // We need to be able to set the orderBy on first fetch of the collection.
            // The orderBy is saved in the viewState and when we refresh the page we need
            // to perform the order by with what has been specified in the collection.
            /*this.orderBy = ((this.orderBy) &&
                            (this.previousQuery !== this.options.query.attributes.where)) ? "" :
                           this.orderBy;*/
            // do not reset the page just because the order by changed. The order by now
            // in the url and the order by and the page needs to be restored
            //this.skipCount = (this.previousOrderBy !== this.orderBy) ? 0 : this.skipCount;
          }
          if (this.searchFacets &&
              (!this.searchFacets.filters || this.searchFacets.filters.length === 0)) {
            urlOptions.push("\'featured\'");
          }

          this.searchFacets && _.extend(queryData, this.getFilterParam(this.searchFacets.filters)); // returns an object with facets array
          _.extend(queryData, this._getBrowsableParams()); // returns object containing browsable_params
          _.extend(queryData, this.getStateEnablingUrlQuery()); // returns an object containing state
          _.extend(queryData, this.getResourceFieldsUrlQuery()); // returns an object containing fields array
          _.extend(queryData, this.getRequestedCommandsUrlQuery()); // returns an object containing actions array

          queryData.options = '{' + urlOptions.toString() + '}';
          queryData.expand = 'properties{original_id,owner_user_id,create_user_id,owner_id,reserved_user_id,parent_id,locked_user_id}';

          //support new placeholders
          queryData.lookfor = this.options.query.get('lookfor');
          queryData.modifier = this.options.query.get('modifier');
          
          // consider cache_id only while sorting and pagination.
          if ((!!this.orderBy || !!this.pagination) && !!this.cacheId) {
            queryData.cache_id = this.cacheId;
            this.pagination = false; // reset pagination to default.
          }
          _.extend(options, {
            type: 'POST',
            contentType: 'application/x-www-form-urlencoded',
            data: queryData,
            traditional: true
          });
         
          return originalSync.apply(this, arguments);
        },

        /**
         * This private method returns brows-able parameters after updating sorting values.
         * If the sort key contains asc_ as a prefix along with the current order state, then it
         * removes asc_ prefix
         *
         * @return browsable params object.
         */
        _getBrowsableParams: function () {
          var browsableParams = this.getBrowsableParams();
          if (browsableParams && browsableParams.sort &&
            (browsableParams.sort.search('asc_desc_') === 0 || browsableParams.sort.search('asc_asc_') === 0)) {
            browsableParams.sort = browsableParams.sort.replace('asc_', '');
          }
          return browsableParams;
        },

        parse: function (response, options) {
          //Filtered the response by obtaining only best bets, excluding others like nicknames,etc.,
          if (response.featured) {
            response.featured = _.filter(response.featured, function (item) {
              return !!item.bestbet || !!item.nickname;
            });
          }
          //Add region data to best bets
          this.addRegionsToPromotedList(response.featured);
          if (response.collection.searching) {
            var sortedColumns = new NodeColumn2Collection();
            var regionMetadata    = _.clone(response.collection.searching.regions_metadata),
                metadataOrder     = _.clone(_.uniq(response.collection.searching.regions_order)),
                columnDefinitions = [];
            _.each(regionMetadata, function (data, key) {
              var sequence = 500 + metadataOrder.indexOf(key);
              data.definitions_order = sequence;
              data.key = key;
              data.sortable = false;
              data.column_key = key;
              data.column_name = key;
              data.default_action = ["OTLocation", "OTName", "OTMIMEType"].indexOf(key) >= 0;
              data.default = ["OTLocation", "OTName", "OTMIMEType"].indexOf(key) >= 0;
              data.completeName = data.name;
              //Add a space behind colon(if exist) in column name as per UX
              data.titleAttr = data.name.replace(/:([^\s])/, ': $1');
              //When a category is added to search region, it will return column name in the format of CategoryName:AttributeName
              //This will remove the CategoryName which seperated by colon
              //CategoryName doesn't allow special charecteors, it is safe to remove string before first available colon
              data.name = data.name && data.name.replace(/^[^:]*:\s*/,'');
              columnDefinitions.push(data);
            });
            //push favorites and reserved
            columnDefinitions.push({
              "key": "favorite",
              "column_key": "favorite",
              "default": true
            });
            columnDefinitions.push({
              "key": "reserved",
              "column_key": "reserved",
              "default": true
            });
            // checking for items with version
            var metadata         = _.pluck(response.results, 'search_result_metadata'),
                nodesWithVersion = _.where(metadata, {current_version: false});
            //show version indicator for items having version_type as 'minor'
            nodesWithVersion = nodesWithVersion.length ? nodesWithVersion :
                               _.where(metadata, {version_type: 'minor'});
            if (nodesWithVersion && nodesWithVersion.length > 0) {
              columnDefinitions.push({
                "key": "version_id",
                "column_key": "version_id"
              });
            }
            sortedColumns.reset(columnDefinitions);
            response.collection.searching.sortedColumns = sortedColumns;
            _.each(response.results, function (model) {
              if (model.data.versions && model.search_result_metadata &&
                  (model.search_result_metadata.current_version === false ||
                   model.search_result_metadata.version_type === 'minor')) {
                model.data.versions.current_version = false;
              }
            });
          }
          var sorting = response.collection.sorting.links;
          for (var sort in sorting) {
            if (sort.search("asc_") === 0) {
              var sortColumn = this.trimSortOptionName(sorting[sort].name);
              sortColumn = sortColumn.trim();
              var column = response.collection.searching.sortedColumns.where({completeName: sortColumn});
              (column && column.length > 0) ? column[0].set('sort', true) : '';
            }
          }
          response.results = (response.featured && response.collection.sorting &&
                              response.collection.sorting.sort[0] === "relevance") ?
                             response.featured.concat(response.results) :
                             response.results;
          this.parseBrowsedState(response.collection, options);
          this.parseSearchResponse(response, options);
          if (options.fetchFacets) {
            //Parse facet search facets
            this._parseFacets(response.collection.searching.facets);
          }
          response.results.sorting = response.collection.sorting;
          this.cacheId = (!!response.collection && !!response.collection.searching &&
                          !!response.collection.searching.cache_id) ?
                         response.collection.searching.cache_id : "";
          return this.parseBrowsedItems(response, options);
        },

        trimSortOptionName: function (name) {
          return name.replace(/\(([;\s\w\"\=\,\:\.\/\~\{\}\?\!\-\%\&\#\$\^\(\)]*?)\)/g, "");
        },

        addRegionsToPromotedList: function (featuredList) {
          _.each(featuredList, function (featuredObject, key) {
            featuredObject.data.regions = {
              OTMIMEType: featuredObject.data.properties.mime_type,
              OTName: featuredObject.data.properties.name,
              OTLocation: featuredObject.data.properties.parent_id,
              OTObjectDate: featuredObject.data.properties.create_date,
              OTModifyDate: featuredObject.data.properties.modify_date,
              OTObjectSize: featuredObject.data.properties.size_formatted
            };
          });
        },

        _parseFacets: function (facets) {
          var topics;
          if (facets) {
            topics = convertFacets(facets.selected, true)
                .concat(convertFacets(facets.available, false));
          }
          this.searchFacets.reset(topics);
        }
      });
    }
  };

  function convertFacets(facets, selected) {
    return _.map(facets, function (facet) {
      var topics = _.map(facet.facet_items, function (topic) {
        return {
          name: topic.display_name,
          total: topic.count,
          value: topic.value,
          selected: selected
        };
      });
      return {
        id: facet.name,
        name: facet.display_name,
        type: facet.type,
        topics: topics,
        items_to_show: 5,
        select_multiple: true
      };
    });
  }

  return ServerAdaptorMixin;
});

csui.define('csui/models/widget/search.results/search.results.model',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/backbone',
  'csui/models/node/node.model', 'csui/models/mixins/connectable/connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin', 'csui/models/browsable/browsable.mixin',
  'csui/models/browsable/v1.request.mixin', 'csui/models/browsable/v2.response.mixin',
  'csui/models/mixins/state.requestor/state.requestor.mixin',
  'csui/models/mixins/v2.delayed.commandable/v2.delayed.commandable.mixin',
  'csui/models/mixins/v2.additional.resources/v2.additional.resources.mixin',
  'csui/models/mixins/v2.fields/v2.fields.mixin',
  'csui/models/mixins/v2.expandable/v2.expandable.mixin',
  'csui/models/widget/search.results/search.response.mixin',
  'csui/models/widget/search.results/server.adaptor.mixin',
  'csui/utils/contexts/perspective/plugins/node/node.extra.data',
  'csui/utils/contexts/perspective/plugins/node/utils/merge.extra.data',
  'i18n!csui/models/widget/nls/lang', 'csui/utils/deepClone/deepClone'
], function (_, $, Backbone, NodeModel, ConnectableMixin, FetchableMixin,
    BrowsableMixin, BrowsableV1RequestMixin, BrowsableV2ResponseMixin, StateRequestorMixin,
    DelayedCommandableV2Mixin, AdditionalResourcesV2Mixin, FieldsV2Mixin, ExpandableV2Mixin,
    SearchResponseMixin, ServerAdaptorMixin, nodeExtraData, mergeExtraData, lang) {
  'use strict';

  var SearchResultCollection = Backbone.Collection.extend({
    model: NodeModel,

    constructor: function SearchResultCollection(models, options) {
      // FIXME: Never store complete options on models. Avoid memory leaks.
      this.options = options || (options = {});
      Backbone.Collection.prototype.constructor.call(this, models, options);

      this.title = lang.searchResults;
      if (!options.fields) {
        options.fields = nodeExtraData.getModelFields();
      }
      if (!options.expand) {
        options.expand = mergeExtraData(
          nodeExtraData.getModelExpand(), {
            // TODO: Instead of hard-coding fixed attributes here, with no
            // connection to what the view actually displays, make the search
            // metadata collection to list the needed extra data, which decides
            // what attributes will be displayed.
            properties: [
              'reserved_user_id', 'original_id', 'owner_user_id',
              'create_user_id', 'owner_id', 'reserved_user_id', 'parent_id'
            ]
          }
        );
      }

      this.makeConnectable(options)
          .makeFetchable(options)
          .makeAdditionalResourcesV2Mixin(options)
          .makeBrowsable(options)
          .makeBrowsableV1Request(options)
          .makeFieldsV2(options)
          .makeExpandableV2(options)
          .makeBrowsableV2Response(options)
          .makeStateRequestor(options)
          .makeDelayedCommandableV2(options)
          .makeSearchResponse(options)
          .makeServerAdaptor(options);
    },

    clone: function () {
      return new this.constructor(this.models, {
        connector: this.connector,
        skip: this.skipCount,
        top: this.topCount,
        filter: _.deepClone(this.filters),
        orderBy: _.clone(this.orderBy),
        expand: _.clone(this.expand),
        includeActions: this.includeActions,
        commands: _.clone(this.commands),
        defaultActionCommands: _.clone(this.defaultActionCommands),
        delayRestCommands: this.delayRestCommands
      });
    },

    isFetchable: function () {
      return (!!this.options.query.get('where') || !!this.options.query.get('query_id'));
    },

    setDefaultPageNum: function () {
      this.skipCount = 0;
    },

    setPreviousOrder: function (attributes, fetch) {
      if (this.previousOrderBy != attributes) {
        this.previousOrderBy = attributes;
        if (fetch !== false) {
          this.fetch({skipSort: false});
        }
        return true;
      }
    },

    getResourceScope: function () {
      return _.deepClone({
        includeResources: this._additionalResources,
        commands: this.commands,
        defaultActionCommands: this.defaultActionCommands
      });
    },

    setResourceScope: function (scope) {
      this.excludeResources();
      scope.includeResources && this.includeResources(scope.includeResources);
      this.resetCommands();
      scope.commands && this.setCommands(scope.commands);
      this.resetDefaultActionCommands();
      scope.defaultActionCommands && this.setDefaultActionCommands(scope.defaultActionCommands);
    }
  });

  BrowsableMixin.mixin(SearchResultCollection.prototype);
  BrowsableV1RequestMixin.mixin(SearchResultCollection.prototype);
  BrowsableV2ResponseMixin.mixin(SearchResultCollection.prototype);
  FieldsV2Mixin.mixin(SearchResultCollection.prototype);
  ExpandableV2Mixin.mixin(SearchResultCollection.prototype);
  ConnectableMixin.mixin(SearchResultCollection.prototype);
  FetchableMixin.mixin(SearchResultCollection.prototype);
  StateRequestorMixin.mixin(SearchResultCollection.prototype);
  AdditionalResourcesV2Mixin.mixin(SearchResultCollection.prototype);
  SearchResponseMixin.mixin(SearchResultCollection.prototype);
  ServerAdaptorMixin.mixin(SearchResultCollection.prototype);
  DelayedCommandableV2Mixin.mixin(SearchResultCollection.prototype);

  return SearchResultCollection;
});

csui.define('csui/models/permission/permission.table.columns.model',['csui/lib/underscore', "csui/lib/backbone"
], function (_, Backbone, lang, extraTableColumns) {

  var TableColumnModel = Backbone.Model.extend({

    idAttribute: "key",

    defaults: {
      key: null,  // key from the resource definitions
      sequence: 0 // smaller number moves the column to the front
    }

  });

  return TableColumnModel;
});


/* START_TEMPLATE */
csui.define('hbs!csui/utils/commands/impl/full.page.modal/full.page.modal',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"binf-modal-dialog\">\r\n  <div class=\"binf-modal-content\">\r\n  </div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_utils_commands_impl_full.page.modal_full.page.modal', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/utils/commands/impl/full.page.modal/full.page.modal',[],function(){});
csui.define('csui/utils/commands/impl/full.page.modal/full.page.modal.view',['csui/lib/jquery', 'csui/lib/marionette',
  'csui/utils/non-emptying.region/non-emptying.region',
  'hbs!csui/utils/commands/impl/full.page.modal/full.page.modal',
  'css!csui/utils/commands/impl/full.page.modal/full.page.modal',
  'csui/lib/binf/js/binf'
], function ($, Marionette, NonEmptyingRegion, template) {
  'use strict';

  // Shows a view inside a modal overlay, which stretches over the entire body

  var FullPageModal = Marionette.LayoutView.extend({

    className: 'csui-full-page-modal binf-modal binf-fade',

    template: template,

    regions: {
      content: '.binf-modal-content',
    },

    events: {
      'shown.binf.modal': '_refresh',
      'hidden.binf.modal': 'destroy'
    },

    constructor: function FullPageModal(options) {
      Marionette.LayoutView.prototype.constructor.apply(this, arguments);
      this.view = this.options.view;
    },

    show: function () {
      var container = $.fn.binf_modal.getDefaultContainer(),
          region = new NonEmptyingRegion({el: container});
      region.show(this);
      return this;
    },

    onRender: function () {
      this.listenTo(this.view, 'destroy', function () {
        this.$el.binf_modal('hide');
      });
      this.content.show(this.options.view);
      // Make sure, that we show the top of the page, before
      // the scrollbars are suppressed; the dialog is absolutely
      // positioned on the top of the page
      $(window).scrollTop(0);
      this.$el.binf_modal({
        backdrop: 'static',
        keyboard: false
      });
    },

    _refresh: function () {
      this.view.triggerMethod('dom:refresh');
    }

  });

  return FullPageModal;

});

csui.define('csui/utils/thumbnail/server.adaptor.mixin',[
  'csui/lib/underscore', 'csui/utils/thumbnail/thumbnail.object', 'csui/utils/url'
], function (_, thumbnailObject, Url) {
  'use strict';

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makeServerAdaptor: function (options) {
          return this;
        },

        url: function () {
          var node         = this.options.node,
              nodeId       = node.get('id'),
              version      = node.get('version_number'), /*Assuming version number is available only
                with VersionModel*/
              versionParam = !!version ? '&version_number=' + version : '';

          return Url.combine(node.connector.connection.url, '/nodes', nodeId,
              '/thumbnails/medium/content?suppress_response_codes' + versionParam);
        },

        available: function () {
          //will refactor the code once rest api is ready
          var supportedTypes = [144, 145, 736, 749];
          return _.contains(supportedTypes, this.options.node.get("type"));
        },

        getPhotOptions: function (node) {
          node = (!!node) ? node : this.options.node;  
         var nodeId = node && node.get('id'),

            photoUrl = Url.combine(node.connector.connection.url, '/nodes',
              nodeId, '/content?action=open&suppress_response_codes');
          return {
            url: photoUrl,
            dataType: 'binary'
          };
        },

        getContentUrl: function (response) {
          return URL.createObjectURL(response);
        }

      });
    }
  };

  return ServerAdaptorMixin;
});

csui.define('csui/utils/thumbnail/thumbnail.object',['csui/lib/jquery', 'csui/lib/marionette',
  'csui/utils/url', 'csui/utils/base', 'csui/utils/thumbnail/server.adaptor.mixin'
], function ($, Marionette, Url, base, ServerAdaptorMixin) {
  'use strict';

  // Loads document thumbnail to a local object URL
  // * needs node model of the document
  // * has to be loaded to set the URL
  // * imgUrl property:
  //   - is undefined - not loaded yet
  //   - is null      - tried to load, but failed
  //   - is string    - loaded
  // * has to be destroyed when not need any more

  var Thumbnail = Marionette.Object.extend({

    constructor: function Thumbnail(options) {
      Marionette.Object.prototype.constructor.apply(this, arguments);
      this.node = this.options.node;
      this.listenTo(this.node, 'change:id', this.loadUrl)
          .listenTo(this, 'destroy', this.release);
      this.makeServerAdaptor(options);
    },

    // function is responsible for making a server call to fetch thumbnail
    loadUrl: function () {
      if(!this.node.get('csuiThumbnailImageUrl')) {
        var url = this.url();
        var self = this;
        this.release();
        return this.node.connector.makeAjaxCall({
              url: url,
              dataType: 'binary'
            }
        ).then(function (response) {
              self.load(response);
            }, function (jqxhr) {
              self._failureHandler(jqxhr);
            }
        );
      }
    },

    load: function (response) {
      var self = this;
      if (response.type && response.type.match(/application\/json/i)) {
        var reader = new window.FileReader();
        reader.readAsText(response);
        reader.onload = function (event) {
          var jsonObject = JSON.parse(event.target.result);
          if (jsonObject.statusCode === 404) {
            self._failureHandler(jsonObject.error);
          }
        };
      } else {
        self.imgUrl = URL.createObjectURL(response);

        // for compatibility reason don't trigger events on node when thumbnail URL is set
        // the loadUrl event is used for that
        self.options.node.set('csuiThumbnailImageUrl', self.imgUrl, {silent: true});
        self.triggerMethod('loadUrl', self, self.imgUrl);
      }
    },

    release: function () {
      if (this.imgUrl) {
        URL.revokeObjectURL(this.imgUrl);
        delete this.imgUrl;
        this.options.node.unset('csuiThumbnailImageUrl', {silent: true});
      }
    },

    _failureHandler: function (jqxhr) {
      var error = new base.Error(new Error(jqxhr));
      this.triggerMethod('error', this, error);
      return $.Deferred().reject(error).promise();
    }

  });

  ServerAdaptorMixin.mixin(Thumbnail.prototype);
  return Thumbnail;

});


/* START_TEMPLATE */
csui.define('hbs!csui/utils/thumbnail/loading.thumbnail',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<p>"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"loading") || (depth0 != null ? lookupProperty(depth0,"loading") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"loading","hash":{},"loc":{"start":{"line":1,"column":3},"end":{"line":1,"column":14}}}) : helper)))
    + "</p>\r\n";
}});
Handlebars.registerPartial('csui_utils_thumbnail_loading.thumbnail', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/utils/thumbnail/no.thumbnail',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<p>"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"notAvailable") || (depth0 != null ? lookupProperty(depth0,"notAvailable") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"notAvailable","hash":{},"loc":{"start":{"line":1,"column":3},"end":{"line":1,"column":19}}}) : helper)))
    + "</p>\r\n";
}});
Handlebars.registerPartial('csui_utils_thumbnail_no.thumbnail', t);
return t;
});
/* END_TEMPLATE */
;

/* START_TEMPLATE */
csui.define('hbs!csui/utils/thumbnail/thumbnail',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<img src=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"url") || (depth0 != null ? lookupProperty(depth0,"url") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"url","hash":{},"loc":{"start":{"line":1,"column":10},"end":{"line":1,"column":17}}}) : helper)))
    + "\" alt=\"\">\r\n";
}});
Handlebars.registerPartial('csui_utils_thumbnail_thumbnail', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/utils/thumbnail/thumbnail',[],function(){});
csui.define('csui/utils/thumbnail/thumbnail.view',['csui/lib/marionette',
  'csui/utils/thumbnail/thumbnail.object',
  'hbs!csui/utils/thumbnail/loading.thumbnail',
  'hbs!csui/utils/thumbnail/no.thumbnail',
  'hbs!csui/utils/thumbnail/thumbnail',
  'i18n!csui/utils/impl/nls/lang',
  'css!csui/utils/thumbnail/thumbnail'
], function (Marionette, Thumbnail,
    loadingThumbnail, noThumbnail, thumbnail, lang) {
  'use strict';

  // Make it public:
  // * move to controls
  // * implement final versions of "loading" and "no" templates
  // * localize

  // Shows document thumbnail
  // * either accepts thumbnail object in options
  // * or creates its own thumbnail object using node model from options
  // * width and height should be set for the parent container,
  //   which would be proportionally filled up to 100%
  // * or the root element should be sized rxplicitly

  var ThumbnailView = Marionette.ItemView.extend({

    className: 'csui-thumbnail',

    getTemplate: function () {
      var imgUrl = this.thumbnail.imgUrl;
      return imgUrl === undefined ? loadingThumbnail({loading: lang.Loading}) :
             imgUrl ? thumbnail : noThumbnail({notAvailable: lang.NotAvailable});
    },

    constructor: function ThumbnailView(options) {
      Marionette.ItemView.prototype.constructor.apply(this, arguments);
      this.thumbnail = this.options.thumbnail || new Thumbnail({
        node: this.options.node
      });
      this.listenTo(this.thumbnail, 'loadUrl', this.render);
      this.listenTo(this.thumbnail, 'error', this.render);
      this.listenTo(this, 'render', function () {
        this.thumbnail.imgUrl === undefined && this.thumbnail.loadUrl();
      });
      this.listenTo(this, 'destroy', function () {
        this.thumbnail.destroy();
      });
    },

    serializeData: function () {
      return {
        imgUrl: this.thumbnail.imgUrl
      };
    }

  });

  return ThumbnailView;

});


/* START_TEMPLATE */
csui.define('hbs!csui/utils/expiration.warning/impl/expiration.warning',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <div class=\"div-inline csui-expiration-warning-dialog-text\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"warningText") || (depth0 != null ? lookupProperty(depth0,"warningText") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"warningText","hash":{},"loc":{"start":{"line":2,"column":62},"end":{"line":2,"column":77}}}) : helper)))
    + "</div><BR>\r\n  <div class=\"div-inline csui-expiration-warning-dialog-timevalue\">\r\n    <span class=\"csui-time-value-min\"></span>:<span class=\"csui-time-value-sec\"></span>\r\n  </div>\r\n\r\n  <p id=\"csui-expiration-timer-live\" aria-live=\"assertive\" aria-atomic=\"true\"></p>  \r\n";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <div class=\"div-inline csui-expiration-warning-dialog-text\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"warningText") || (depth0 != null ? lookupProperty(depth0,"warningText") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"warningText","hash":{},"loc":{"start":{"line":9,"column":62},"end":{"line":9,"column":77}}}) : helper)))
    + "</div>  \r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isExpirationWarningContent") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"loc":{"start":{"line":1,"column":0},"end":{"line":10,"column":7}}})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_utils_expiration.warning_impl_expiration.warning', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/utils/expiration.warning/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/utils/expiration.warning/impl/nls/root/lang',{

  dialogExpirationWarningTitle: 'Session timeout warning',

  dialogExpirationWarningText: 'Your session will expire automatically in',

  dialogExpirationWarningButtonContinueSession: 'Continue session',
  dialogExpirationWarningButtonContinueSessionTooltip: 'Refresh session and continue work',
  dialogExpirationWarningButtonContinueSessionAria: 'Refresh session and continue work',

  dialogExpirationWarningButtonTerminateSession: 'End session now',
  dialogExpirationWarningButtonTerminateSessionTooltip: 'Trigger logout now',
  dialogExpirationWarningButtonTerminateSessionAria: 'Trigger logout now',

  dialogExpirationWarningLoggedOutText: 'Performing sign out...',

  dialogExpirationWarningButtonLeave: 'Close',
  dialogExpirationWarningButtonLeaveTooltip: 'Close the dialog and redirect to target page',
  dialogExpirationWarningButtonLeaveAria: 'Close the dialog and redirect to target page',

  dialogExpirationWarningAriaTime: 'The session expires in {{overallSeconds}} seconds',
  dialogExpirationWarningAriaSessionExpired: 'The session has expired'

});


csui.define('csui/utils/expiration.warning/impl/minutes.view',[
    'module',
    'csui/lib/underscore', 'csui/lib/marionette',
    'csui/utils/log',
    'csui/lib/handlebars'
  ], function (module, _, Marionette,
            log, Handlebars) {
    'use strict';
    log = log(module.id);    

    // helper views to render time values every second
    var TimeValueMinutesView = Marionette.ItemView.extend({
      className: 'csui-time-value-min-value',

      tagName: 'span',

      modelEvents: {
        "change": "render"
      },

      template: Handlebars.compile('{{timeValueMinutes}}'),

      templateHelpers: function() {
        return { timeValueMinutes: this.model.get('minutes') };
      },

      constructor: function TimeValueMinutesView(options) {
        options || (options = {});
        Marionette.ItemView.prototype.constructor.call(this, options);
      },

    });

    return TimeValueMinutesView;
});

csui.define('csui/utils/expiration.warning/impl/seconds.view',[
    'module',
    'csui/lib/underscore', 'csui/lib/marionette',
    'csui/utils/log',
    'csui/lib/handlebars'
  ], function (module, _, Marionette,
            log, Handlebars) {
    'use strict';
    log = log(module.id);

    // helper views to render time values every second
    var TimeValueSecondsView = Marionette.ItemView.extend({
        className: 'csui-time-value-sec-value',

        tagName: 'span',

        modelEvents: {
          "change": "render"
        },  
      
        template: Handlebars.compile('{{timeValueSeconds}}'),
  
        templateHelpers: function() {
          return { timeValueSeconds: this.model.get('seconds') };
        },

        constructor: function TimeValueSecondsView(options) {
          options || (options = {});
  
          Marionette.ItemView.prototype.constructor.call(this, options);
        },

      });

    return TimeValueSecondsView;
});


csui.define('css!csui/utils/expiration.warning/impl/expiration.warning',[],function(){});
csui.define('csui/utils/expiration.warning/impl/expiration.warning.view',[
    'module',
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette', 
    'csui/lib/backbone',
    'csui/utils/base',    
    'hbs!csui/utils/expiration.warning/impl/expiration.warning',
    'i18n!csui/utils/expiration.warning/impl/nls/lang',
    'csui/utils/log',    
    'csui/utils/expiration.warning/impl/minutes.view',
    'csui/utils/expiration.warning/impl/seconds.view',
    'csui/lib/handlebars',
    'css!csui/utils/expiration.warning/impl/expiration.warning'
  ], function (module, _, $, Marionette, Backbone, base, 
            template, lang, log, 
            MinutesView, SecondsView, Handlebars
            ) {
    'use strict';
    log = log(module.id);

    var TimevalueModel = Backbone.Model.extend({
      defaults: {
        initTime: Date.now(),
        timer: -1,
        minutes: 0,
        seconds: 0
      }
    });


    var ExpirationWarningView = Marionette.LayoutView.extend({
      className: 'csui-expiration-warning',
  
      template: template,
      templateHelpers: function () {
        // countdown content
        return {
          isExpirationWarningContent: true,
          warningText: lang.dialogExpirationWarningText,
          msgId: _.uniqueId('msg')
        };
      },

      regions: {
        timeValueMinRegion: 'span.csui-time-value-min',
        timeValueSecRegion: 'span.csui-time-value-sec'
      },
    
      constructor: function ExpirationWarningView(options) {
        options || (options = {});
        this.authenticator = options.authenticator;
        this.shouldDisplayExpirationWarning = options.shouldDisplayExpirationWarning;
        this.UserSession = options.userSession;
        this.startTime = options.startTime;
        this.timerId = undefined;
        this.isFinished = false;
        this.timeAriaTemplate = Handlebars.compile(lang.dialogExpirationWarningAriaTime);

        options.model = this._createModel();

        Marionette.LayoutView.prototype.constructor.call(this, options);
  
        // IE11 fails to update CSS center styling correctly on window resize
        if (base.isIE11()) {
          var self = this;
          var resizeHandler = function () {
            self.render();
          };
          $(window).on('resize', resizeHandler);
          this.once('before:destroy', function () {
            $(window).off('resize', resizeHandler);
          });
        }

        this._createTimer();
      },

      _createModel: function() {
        var timeVal = this._getReactionDuration();
        var convertedTime = this._getMinutesSeconds(timeVal);
        // model for managing time value
        var TimeModel = new TimevalueModel({ timer: timeVal, 
                                             minutes: convertedTime.minutes, 
                                             seconds: convertedTime.seconds
                                           });
        return TimeModel;
      },

      // The screenreader wants only the text changed, but not the whole paragraph or div re-rendered.
      // So change only the aria-label and you have to ensure that the parent is not re-rendered when time-value changes.
      _updateAriaTimeLabel: function(timeInSec) {
        var timeAriaLabel;
        if (timeInSec <= 0) {
          // update aria-live label with session expired
          timeAriaLabel = lang.dialogExpirationWarningAriaSessionExpired;
          document.getElementById('csui-expiration-timer-live').setAttribute('aria-label', timeAriaLabel);
        } else {
          // update aria-live label e.g. all 10 seconds
          if ((timeInSec % 10) == 0) {
            timeAriaLabel = this.timeAriaTemplate({overallSeconds: timeInSec});
            document.getElementById('csui-expiration-timer-live').setAttribute('aria-label', timeAriaLabel);
          }
        }        
      },

      _createTimer: function() {
        var timeVal = this.model.get('timer');
        var self = this;
        self.model.set({initTime: Date.now()}, {silent: true}); // do not trigger change
        var expectedEndTime = self.model.get('initTime') + (timeVal * 1000);
        this.isFinished = false;          

        log.info("expiration.warning.view: _createTimer: used sessionReactionTime: " + self._getReactionDuration() + " (Date: " + self.UserSession.currentDateUTC() + ")." ) && console.log(log.last);
        
        this.timerId = setInterval(function() {
          var currTimer = self.model.get('timer');
          if (--currTimer < 0) {
            currTimer = 0;

            // session expired
            self._clearWarningTimer();
            log.info("expiration.warning.view: _createTimer: Expiration warning timeout expired, session timed out (Date: " + self.UserSession.currentDateUTC() + ")." ) && console.log(log.last);
            // Do nothing here. As long as we have no logout call which returns JSON-result,
            // does not perform any redirects and returns JSON-result we do nothing.
            
            // update aria-live label with session expired
            self._updateAriaTimeLabel(currTimer);

            // show loggedOut dialog
            self.UserSession.performSessionExpired(self.authenticator, false);
            self.isFinished = true;
          }

          if (!self.isFinished) {
            var nowTime = Date.now();
            var timeDiff = (expectedEndTime - nowTime + 500) / 1000;
            if ( timeDiff < currTimer) {
              if (timeDiff > 0) {
                log.info("expiration.warning.view: _createTimer: Adjusting timer value to actual time, using: " + timeDiff + "(currentTimer was: " + currTimer + ")") && console.log(log.last);
                currTimer = timeDiff;
              }
            }
            log.debug("expiration.warning.view: _createTimer: Setting timer in model to " + currTimer) && console.log(log.last);
            var convertedTime = self._getMinutesSeconds(currTimer);            
            self.model.set({ timer: currTimer,
                             minutes: convertedTime.minutes,
                             seconds: convertedTime.seconds 
                           });

            // update aria-live label
            self._updateAriaTimeLabel(currTimer);            

            log.debug("expiration.warning.view: _createTimer: Expected end time in ms: " + expectedEndTime + " (current: " + nowTime + ", diff: " + (expectedEndTime - nowTime) + ")") && console.log(log.last);
          }

        }, 1000);
      },

      // this is called by event 'clear:timer'
      onClearTimer: function() {
        log.debug("expiration.warning.view: onClearTimer: clearing view timer...") && console.log(log.last);
        this._clearWarningTimer();
      },

      onBeforeDestroy: function() {
        this._clearWarningTimer();
      },

      _clearWarningTimer: function() {
        if ( this.timerId ) {
          clearInterval(this.timerId);
          this.timerId = undefined;
        }
      },

      _getReactionDuration: function() {
        // We start with one seconds less than the configured
        // time e.g. 01 min 59 sec and include 00 sec.
        var reactTime = this.startTime !== undefined ? this.startTime : this.UserSession.getSessionReactionTime()/1000 - 1;
        if (reactTime < 0 ) {
          reactTime = 0;
        }
        return reactTime;
      },

      _getMinutesSeconds: function(timeSecs) {
        var minutes, seconds;
        minutes = parseInt(timeSecs / 60, 10);
        seconds = parseInt(timeSecs % 60, 10);

        minutes = minutes < 10 ? "0" + minutes : minutes; // add leading 0
        seconds = seconds < 10 ? "0" + seconds : seconds; // add leading 0

        return { 
          minutes: minutes,
          seconds: seconds
        };
      },
      
      onRender: function() {        
        if ( this.shouldDisplayExpirationWarning && !this.isFinished && this.isRendered) {
          // log.debug("expiration.warning.view: onRender: rendering views ...") && console.log(log.last);
          var minutesView = new MinutesView({ model: this.model });
          var secondsView = new SecondsView({ model: this.model });
          this.showChildView('timeValueMinRegion', minutesView);
          this.showChildView('timeValueSecRegion', secondsView);
        }
      },
  
      onKeyInView: function (event) {
        if (event.keyCode === 32 || event.keyCode === 13) {
          // space(32) or enter(13)
          event.preventDefault();
          event.stopPropagation();
          $(event.target).trigger('click');
        }
      }
  
    });
  
    return ExpirationWarningView;
  });
  
csui.define('csui/utils/expiration.warning/expiration.warning.dialog',[
    'module',
    'csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
    'csui/utils/expiration.warning/impl/expiration.warning.view',
    'csui/dialogs/modal.alert/modal.alert',
    'i18n!csui/utils/expiration.warning/impl/nls/lang',
    'csui/utils/log',
    'css!csui/utils/expiration.warning/impl/expiration.warning',
  ], function (module, _, $, Marionette,
            ExpirationWarningView, ModalAlertView,
            lang, log) {
    'use strict';
    log = log(module.id);

    var dialogSize = 'md',
      dlgOptions;

    // returns array of buttons data objects
    function _getButtonsData(isExpWarning) {
      var buttonArr = [];
      if ( isExpWarning === true ) {

        // continue session button
        buttonArr.push({
          showYes: true,
          labelYes: lang.dialogExpirationWarningButtonContinueSession,
          tooltipYes: lang.dialogExpirationWarningButtonContinueSessionTooltip,
          ariaYes: lang.dialogExpirationWarningButtonContinueSessionAria,
          clickYes: function(dialog) {
            var cloptions = _.extend({ dialogOptions: dlgOptions }, { dialog: dialog });

            if (cloptions.dialogOptions.authenticator.isAuthenticated() === true) {
              // stop the background timer as early as possible since you may get logged out 
              // before the ajax call has finished (e.g. press continue button at 1 sec)
              cloptions.dialogOptions.cbClearExpirationTimer();
            }
            // disable button to avoid multiple invocations;
            // disable other button to prevent conflicting actions
            if ( cloptions.dialog && !cloptions.dialog.isDestroyed ) {
              cloptions.dialog.updateButtons({ disableYes: true, disableNo: true });
            }
            log.info("expiration.warning.dialog: User continued session, performing REST-call (Date: " + cloptions.dialogOptions.userSession.currentDateUTC() + ").") && console.log(log.last);
            cloptions.dialogOptions.userSession.continueSession(cloptions.dialogOptions.authenticator);
          }          
        });

        // this button ends the session by performing logout
        buttonArr.push({
          showNo: true,
          labelNo: lang.dialogExpirationWarningButtonTerminateSession,
          tooltipNo: lang.dialogExpirationWarningButtonTerminateSessionTooltip,
          ariaNo: lang.dialogExpirationWarningButtonTerminateSessionAria,
          clickNo: function(dialog) {
            var cloptions = _.extend({ dialogOptions: dlgOptions }, { dialog: dialog });
            cloptions.dialogOptions.cbClearExpirationTimer();
            // disable button to avoid multiple invocations;
            // disable other button to prevent conflicting actions
            if ( cloptions.dialog && !cloptions.dialog.isDestroyed ) {
              cloptions.dialog.updateButtons({ disableNo: true, disableYes: true});
            }
            log.info("expiration.warning.dialog: User terminated session, performing signOut (Date: " + cloptions.dialogOptions.userSession.currentDateUTC() + ").") && console.log(log.last);
            cloptions.dialogOptions.userSession.signOut(cloptions.dialogOptions.authenticator);            
            // keep dialog on page to hide content
          }
        });
      } else {
        // this button just redirects to target page
        buttonArr.push({
          showYes: true,
          labelYes: lang.dialogExpirationWarningButtonLeave,
          tooltipYes: lang.dialogExpirationWarningButtonLeaveTooltip,
          ariaYes: lang.dialogExpirationWarningButtonLeaveAria,
          clickYes: function(dialog) {
            var cloptions = _.extend({ dialogOptions: dlgOptions }, { dialog: dialog });
            cloptions.dialogOptions.cbClearExpirationTimer();
            // disable button to avoid multiple invocations
            if ( cloptions.dialog && !cloptions.dialog.isDestroyed ) {
              cloptions.dialog.updateButtons({disableYes: true});
            }
            log.info("expiration.warning.dialog: Redirecting to target page...'") && console.log(log.last);
            cloptions.dialogOptions.userSession.redirectToTargetPage(cloptions.dialogOptions.authenticator);
            // keep dialog on page to hide content
          }
        });

      }

      // compose single buttons object accepted by modal.alert
      var i, 
          bLen = buttonArr.length,
          combined = { showYes: false, showNo: false, showCancel: false};
      for (i = 0; i < bLen; i++) {
        combined = _.extend(combined, buttonArr[i]);
      }

      return combined;
    }

    function createExpirationWarningDialog(options) {
      options || (options = {});

      this.UserSession = options.userSession;   // avoid cyclic dependendy and let pass-in the UserSession
      this.authenticator = options.authenticator;
      if ( !this.authenticator ) {
        log.error("expiration.warning.dialog: showExpirationWarningDialog: Given authenticator is 'undefined'!") && console.error(log.last);
      }
      this.shouldDisplayExpirationWarning = (options.startWithWarningContent && options.startWithWarningContent === true) ? true : false;
      this.cbClearExpirationTimer = options.clearExpirationTimer;  // callback function to clear timer on demand
      this.startTime = options.startTime;
      
      this.buttonsData = _getButtonsData(this.shouldDisplayExpirationWarning);      

      dlgOptions = {
        userSession: this.UserSession,
        authenticator: this.authenticator,
        shouldDisplayExpirationWarning: this.shouldDisplayExpirationWarning,
        startTime: this.startTime,
        cbClearExpirationTimer: this.cbClearExpirationTimer,
        buttonsData: this.buttonsData
      };

      var dlg = _createExpiration(dlgOptions);

      return dlg;
    }

    function showExpirationWarningDialog(dialog) {
      var self = this;
      var deferred = $.Deferred();

      dialog.show()
      .then(
        function success(result) {
          self.buttonsData.clickYes(dialog);
          deferred.resolve(result);
        }, 
        function failure(result) {
          self.buttonsData.clickNo(dialog);
          /* if (result === false) {
            self.buttonsData.clickNo(dialog);
          } else {
            // undefined
            self.buttonsData.clickCancel(dialog);
          } */
          deferred.reject(result);
        }
      );
      return deferred.promise();
    }

    function _createExpiration(options) {

      var expDlg = new ModalAlertView(_.defaults({
          dialogSize: dialogSize
      }, {
          // message: "Hello this is a test with some text.\nThis is a second line.",
          bodyView: ExpirationWarningView,
          bodyViewOptions: {
              userSession: options.userSession,
              authenticator: options.authenticator,
              startTime: options.startTime,
              shouldDisplayExpirationWarning: options.shouldDisplayExpirationWarning 
          },
          title: lang.dialogExpirationWarningTitle,
          showTitleCloseButton: false,
          staticBackdrop: true,
          closeWithEsc: false,
          buttons: options.buttonsData
        },
        ModalAlertView.defaultOptions.Warning ));

      return expDlg;
  }

  return {
    createExpirationWarningDialog: createExpirationWarningDialog,
    showExpirationWarningDialog: showExpirationWarningDialog
  };

});

csui.define('json!csui/utils/commands/open.types.json',{
  "mimeTypesForOpen": [
    "application/atom+xml",
    "application/font-woff",
    "application/javascript",
    "application/json",
    "application/mathml+xml",
    "application/ogg",
    "application/pdf",
    "application/postscript",
    "application/rdf+xml",
    "application/rss+xml",
    "application/vnd.mozilla.xul+xml",
    "application/xhtml+xml",
    "application/xml",
    "application/x-shockwave-flash",
    "audio/3gpp",
    "audio/3gpp2",
    "audio/aac",
    "audio/aiff",
    "audio/amr",
    "audio/basic",
    "audio/flac",
    "audio/midi",
    "audio/mp3",
    "audio/mp4",
    "audio/mpeg",
    "audio/mpeg3",
    "audio/ogg",
    "audio/vorbis",
    "audio/wav",
    "audio/webm",
    "audio/x-m4a",
    "audio/x-ms-wma",
    "audio/x-wav",
    "audio/vnd.rn-realaudio",
    "audio/vnd.wave",
    "image/bmp",
    "image/cis-cod",
    "image/gif",
    "image/ief",
    "image/jpeg",
    "image/webp",
    "image/pict",
    "image/pipeg",
    "image/png",
    "image/svg+xml",
    "image/tiff",
    "image/vnd.microsoft.icon",
    "image/webp",
    "image/x-cmu-raster",
    "image/x-cmx",
    "image/x-icon",
    "image/x-portable-anymap",
    "image/x-portable-bitmap",
    "image/x-portable-graymap",
    "image/x-portable-pixmap",
    "image/x-rgb",
    "image/x-xbitmap",
    "image/x-xpixmap",
    "image/x-xwindowdump",
    "message/rfc822",
    "multipart/related",
    "multipart/x-mixed-replace",
    "text/css",
    "text/html",
    "text/plain",
    "text/xml",
    "video/3gpp",
    "video/3gpp2",
    "video/avi",
    "video/divx",
    "video/flc",
    "video/mp4",
    "video/mpeg",
    "video/ogg",
    "video/quicktime",
    "video/sd-video",
    "video/webm",
    "video/x-dv",
    "video/x-m4v",
    "video/x-mpeg",
    "video/x-ms-asf",
    "video/x-ms-wmv",
    "video/x-msvideo"
  ],
  "officeMimeTypes": [
    "application/msword",
    "application/vnd.ms-word",
    "application/vnd.msword",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.wordprocessing-openxml",
    "application/vnd.ces-quickword",
    "application/vnd.ms-word.document.macroEnabled.12",
    "application/vnd.ms-word.document.12",
    "application/mspowerpoint",
    "application/vnd.ms-powerpoint",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.ces-quickpoint",
    "application/vnd.presentation-openxml",
    "application/vnd.presentation-openxmlm",
    "application/vnd.ms-powerpoint.presentation.macroEnabled.12",
    "application/msexcel",
    "application/vnd.ms-excel",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.ces-quicksheet",
    "application/vnd.spreadsheet-openxml",
    "application/vnd.ms-excel.sheet.macroEnabled.12",
    "text/csv"
  ]
}
);

csui.define('csui/utils/commands/open.plugins/impl/csv.plugin',[
  'csui/lib/underscore', 'csui/lib/jquery', 'csui/models/version'
], function (_, $, VersionModel) {
  'use strict';

  var config = window.csui.requirejs.s.contexts._.config
                   .config['csui/utils/commands/open'] || {};

  config = _.extend({
    CSViewerIsAvailable: false,
    CSViewerSupportedMimeTypes: [],
    csViewerView: 'csv/widgets/csviewer/csviewer.view'
  }, config);

  config.CSViewerSupportedMimeTypes = _.invoke(
      config.CSViewerSupportedMimeTypes, 'toLowerCase');

  function ContentSuiteViewerPlugin() {
  }

  ContentSuiteViewerPlugin.prototype.widgetView = config.csViewerView;

  ContentSuiteViewerPlugin.prototype.getUrlQuery = function (node) {
    var query = {
      func: 'doc.ViewDoc',
      nodeid: node.get('id')
    };
    if (node instanceof VersionModel) {
      query.vernum = node.get('version_number');
    }
    return $.Deferred()
            .resolve(query)
            .promise();
  };

  ContentSuiteViewerPlugin.prototype.needsAuthentication = function (node) {
    return true;
  };

  ContentSuiteViewerPlugin.isSupported = function (node) {
    var mimeType = node.get('mime_type');
    return mimeType && config.CSViewerIsAvailable &&
           config.CSViewerSupportedMimeTypes.indexOf(mimeType.toLowerCase()) >= 0;
  };

  return ContentSuiteViewerPlugin;
});

csui.define('csui/utils/commands/open.plugins/impl/browser.plugin',[
  'csui/lib/underscore', 'csui/lib/jquery',
  'csui/utils/base',
  'json!csui/utils/commands/open.types.json', 'csui/utils/content.helper'
], function (_, $, base, openMimeTypes,
    contentHelper) {
  'use strict';

  var config = window.csui.requirejs.s.contexts._.config
                   .config['csui/utils/commands/open'] || {},
      mimeTypesFromPlugins = _.chain(navigator.plugins || [])
                              .map(function (plugin) {
                                return _.chain(plugin)
                                        .map(function (mimeType) {
                                          return mimeType.type;
                                        })
                                        .value();
                              })
                              .flatten()
                              .compact()
                              .invoke('toLowerCase')
                              .value();

  config = _.extend({
    // from https://code.google.com/p/chromium/codesearch#chromium/src/net/base/mime_util.cc
    // and https://tools.ietf.org/html/rfc3023
    // and https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types
    mimeTypesForOpen: openMimeTypes.mimeTypesForOpen,

    // from chrome-extension://gbkeegbaiigmenfmjfclcdgdpimamgkj/manifest.json
    officeMimeTypes: openMimeTypes.officeMimeTypes,

    // Opening HTML and XML documents can be considered a security risk.
    forceDownloadForMimeTypes: [],

    // If overridden, true will always download the document instead of letting
    // the browser open it natively.
    forceDownloadForAll: false

  }, config);

  config.mimeTypesForOpen = _.invoke(config.mimeTypesForOpen, 'toLowerCase');
  config.officeMimeTypes = _.invoke(config.officeMimeTypes, 'toLowerCase');
  config.forceDownloadForMimeTypes = _.invoke(
      config.forceDownloadForMimeTypes, 'toLowerCase');

  // Extend the openable MIME types by plugins installed in the browser
  config.mimeTypesForOpen = _.chain(config.mimeTypesForOpen)
                             .concat(mimeTypesFromPlugins)
                             .unique()
                             .invoke('toLowerCase')
                             .value();

  function BrowserPlugin() {
  }

  BrowserPlugin.prototype.getUrl = function (node) {
    return getPageUrl(node);
  };

  BrowserPlugin.isSupported = function (node) {
    var mimeType = node.get('mime_type');
    if (mimeType) {
      mimeType = mimeType.toLowerCase();
      // Downloading does not work on iOS; only opening does.
      return base.isAppleMobile() ||
      // Only MIME types handled by the browser or plugins can be opened.
             config.mimeTypesForOpen.indexOf(mimeType) >= 0 &&
      // Do not open MIME types blocked by the configuration.
             config.forceDownloadForMimeTypes.indexOf(mimeType) < 0 &&
      // Do not open anything, if opening is blocked by the configuration.
             !config.forceDownloadForAll;
    }
  };

  BrowserPlugin.prototype.needsAuthentication = function (node) {
    return true;
  };

  function getPageUrl(node) {
    var download;
    var mimeType = (node.get('mime_type') || '').toLowerCase();
    if (!base.isAppleMobile() 
        && config.officeMimeTypes.indexOf(mimeType) >= 0) {
        download = true;
    }
    var contentUrl = contentHelper.getContentPageUrl(node, { download: !!download });
    return $.Deferred().resolve(contentUrl).promise();
  }

    return BrowserPlugin;
});

csui.define('csui/utils/commands/open.plugins/impl/core.open.plugins',[
  'csui/utils/commands/open.plugins/impl/brava.plugin',
  'csui/utils/commands/open.plugins/impl/csv.plugin',
  'csui/utils/commands/open.plugins/impl/browser.plugin'
], function (BravaPlugin, CSViewerPlugin, BrowserPlugin) {
  'use strict';

  return [
    {
      sequence: 200,
      plugin: BravaPlugin,
      decides: BravaPlugin.isSupported
    },
    {
      sequence: 400,
      plugin: CSViewerPlugin,
      decides: CSViewerPlugin.isSupported
    },
    {
      sequence: 600,
      plugin: BrowserPlugin,
      decides: BrowserPlugin.isSupported
    }
  ];
});

csui.define('csui/utils/contexts/factories/search.results.factory',['require', 'module', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/contexts/factories/factory', 'csui/utils/contexts/factories/connector',
  'csui/utils/contexts/factories/search.query.factory',
  'csui/models/widget/search.results/search.results.model',
  'csui/utils/commands',
  'csui/utils/base'
], function (require, module, _, Backbone, CollectionFactory, ConnectorFactory,
    SearchQueryModelFactory, SearchResultCollection, commands, base) {

  var SearchResultCollectionFactory = CollectionFactory.extend({

    propertyPrefix: 'searchResults',

    constructor: function SearchResultCollectionFactory(context, options) {
      CollectionFactory.prototype.constructor.apply(this, arguments);

      var searchResults = this.options.searchResults || {};
      if (!(searchResults instanceof Backbone.Collection)) {
        var connector = context.getObject(ConnectorFactory, options),
            query     = options.searchResults.query,
            config    = module.config();
        searchResults = new SearchResultCollection(searchResults.models, _.extend({
          connector: connector,
          query: query,
          // Make sure, that the metadata token is returned for nodes
          // requesated via this factory, because they are supposed to
          // be shared and may be the subject of changes.
          stateEnabled: true,
          // Ask the server to check for permitted actions V2
          commands: commands.getAllSignatures()
        }, searchResults.options, config.options, {
          autofetch: true,
          autoreset: true
        }));
      }
      this.property = searchResults;
    },

    isFetchable: function () {
      return this.property.isFetchable();
    },

    fetch: function (options) {
      !this.property.fetched && this.property.fetch({
        success: _.bind(this._onSearchResultsFetched, this, options),
        error: _.bind(this._onSearchResultsFailed, this, options)
      });
    },

    _onSearchResultsFetched: function (options) {
      //nothing to-do for now upon success.
      return true;
    },

    _onSearchResultsFailed: function (model, request, message) {
      var error = new base.RequestErrorMessage(message);
      csui.require(['csui/dialogs/modal.alert/modal.alert'], function (ModalAlert) {
        ModalAlert.showError(error.toString());
      });
    }

  }, {

    getDefaultResourceScope: function () {
      return _.deepClone({
        commands: commands.getAllSignatures()
      });
    }

  });

  return SearchResultCollectionFactory;

});


/* START_TEMPLATE */
csui.define('hbs!csui/controls/signin/impl/signin',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"login-container\">\r\n  <div class=\"login-controls\">\r\n    <div class=\"branding\"><span role=\"presentation\" class=\"ot-logo\">&nbsp;</span></div>\r\n    <div class=\"login-error\" id=\"loginError\"></div>\r\n    <div class=\"login-form-wrapper\">\r\n      <form>\r\n        <div class=\"binf-form-group binf-has-feedback\">\r\n          <div class=\"col-md-20\">\r\n            <input id=\"inputUsername\" type=\"text\" class=\"binf-form-control binf-input-lg textbox hasclear\"\r\n                   placeholder=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"placeholderusername") || (depth0 != null ? lookupProperty(depth0,"placeholderusername") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"placeholderusername","hash":{},"loc":{"start":{"line":10,"column":32},"end":{"line":10,"column":55}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"userNameAria") || (depth0 != null ? lookupProperty(depth0,"userNameAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"userNameAria","hash":{},"loc":{"start":{"line":10,"column":69},"end":{"line":10,"column":85}}}) : helper)))
    + "\">\r\n              <span id=\"usernameclearer\" class=\"clearer clear-icon binf-form-control-feedback\"></span>\r\n\r\n          </div>\r\n        </div>\r\n        <div class=\"binf-form-group binf-has-feedback\">\r\n          <div class=\"col-md-20\">\r\n            <input id=\"inputPassword\" type=\"password\"\r\n                   class=\"binf-form-control binf-input-lg textbox hasclear\"\r\n                   placeholder=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"placeholderpassword") || (depth0 != null ? lookupProperty(depth0,"placeholderpassword") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"placeholderpassword","hash":{},"loc":{"start":{"line":19,"column":32},"end":{"line":19,"column":55}}}) : helper)))
    + "\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"passwordAria") || (depth0 != null ? lookupProperty(depth0,"passwordAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"passwordAria","hash":{},"loc":{"start":{"line":19,"column":69},"end":{"line":19,"column":85}}}) : helper)))
    + "\">\r\n              <span id=\"passwordclearer\" class=\"clearer clear-icon binf-form-control-feedback\"></span>\r\n          </div>\r\n        </div>\r\n        <button id=\"buttonSubmit\" type=\"button\" class=\"login-btn\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"buttontext") || (depth0 != null ? lookupProperty(depth0,"buttontext") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"buttontext","hash":{},"loc":{"start":{"line":23,"column":66},"end":{"line":23,"column":80}}}) : helper)))
    + "</button>\r\n      </form>\r\n    </div>\r\n  </div>\r\n</div>\r\n";
}});
Handlebars.registerPartial('csui_controls_signin_impl_signin', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/controls/signin/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/controls/signin/impl/nls/root/localized.strings',{
  signinButtonText: "Sign in",
  signinForgotPassword: "Forgot password?",
  signinPlaceholderUsername: "User name",
  usernameAria: 'Enter user name',
  signinPlaceholderPassword: "Password",
  passwordAria: 'Enter password',
  signinInvalidUsernameOrPassword: "You have entered an invalid user name or password. Please try again."
});



csui.define('css!csui/controls/signin/impl/css/signin',[],function(){});
csui.define('csui/controls/signin/signin.view',[
  'module', 'csui/lib/underscore', 'csui/lib/jquery',
  'csui/utils/authenticators/basic.authenticator',
  'csui/utils/authenticators/credentials.authenticator',
  'csui/utils/contexts/page/page.context',
  'csui/utils/connector', 'csui/utils/contexts/factories/connector',
  'csui/lib/marionette', 'hbs!csui/controls/signin/impl/signin',
  'i18n!csui/controls/signin/impl/nls/localized.strings',
  'css!csui/controls/signin/impl/css/signin'
], function (module, _, $, BasicAuthenticator, CredentialsAuthenticator,
    PageContext, Connector, ConnectorFactory, Marionette, template, lang) {
  'use strict';

  var config = _.extend({
    useBasicAuthentication: false
  }, module.config());

  var SignInView = Marionette.ItemView.extend({
    constructor: function SignInView() {
      Marionette.ItemView.apply(this, arguments);
    },

    className: 'cs-signin',

    template: template,

    triggers: {
      'click button': 'click:button',
      //'click @ui.usernameclearer': 'click:usernameclearer',
      //'click @ui.passwordclearer': 'click:passwordclearer',
      'mousedown @ui.usernameclearer': 'click:usernameclearer',
      'mousedown @ui.passwordclearer': 'click:passwordclearer',
      'focus @ui.username': 'focus:username',
      'focus @ui.password': 'focus:password',
      'change @ui.password': 'change:password',
      'change @ui.username': 'change:username'
    },

    ui: {
      username: '#inputUsername',
      password: '#inputPassword',
      button: '#buttonSubmit',
      passwordclearer: '#passwordclearer',
      usernameclearer: '#usernameclearer',
      loginerror: '#loginError'
    },

    onRender: function () {
      this.ui.usernameclearer.toggle(false);
      this.ui.passwordclearer.toggle(false);
      //if (window.navigator.userAgent.indexOf("MSIE") === -1) {
        this.ui.username.prop('autofocus', true);
      //}
    },

    onClickPasswordclearer: function (event) {
      this.ui.password.val('').trigger('focus');
      this._unsetErrorStyle();
      this.ui.passwordclearer.hide();
    },

    onClickUsernameclearer: function (event) {
      this.ui.username.val('').trigger('focus');
      this._unsetErrorStyle();
      this.ui.usernameclearer.hide();
    },

    onFocusUsername: function () {
        this.validate();
    },

    onFocusPassword: function () {
        this.validate();
    },

    onChangeUsername: function () {
        this.validate();
    },

    onChangePassword: function () {
        this.validate();
    },

    templateHelpers: function () {
      return {
        buttontext: lang.signinButtonText,
        copyright: lang.signinCopyright,
        forgotpassword: lang.signinForgotPassword,
        placeholderusername: lang.signinPlaceholderUsername,
        usernameAria: lang.usernameAria,
        placeholderpassword: lang.signinPlaceholderPassword,
        passwordAria: lang.passwordAria
      };
    },

    events: {
      'keyup .binf-form-control': 'validate',
      'keydown button': 'onKeyPress'
    },

    onKeyPress: function (event) {
      var isButtonDisabled = this.ui.button.prop("disabled");

      // handle enter -> enable button
      if (!isButtonDisabled && event.which === 13) {
        this.ui.button.toggleClass('login-btn-enabled');
      }
    },

    validate: function (event) {
      this._unsetErrorStyle();

      var bIsUserNameSet = !!this.ui.username.val().length,
        bIsPasswordSet = true, //!!this.ui.password.val().length, // allow for empty pw
        bIsValidInput = bIsUserNameSet && bIsPasswordSet,
        bUserNameHasFocus = $(document.activeElement).is(this.ui.username),
        bPasswordHasFocus = $(document.activeElement).is(this.ui.password);

      // show/hide clearers
      this.ui.usernameclearer.toggle(bIsUserNameSet && bUserNameHasFocus);
      this.ui.passwordclearer.toggle(bIsPasswordSet && bPasswordHasFocus);

      // en/disable button
      this.ui.button.prop("disabled", !bIsValidInput);
      this.ui.button.toggleClass('login-btn-enabled', bIsValidInput);

      // submit on enter
      if (bIsValidInput && event && event.which === 13) {
        event.preventDefault();
        this.ui.button.trigger('click');
      }
    },

    onClickButton: function () {
      // disable button during login
      this.ui.button.toggleClass('login-btn-enabled', false);

      // Credentials always come from the form fields, while the rest
      // of the connection was specified in the constructor options
      var credentials = {
            username: this.ui.username.val(),
            password: this.ui.password.val()
          },
          useBasicAuthentication = config.useBasicAuthentication;

      if (!this.authenticator) {
        var connection = _.defaults({
              credentials: credentials
            }, this.options.connection),
            Authenticator = useBasicAuthentication ? BasicAuthenticator :
                            CredentialsAuthenticator,
            authenticator = new Authenticator({
              connection: connection
            }).on('loggedIn', _.bind(function () {
              this.ui.button.toggleClass('login-btn-enabled', true);
              this.trigger('success', {
                username: credentials.username,
                session: connection.session
              });
            }, this));
        this.authenticator = authenticator;
      }

      // authenticate
      var successHandler = _.bind(function () {
            // authentication succeeded -> update the shared connector used on the page
            var context = new PageContext(),
                connector = context.getObject(ConnectorFactory),
                session = this.authenticator.connection.session;
            connector.authenticator.updateAuthenticatedSession(session);
          }, this),
          errorHandler = _.bind(function (error, connection) {
            // authentication failed -> raise event, show error
            this.ui.button.toggleClass('login-btn-enabled', true);
            this._setErrorStyle();
            this.trigger('failure', {
              username: credentials.username,
              error: error
            });
          }, this);
      if (useBasicAuthentication) {
        this.authenticator.check({
          credentials: credentials,
        }, successHandler, errorHandler);
      } else {
        this.authenticator.login({
          data: credentials
        }, successHandler, errorHandler);
      }
    },

    _setErrorStyle: function () {
      this.ui.username.trigger('focus').trigger('select');
      this.ui.password.val('');
      this.ui.usernameclearer.toggle(true);
      this.ui.passwordclearer.toggle(true);
      this.ui.loginerror.html(lang.signinInvalidUsernameOrPassword);
      // TODO Force the error message through the screenreader

      this.$('.binf-form-group').addClass('binf-has-error');
      this.$('.clearer').removeClass('clear-icon').addClass('error-icon');
    },

    _unsetErrorStyle: function () {
      this.ui.loginerror.html('');
      this.$('.binf-form-group').removeClass('binf-has-error');
      this.$('.clearer').removeClass('error-icon').addClass('clear-icon');
    }
  });

  return SignInView;
});


/* START_TEMPLATE */
csui.define('hbs!csui/utils/impl/signin.dialog/signin',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"csui-signin binf-modal\">\r\n  <div class=\"binf-modal-dialog\">\r\n    <div class=\"binf-modal-content\"></div>\r\n  </div>\r\n</div>";
}});
Handlebars.registerPartial('csui_utils_impl_signin.dialog_signin', t);
return t;
});
/* END_TEMPLATE */
;

csui.define('css!csui/utils/impl/signin.dialog/signin',[],function(){});
csui.define('csui/utils/impl/signin.dialog/signin.dialog',['csui/lib/underscore', 'csui/lib/jquery', 'csui/lib/marionette',
  'csui/controls/signin/signin.view',
  'hbs!csui/utils/impl/signin.dialog/signin',
  'css!csui/utils/impl/signin.dialog/signin',
  'csui/lib/binf/js/binf'
], function (_, $, Marionette, SignInView, wrapperTemplate) {
  'use strict';

  function SignInDialog(options) {
    this.connection = options.connection;
  }

  _.extend(SignInDialog.prototype, {

    show: function () {
      var deferred = $.Deferred(),
          container = $.fn.binf_modal.getDefaultContainer(),
          wrapper = $(wrapperTemplate()).appendTo(container),
          region = new Marionette.Region({
            el: wrapper.find('.binf-modal-content')[0]
          }),
          view = new SignInView({
            connection: this.connection
          });
      view.on('success', function (args) {
        wrapper.binf_modal('hide');
        deferred.resolve(args);
      });
      region.show(view);
      wrapper
          .on('shown.binf.modal', function () {
            view.triggerMethod('dom:refresh');
          })
          .on('hidden.binf.modal', function () {
            view.destroy();
          })
          .binf_modal({
            backdrop: 'static',
            keyboard: false
          });
      return deferred.promise();
    }

  });

  return SignInDialog;

});

csui.define('csui/utils/toolitem.masks/global.toolitems.mask',['module', 'csui/lib/underscore',
  'csui/controls/toolbar/toolitems.mask'
], function (module, _, ToolItemMask) {
  'use strict';

  // Masks tool items in amy toolbar or menu by blacklist and whitelist
  var GlobalToolItemsMask = ToolItemMask.extend({

    constructor: function GlobalToolItemsMask() {
      ToolItemMask.prototype.constructor.apply(this);
      var config = module.config();
      // Masks passed in by separate require.config calls are sub-objects
      // stored in the outer object be different keys
      _.each(config, function (source, key) {
        this.extendMask(source);
      }, this);
      // Enable restoring the mask to its initial state
      this.storeMask();
    }

  });

  return GlobalToolItemsMask;

});


csui.define('css!csui/controls/form/impl/form',[],function(){});
csui.define('csui/models/form',['csui/lib/underscore', 'csui/lib/backbone', 'csui/lib/jsonpath'
], function (_, Backbone, jsonPath) {
  'use strict';

  var FormModel = Backbone.Model.extend({

    constructor: function FormModel(attributes, options) {
      this.options = options || (options = {});

      Backbone.Model.prototype.constructor.call(this, attributes, options);
    },

    getValue: function (path) {
      var data = this.get('data');
      if (data && path) {
        data = FormModel.getValueOnPath(data, path);
      } else {
        data = null;
      }
      return data;
    },

    setValue: function (path, value) {
      var data = this.get('data');
      if (data && path) {
        data = FormModel.setValueOnPath(data, path, value);
      } else {
        data = null;
      }
      return data;
    }

  }, {

    // Gets a value (generally a sub-object of an object) at the XPath-like
    // location in the provided data.  The path is in the HTML forms format,
    // which Alpaca uses to identify a field value
    getValueOnPath: function (data, path) {
      if (path) {
        // Convert the XPath-like path to the JSON path format
        path = path
            .replace(/^\//, '$.')
            .replace(/\//, '.');
        data = jsonPath(data, path);
        // jsonPath returns always an array with results or `false`
        data = data ? data[0] : null;
      }
      return data;
    },

    // Sets a value (generally a sub-object of an object) at the XPath-like
    // location in the provided data.  The path is in the HTML forms format,
    // which Alpaca uses to identify a field value
    setValueOnPath: function (data, path, value) {
      if (path) {
        // The field name is at the end of path and it could be an array with
        // the index in square brackets
        var name = path.replace(/^.*\/([^\/]+)$/, '$1'),
            index = name.indexOf('[') > 0 ?
                    name.replace(/^.*\[(\d+)\]$/, '$1') : undefined;
        if (index !== undefined) {
          // Get the parent array path by cutting the index - the last part
          // of the path and convert the XPath-like path to the JSON path format
          path = path
              .replace(/^(.*)\[[^\]]\]+$/, '$1')
              .replace(/^\//, '$.')
              .replace(/\//, '.');
          data = jsonPath(data, path);
          // If the parent array of the original value was not found,
          // do not set anything, otherwise return the modified parent
          if (data) {
            // jsonPath returns an array with found nodes
            data = data[0];
            data[parseInt(index, 10)] = value;
          } else {
            data = null;
          }
        } else {
          // Get the parent object path by cutting the name - the last item of
          // the path - and convert the XPath-like path to the JSON path format
          path = path
              .replace(/^(.*)\/[^\/]+$/, '$1')
              .replace(/^\//, '$.')
              .replace(/\//, '.');
          // If the parent object is the root, no need to traverse the data
          if (path && path !== '/') {
            data = jsonPath(data, path);
            if (data) {
              // jsonPath returns an array with found nodes
              data = data[0];
            }
          }
          // If the parent object of the original value was not found,
          // do not set anything, otherwise return the modified parent
          if (data) {
            data[name] = value;
          } else {
            data = null;
          }
        }
      }
      return data;
    },

    pluckPrimitiveFields: function (data) {
      function flattenObject(data, result) {
        return _.reduce(_.keys(data), function (result, key) {
          var value = data[key];
          if (_.isArray(value)) {
            result[key] = flattenArray(value);
          } else if (_.isObject(value)) {
            result = flattenObject(value, result);
          } else {
            result[key] = value;
          }
          return result;
        }, result || {}, this);
      }

      function flattenArray(array) {
        return _.map(array, function (item) {
          if (_.isArray(item)) {
            return flattenArray(item);
          } else if (_.isObject(item)) {
            return flattenObject(item);
          } else {
            return item;
          }
        });
      }

      return flattenObject(data);
    }

  });

  return FormModel;

});

csui.define('csui/models/appliedcategoryform',[
  'csui/lib/underscore', 'csui/utils/url', 'csui/models/form',
  'csui/models/mixins/node.connectable/node.connectable.mixin'
], function (_, Url, FormModel, NodeConnectableMixin) {
  'use strict';

  var AppliedCategoryFormModel = FormModel.extend({
    constructor: function AppliedCategoryFormModel(attributes, options) {
      FormModel.prototype.constructor.call(this, attributes, options);
      this.makeNodeConnectable(options);
      if (options) {
        this.action = this.options.action;
        this.categoryId = this.options.categoryId;
      }
    },

    clone: function () {
      return new this.constructor(this.attributes, {
        node: this.node,
        action: this.action,
        categoryId: this.categoryId
      });
    },

    url: function () {
      var url = _.str.sformat('forms/nodes/categories/{0}?id={1}&category_id={2}',
          this.action, this.node.get('id'), this.categoryId);
      return Url.combine(this.connector.connection.url, url);
    },

    parse: function (response, options) {
      // Some views may fail if one of the three properties was missing
      var form = _.extend({
            data: {},
            schema: {},
            options: {}
            // The server returns an array pf forms, although only one category
            // was requested.  Normalize the response to be just a single form.
          }, response.form || response.forms && response.forms[0] || response),
          // Title usually does not come from the server
          title = form.title || this.get('title');

      form.options = _.omit(form.options, 'form');
      if (form.schema.title === undefined) {
        form.schema.title = title;
      }
      if (!form.title) {
        form.title = title;
      }
      if (form.role_name === undefined) {
        form.role_name = "categories";
      }

      var categoryId = form.categoryId || options && options.categoryId || this.categoryId;
      if (categoryId) {
        AppliedCategoryFormModel.updateInternalProperties(categoryId, form);
      }

      return form;
    }
  }, {
    updateInternalProperties: function (categoryId, form) {
      var categoryData = form.data;
      var categorySchema = form.schema;
      var categoryOptions = form.options;
      var stateId = categoryId + '_1';
      var stateData = categoryData[stateId] || {};
      var internalIds = Object.keys(stateData);
      // State flags should be (mostly) read-only not to be sent back to the server.
      var stateSchema = categorySchema.properties && categorySchema.properties[stateId];
      if (stateSchema) {
        // Allow some internal fields be writable.
        stateSchema.readonly = false;
        stateSchema = stateSchema.properties || (stateSchema.properties = {});
        Object
          .keys(stateSchema)
          .forEach(function (propertyName) {
            // Let only metadata token be writable and thus sent back to the server.
            stateSchema[propertyName].readonly = propertyName !== 'metadata_token';
          });
        // Workaround for the server not sending schema for internal properties
        internalIds.forEach(function (id) {
          if (!stateSchema[id]) {
            stateSchema[id] = {
              readonly: id !== 'metadata_token'
            };
          }
        });
      }
      // State flags need not be visible.
      var stateOptions = categoryOptions.fields && categoryOptions.fields[stateId];
      if (stateOptions) {
        // Hide all internal fields.
        stateOptions.hidden = true;
        stateOptions = stateOptions.fields || (stateOptions.fields = {});
        Object
          .keys(stateOptions)
          .forEach(function (fieldName) {
            stateOptions[fieldName].hidden = true;
          });
        // Workaround for the server not sending options for internal fields
        internalIds.forEach(function (id) {
          if (!stateOptions[id]) {
            stateOptions[id] = {
              hidden: true
            };
          }
        });
      }
    }
  });

  NodeConnectableMixin.mixin(AppliedCategoryFormModel.prototype);

  return AppliedCategoryFormModel;
});

csui.define('csui/widgets/metadata/impl/nls/lang',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/widgets/metadata/impl/nls/root/lang',{
  metadataRegionAria: 'Metadata content',

  // tab title
  properties: 'Properties',
  versions: 'Versions',
  general: 'General',
  audit: 'Audit',
  releases: 'Releases',

  // Dropdown menu items
  MenuItemRename: 'Rename',
  MenuItemEdit: 'Edit',
  MenuItemCopy: 'Copy',
  MenuItemMove: 'Move',
  MenuItemDownload: 'Download',
  MenuItemReserve: 'Reserve',
  MenuItemUnreserve: 'Unreserve',
  MenuItemAddVersion: 'Add version',
  MenuItemDelete: 'Delete',

  // add item metadata
  addItemMetadataDialogButtonAddTitle: 'Add',
  addItemMetadataDialogButtonUploadTitle: 'Upload',
  addItemMetadataDialogButtonCancelTitle: 'Cancel',
  addItemMetadataDialogTitle1: 'Add {0}',
  addItemMetadataDialogTitleGeneric: 'Item',
  addDocumentMetadataDialogTitle: 'Upload file',
  addFolderMetadataDialogTitle: 'Upload folder',
  addDocumentsMetadataDialogTitle: 'Upload files',
  addFoldersMetadataDialogTitle: 'Upload folders',
  addItemsMetadataDialogTitle: 'Upload items',
  addDocumentMetadataDialogAddButtonTitle: 'Upload',
  addItemPlaceHolderName: 'Enter name',
  emptyObjectNameAria: 'Object name',

  // other messages
  itemTitleAria: '{0}, click to edit',
  editNameTooltip: 'Edit name',
  saveEditNameTooltip: 'Save',
  cancelEditNameTooltip: 'Cancel',
  failedToSaveName: 'Failed to save name.',
  failedToCreateItem: 'Failed to create the new item.',
  failedToValidateForms: 'Failed to validate all Forms.  Please check that all required fields are entered.',
  switchLanguageTooltip: 'Switch language',
  gotoPreviousCategoryTooltip: 'Show previous Category',
  gotoNextCategoryTooltip: 'Show next Category',
  addNewProperties: 'Add properties',
  addNewCategory: 'Add a new Category',
  addNewCategoryDialogTitle: 'Add Category',
  addNewCategoryDialogAddButtonTitle: 'Add',
  removeCategoryTooltip: 'Remove this Category',
  removeCategoryWarningTitle: 'Remove Category',
  removeCategoryWarningMessage: 'Do you want to remove Category "{0}"?',
  removeCategoryFailMessageTitle: 'Remove Category Failed',
  removeCategoryFailMessage: 'Failed to remove Category "{0}". \n\n{1}',
  getPropertyPanelsFailTitle: 'Error Loading Properties',
  getCategoryActionsFailTitle: 'Get Category Actions',
  getCategoryActionsFailMessage: 'Failed to get Category actions for node "{0}". \n\n{1}',
  getActionsForACategoryFailMessage: 'Failed to get actions for Category "{0}" of node "{1}". \n\n{2}',
  addNewCategoryFailTitle: 'Add Category to node',
  addNewCategoryFailMessage: 'Failed to add Category "{0}" to node "{1}" with node ID "{2}". \n\n{3}',
  categoryExistsMessage: 'Error: Category "{0}" already exists.',
  loadNewCategoryFailTitle: 'Get new Category Form',
  loadNewCategoryFailMessage: 'Failed to get Form for Category "{0}" on node "{1}" with node ID "{2}". \n\n{3}',
  selectCategoryTitle: 'Select a Category to add',
  selectCategoryButtonLabel: 'Add',
  viewShortcutMessage: 'View shortcut',
  viewOriginalMessage: 'View original',
  shortcutLocationLabel: 'Original location',
  closeMetadataButtonTooltip: 'Close metadata',
  formValidationErrorMessage: 'Required fields must be filled',
  hideValidationErrorMessageIconTooltip: 'Hide validation error',
  missingRequiredMetadataForDocuments: 'Missing required metadata for some document(s).',
  goBackTooltip: 'Go back',
  onlyRequiredFieldsLabel: 'Only required fields (*)',
  defaultDialogTitle: 'Metadata',
  defaultDialogOkButtonTitle: 'OK',
  defaultDialogCancelButtonTitle: 'Cancel',
  moveOneItemMetadataDialogTitle: 'Move {0} item',
  moveMultipleItemsMetadataDialogTitle: 'Move {0} items',
  moveItemsMetadataDialogButtonTitle: 'Move',
  copyOneItemMetadataDialogTitle: 'Copy {0} item',
  copyMultipleItemsMetadataDialogTitle: 'Copy {0} items',
  copyItemsMetadataDialogButtonTitle: 'Copy',
  missingRequiredMetadataForObjects: 'Missing required metadata for some object(s).',
  inheritanceOriginalProperties: 'with original properties',
  inheritanceDestinationProperties: 'with destination properties',
  inheritanceMergedProperties: 'with combined properties',
  requiredTooltip: 'Required',
  requiredPassedTooltip: 'Required fields satisfied.',
  restructureOneItemMetadataDialogTitle: 'Restructure {0} item',
  restructureMultipleItemsMetadataDialogTitle: 'Restructure {0} items',
  restructureItemsMetadataDialogButtonTitle: 'Restructure',

  // Versions
  ToolbarItemVersionInfo: 'Properties',
  ToolbarItemVersionDelete: 'Delete',
  ToolbarItemPromoteVersion: 'Promote to major',
  ToolbarItemVersionPurgeAll: 'Purge all previous Versions',
  ToolbarItemVersionDownload: 'Download',
  ToolbarItemDocVersionPreview: 'View',
  ToolbarItemCopyLink: 'Copy link',
  ToolbarItemEmailLink: 'Mail as link',
  ToolbarItemMore: 'More actions',
  versionColumnSizeTitle: 'Size',
  versionColumnVersionNumberTitle: 'Version',
  openDoc: 'Open {0}',
  openDocAria: 'Open {0} {1}',
  versionNumInBrowserTitle: 'Version {0}',
  docPreviewAlt: 'Document Preview',
  versionTableAria: 'Versions of {0}',

  // Audit
  action: 'Action',
  date: 'Date',
  user: 'User',
  auditNoResultsPlaceholder: "No results found",
  auditTableAria: 'Audit events of {0}',

  //Releases
  release: 'Release',
  created: 'Created',
  createdBy: 'Created By',
  releasesNoResultsPlaceholder: 'There are no releases available for this compound document.',
  releasesTableAria: 'Releases of {0}',

  // properties: general
  formFieldItemIdLabel: 'Item ID',
  formFieldSizeLabel: 'Size',
  formFieldTypeLabel: 'Type',
  formFieldReservedStatusLabel: 'Status',
  formFieldReservedByLabel: 'Reserved by',

  UrlLabel: "Web address",
  UrlTitle: "Web address",

  // alpaca placeholder
  alpacaPlaceholderNotAvailable: 'n/a',
  alpacaPlaceholderUrl: 'Add web address',
  alpacaPlaceholderOTNodePicker: 'Select',
  alpacaPlaceholderDescription: 'Add description',
  NoOwner: '<No Owner>',
  showMore: 'Show more',
  showMoreAria: 'Show more actions of {0}',
  collapse: 'Hide item list',
  expand: 'Show item list',
  permissionPage: "Permission Page of {0}"
});


csui.define('csui/models/forms',['csui/lib/backbone', 'csui/models/form'
], function (Backbone, FormModel) {
  'use strict';

  var FormCollection = Backbone.Collection.extend({

    model: FormModel,

    constructor: function FormCollection(models, options) {
      this.options = options || (options = {});

      Backbone.Collection.prototype.constructor.call(this, models, options);
    }

  });

  return FormCollection;

});

csui.define('csui/models/nodeforms',['module', 'csui/lib/jquery', 'csui/lib/underscore',
  'csui/lib/backbone', 'csui/utils/log', 'csui/utils/base',
  'csui/models/forms',
  'csui/models/mixins/node.resource/node.resource.mixin'
], function (module, $, _, Backbone, log, base, FormCollection,
    NodeResourceMixin) {
  'use strict';

  var NodeFormCollection = FormCollection.extend({

    constructor: function NodeFormCollection(models, options) {
      FormCollection.prototype.constructor.apply(this, arguments);

      this.makeNodeResource(options);
    },

    parse: function (response) {
      return response.forms;
    }

  });

  NodeResourceMixin.mixin(NodeFormCollection.prototype);

  return NodeFormCollection;

});

csui.define('csui/models/nodecreateforms',["module", "csui/lib/jquery", "csui/lib/underscore", "csui/lib/backbone",
  "csui/utils/log", "csui/utils/base", "csui/models/nodeforms",
  'csui/models/node.createform/server.adaptor.mixin'
], function (module, $, _, Backbone, log, base, NodeFormCollection, ServerAdaptorMixin) {
  "use strict";

  // NodeCreateFormCollection
  // ------------------------

  var NodeCreateFormCollection = NodeFormCollection.extend({

      constructor: function NodeCreateFormCollection(models, options) {
        NodeFormCollection.prototype.constructor.apply(this, arguments);
        this.type = options.type;
        this.docParentId = options.docParentId;
        if (this.type === undefined) {
          throw new Error(this.ERR_CONSTRUCTOR_NO_TYPE_GIVEN);
        }
      },

      clone: function () {
        return new this.constructor(this.models, {
          node: this.node,
          type: this.type
        });
      }
    },
    // statics
    {
      // errors
      ERR_CONSTRUCTOR_NO_TYPE_GIVEN: "No creation type given in constructor"
    });

  // Module
  // ------

  _.extend(NodeCreateFormCollection, {
    version: '1.0'
  });

  ServerAdaptorMixin.mixin(NodeCreateFormCollection.prototype);
  return NodeCreateFormCollection;

});
csui.define('csui/models/nodeupdateforms',[
  'csui/lib/underscore', 'csui/models/node/node.model', 'csui/models/nodeforms',
  'csui/models/form', 'csui/models/appliedcategoryform'
], function (_, NodeModel, NodeFormCollection, FormModel, AppliedCategoryFormModel) {
  'use strict';

  function UpdateFormModelFactory (attributes, options) {
    if (attributes.role_name === 'categories') {
      return new AppliedCategoryFormModel(attributes, options);
    }
    return new FormModel(attributes, options);
  }

  var NodeUpdateFormCollection = NodeFormCollection.extend({
    constructor: function NodeUpdateFormCollection(models, options) {
      NodeFormCollection.prototype.constructor.apply(this, arguments);
      this.makeNodeResource(options);
    },

    model: UpdateFormModelFactory,

    clone: function () {
      return new this.constructor(this.models, {
        node: this.node
      });
    },

    url: function () {
      return _.str.sformat('{0}/forms/nodes/update?id={1}', this.connector.connection.url,
        this.node.get('id'));
    },

    parse: function (response) {
      var forms = [];
      (response.forms || []).forEach(this._parseForm.bind(this, forms));
      return forms;
    },

    _parseForm: function (forms, form) {
      if (form.role_name === 'categories') {
        this._parseCategory(forms, form);
      } else if (form.role_name === 'systemattributes') {
        this.node.systemattributes = form;
      } else {
        forms.push(form);
      }
    },

    _parseCategory: function (forms, form) {
      var formData = form.data || {};
      var formSchema = form.schema && form.schema.properties || {};
      var formOptions = form.options && form.options.fields || {};
      // Categories are sent as sub-forms in a single form.
      Object
        .keys(formSchema)
        .forEach(function (categoryId) {
          // Although the identifier should be an integer, categories are
          // enumerable only as object keys, which forces them to strings.
          if (NodeModel.usesIntegerId) {
            categoryId = +categoryId;
          }
          var categoryData = formData[categoryId] || {};
          var categorySchema = formSchema[categoryId] || {};
          var categoryOptions = formOptions[categoryId] || {};
          var categoryName = categorySchema['title'];
          var removeable = categoryOptions.removeable !== false;
          forms.push({
            id: categoryId,
            name: categoryName,
            title: categoryName,
            data: categoryData,
            role_name: 'categories',
            removeable: removeable,
            // TODO: Remove this and leave the `removeable` property only.
            // It should be done as one of braking-changes release.
            allow_delete: removeable,
            categoryId: categoryId,
            options: categoryOptions,
            schema: categorySchema
          });
        });
    }
  });

  return NodeUpdateFormCollection;
});

csui.define('csui/widgets/metadata/metadata.forms/server.adaptor.mixin',[
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/backbone',
  'csui/utils/log', 'csui/utils/base', 'csui/utils/url',
  'csui/models/appliedcategories', 'csui/models/form',
  'csui/models/appliedcategoryform', 'i18n!csui/widgets/metadata/impl/nls/lang',
  'csui/models/nodecreateforms','csui/models/nodeupdateforms',
  'csui/models/node/node.model', 'csui/models/version'
], function ($, _, Backbone, log, base, Url,
    AppliedCategoryCollection, FormModel, AppliedCategoryFormModel, lang,
    NodeCreateFormCollection, NodeUpdateFormCollection, NodeModel,
    VersionModel) {
  'use strict';

  var prototypeExt = {

    makeServerAdaptor: function (options) {
      return this;
    },

    sync: function (method, model, options) {

      if (method === 'read') {

        // branch off for different metadata form calls
        if (this.action === 'copy' || this.action === 'move' || this.action === 'restructure') {
          return this._getMetadataCopyMoveItemForms(method, model, options);
        } else if (this.action === 'create' || this.node.get("id") === undefined) {
          return this._getMetadataAddItemForms(method, model, options);
        } else {  // the main metadata case
          if (this.node instanceof VersionModel) {
            return this._getMetadataVersionsForms(method, model, options);
          } else {
            return this._getMetadataForms(method, model, options);
          }
        }

      } else {
        // create/delete/update
        return Backbone.Collection.prototype.sync.apply(this, arguments);
      }

    },

    // Get metadata forms for an existing node
    _getMetadataForms: function (method, model, options) {

      model.trigger('request', model, undefined, options);

      // fetch categories
      // if this is for a shortcut, fetch categories for original node
      var node       = this.node,
          type       = node.get('type'),
          categories = new NodeUpdateFormCollection(undefined, {node: node});
      return categories
          .fetch()
          .then(_.bind(function (data, status, jqXHR) {
            // Form models are passed to the tab control as-is. The tab control
            // recognizes `allow_delete`, while the category schema includes
            // `removeable` for permanent categories.
            categories.each(function (category) {
              category.set('allow_delete', category.get('removeable'));
            });
            this.options = options;
            this.forms = categories.models;
            if (options.success) {
              options.success(this.forms, 'success');
            }
          }, this))
          .fail(function (request, message, statusText) {
            if (options.error) {
              options.error(request, message, statusText);
            }
          });
    },

    // Get metadata forms for a document version
    _getMetadataVersionsForms: function (method, model, options) {

      model.trigger('request', model, undefined, options);

      var deferred = $.Deferred();

      var version = this.node;
      var nodeId = version.get('id');
      var verNum = version.get('version_number');
      var connector = version.connector;

      var versionCatsUrl = Url.combine(connector.connection.url, 'forms/nodes/versions/categories');
      var getCategoriesOptions = {
        url: versionCatsUrl + '?' +
             $.param({
               id: nodeId,
               version_number: verNum
             })
      };

      connector.makeAjaxCall(getCategoriesOptions)
          .done(_.bind(function (response, statusText, jqxhr) {

            var forms = [];

            // category form models
            var allCategoriesForm = response.forms[0];
            if (allCategoriesForm) {
              var roleName = "categories";
              if (this.roles === undefined) {
                this.roles = {};
              }
              if (this.roles[roleName] === undefined) {
                this.roles[roleName] = {};
              }

              var catIds = _.keys(allCategoriesForm.options.fields);
              _.each(catIds, function (catId) {
                var catName = allCategoriesForm.schema.properties[catId].title;
                var catData = allCategoriesForm.data[catId];
                var catOptions = allCategoriesForm.options.fields[catId];
                var catSchema = allCategoriesForm.schema.properties[catId];
                if (NodeModel.usesIntegerId) {
                  catId = parseInt(catId);
                }
                var catModel = new AppliedCategoryFormModel({
                  id: catId,
                  title: catName,
                  allow_delete: false,
                  removeable: false
                }, {
                  node: this.node,
                  categoryId: catId,
                  action: 'none'
                });
                forms.push(catModel);

                catModel.set({
                  data: catData,
                  options: catOptions,
                  schema: _.omit(catSchema, ['description']),
                  role_name: roleName,
                  removeable: false
                });
              }, this);
            }

            if (options.success) {
              options.success(forms, 'success');
            }
            deferred.resolve();

          }, this))
          .fail(function () {
            deferred.reject.apply(deferred, arguments);
          });

      return deferred.promise();
    },

    // Get Metadata forms for Add Item
    _getMetadataAddItemForms: function (method, model, options) {

      model.trigger('request', model, undefined, options);

      var nData       = this.node.get('data'),
          createForms = this.formCollection ||
                        new NodeCreateFormCollection(undefined, {
                          node: this.container,
                          docParentId: this.node.get('docParentId'),
                          type: this.node.get('type')
                        }),
          data        = this.node.get('forms') || undefined,
          xhr         = this.node.get('xhr') || undefined,
          pushresp    = {};

      if (!!data && !!xhr) {
        data.forms[0].id = 'general';

        this._pushForms(data, nData, options);
        this.fetching = false;
        this.fetched = true;
        return $.Deferred().resolve();
      }
      else {
        return createForms
            .fetch()
            .then(_.bind(function (data, status, jqXHR) {

              this._pushForms(data, nData, options);
            }, this))
            .fail(function (jqXHR, textStatus, errorThrown) {
              if (options.error) {
                options.error(jqXHR, textStatus, errorThrown);
              }
            });
      }

    },

    _pushForms: function (data, nData, options) {
      var forms = [];

      // set data from inline form if entered
      var name = this.node.get('name');
      if (name !== undefined) {
        data.forms[0].data.name = name;
      }
      var addableType = this.node.get('type');
      if (addableType === 1) {  // Shortcut
        var original_id = this.node.get('original_id');
        if (original_id !== undefined) {
          data.forms[0].data.original_id = original_id;
        }
      } else if (addableType === 140) {  // URL
        var url = this.node.get('url');
        if (url && url.length > 0) {
          data.forms[0].data.url = url;
        }
      } else if (addableType === 144) {  // Document
        if (name !== undefined) {
          data.forms[0].data.file = name;
        }
        if (nData) {
          var fData = data.forms[0].data;
          nData.name && (fData.name = nData.name);
          nData.description && (fData.description = nData.description);
          nData.advanced_versioning &&
          (fData.advanced_versioning = nData.advanced_versioning);
        }
      }

      _.each(data.forms, function (form) {
        if (form.role_name === 'categories') {
          this._pushCategoryForms(form, forms, options);
        } else {
          forms.push(new FormModel(form));
        }
      }, this);

      if (options.success) {
        options.success(forms, 'success');
      }
    },

    _pushCategoryForms: function (multiForm, targetForms, options) {
      var nData  = this.node.get('data'),
          catIds = _.keys(multiForm.options.fields);
      _.each(catIds, function (catId) {
        if (_.indexOf(this.node.removedCategories, catId) === -1) {
          var catName = multiForm.schema.properties[catId].title,
              catData = multiForm.data[catId];
          if (nData && nData.roles && nData.roles.categories &&
              nData.roles.categories[catId]) {
            catData = _.extend(catData, nData.roles.categories[catId]);
          }
          var catOptions = multiForm.options.fields[catId];
          var catSchema = _.omit(multiForm.schema.properties[catId], 'description');
          if (NodeModel.usesIntegerId) {
            catId = parseInt(catId);
          }
          var removeable = catOptions && catOptions.removeable === false ? false : true;
          var catModel = new AppliedCategoryFormModel({
            id: catId,
            title: catName,
            data: catData,
            options: catOptions,
            schema: catSchema,
            role_name: 'categories',
            allow_delete: removeable,
            removeable: removeable
          }, {
            node: this.node,
            categoryId: catId,
            action: 'none'
          });
          if (options.reset) {
            targetForms.push(catModel);
          } else {
            this.add(catModel);
          }
        }
      }, this);
    },

    // Get Metadata forms for Copy/Move Item
    _getMetadataCopyMoveItemForms: function (method, model, options) {

      model.trigger('request', model, undefined, options);

      var deferred    = $.Deferred(),
          self        = this,
          nodeId      = this.node.get('id'),
          connector   = this.container.connector,
          inheritance = {original: 0, destination: 1, merged: 2},
          formUrl;

      if (self.action === 'copy') {
        formUrl = '/forms/nodes/copy';
      } else if (self.action === 'move') {
        formUrl = '/forms/nodes/move';
      } else if (self.action === 'restructure') {
        // restructure functionality is similar to move, so we can reuse this api
        formUrl = '/forms/nodes/move';
      }
      var getCategoriesOptions = {
        url: connector.connection.url + formUrl + '?' +
             $.param({
               id: nodeId,
               parent_id: self.container.get('id'),
               inheritance: inheritance[self.inheritance]
             })
      };

      connector.makeAjaxCall(getCategoriesOptions)
          .done(function (response, statusText, jqxhr) {

            var forms = [];

            // category form models
            var allCategoriesForm;
            if (response.forms.length > 1) {
              allCategoriesForm = _.find(response.forms, function (form) {
                return form.role_name === "categories";
              });
            }
            if (allCategoriesForm) {
              var roleName = allCategoriesForm.role_name;
              if (self.roles === undefined) {
                self.roles = {};
              }
              if (self.roles[roleName] === undefined) {
                self.roles[roleName] = {};
              }

              var prevDataOnNode = self.node.get('data');
              var prevCatDataOnNode = {};
              if (prevDataOnNode && prevDataOnNode.roles && prevDataOnNode.roles[roleName]) {
                prevCatDataOnNode = prevDataOnNode.roles[roleName];
              }

              var catIds = _.keys(allCategoriesForm.options.fields);
              _.each(catIds, function (catId) {
                if (_.indexOf(self.node.removedCategories, catId) === -1) { //don't show
                  // previously deleted categories
                  var catName      = allCategoriesForm.schema.properties[catId].title,
                      catData      = allCategoriesForm.data[catId],
                      catOptions   = allCategoriesForm.options.fields[catId],
                      catSchema    = allCategoriesForm.schema.properties[catId],
                      correctCatId = NodeModel.usesIntegerId ? parseInt(catId) : catId,
                      removable    = catOptions.removeable !== false,
                      catModel     = new AppliedCategoryFormModel({
                        id: correctCatId,
                        title: catName,
                        removeable: removable,
                        allow_delete: removable
                      }, {
                        node: self.node,
                        categoryId: correctCatId,
                        action: 'none'
                      });

                  forms.push(catModel);

                  //restore previous set values if available
                  if (_.isEmpty(prevCatDataOnNode[catId]) === false) {
                    _.each(catData, function (iValue, iKey) {
                      if (_.has(prevCatDataOnNode[catId], iKey)) {
                        catData[iKey] = prevCatDataOnNode[catId][iKey];
                      }
                    });
                  }
                  catModel.set({
                    data: catData,
                    options: catOptions,
                    schema: _.omit(catSchema, ['description']),
                    role_name: roleName
                  });
                }
              });
            }

            if (options.success) {
              options.success(forms, 'success');
            }
            deferred.resolve();

          })
          .fail(function (jqXHR, textStatus, errorThrown) {
            if (options.error) {
              options.error(jqXHR, textStatus, errorThrown);
            }
            deferred.reject.apply(deferred, arguments);
          });

      return deferred.promise();
    }
  };

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, prototypeExt);
    }
  };

  return ServerAdaptorMixin;
});

csui.define('csui/widgets/metadata/metadata.forms',[
  'csui/lib/backbone', 'csui/utils/log',
  'csui/models/mixins/node.connectable/node.connectable.mixin',
  'csui/models/mixins/fetchable/fetchable.mixin',
  'csui/widgets/metadata/metadata.forms/server.adaptor.mixin'
], function (Backbone, log, NodeConnectableMixin,
    FetchableMixin,  ServerAdaptorMixin) {
  'use strict';

  // TODO: Let the scenario owner create the specific a collection and pass
  // it down to the metadata view.  The "collection guidepost should not be
  // needed.  It tightly couples all metadata scenarios

  var MetadataFormCollection = Backbone.Collection.extend({
    constructor: function MetadataFormCollection(models, options) {
      options || (options = {});
      this.action = options.action;
      this.inheritance = options.inheritance;
      this.container = options.container;
      this.formCollection = options.formCollection;

      Backbone.Collection.prototype.constructor.apply(this, arguments);

      this.makeNodeConnectable(options)
          .makeFetchable(options)
          .makeServerAdaptor(options);
    }
  });

  NodeConnectableMixin.mixin(MetadataFormCollection.prototype);
  FetchableMixin.mixin(MetadataFormCollection.prototype);
  ServerAdaptorMixin.mixin(MetadataFormCollection.prototype);

  return MetadataFormCollection;
});

csui.define('csui/widgets/search.results/controls/sorting/impl/nls/localized.strings',{
  // Always load the root bundle for the default locale (en-us)
  "root": true,
  // Do not load English locale bundle provided by the root bundle
  "en-us": false,
  "en": false
});

csui.define('csui/widgets/search.results/controls/sorting/impl/nls/root/localized.strings',{
  sortBy: 'Sort by...',
  sortByThis: 'Sort by {0}',
  sortOptionsAria: 'Sort options',
  ascending: '{0}: Click to sort ascending',
  descending: '{0}: Click to sort descending'
});



/* START_TEMPLATE */
csui.define('hbs!csui/widgets/search.results/controls/sorting/impl/sort.menu',['module','hbs','nuc/lib/handlebars'], function( module, hbs, Handlebars ){ 
var t = Handlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "  <div class=\"csui-search-sort-options \">\r\n    <button id=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"id") || (depth0 != null ? lookupProperty(depth0,"id") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"id","hash":{},"loc":{"start":{"line":3,"column":16},"end":{"line":3,"column":22}}}) : helper)))
    + "\" type=\"button\" class=\"binf-btn binf-btn-default binf-dropdown-toggle\"\r\n            data-binf-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"sortButtonAria") || (depth0 != null ? lookupProperty(depth0,"sortButtonAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"sortButtonAria","hash":{},"loc":{"start":{"line":4,"column":95},"end":{"line":4,"column":113}}}) : helper)))
    + "\">\r\n      <span class=\"cs-label\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"loc":{"start":{"line":5,"column":29},"end":{"line":5,"column":38}}}) : helper)))
    + "</span>\r\n      <span class=\"cs-icon icon-caret-down\"></span>\r\n    </button>\r\n    <ul class=\"binf-dropdown-menu\" role=\"menu\" aria-label=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"listAria") || (depth0 != null ? lookupProperty(depth0,"listAria") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"listAria","hash":{},"loc":{"start":{"line":8,"column":59},"end":{"line":8,"column":71}}}) : helper)))
    + "\"></ul>\r\n  </div>\r\n  <a href=\"javascript:void(0);\" class=\"cs-icon search-sort-btn icon-sortArrowDown\"></a>\r\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"sortEnable") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"loc":{"start":{"line":1,"column":0},"end":{"line":11,"column":7}}})) != null ? stack1 : "");
}});
Handlebars.registerPartial('csui_widgets_search.results_controls_sorting_impl_sort.menu', t);
return t;
});
/* END_TEMPLATE */
;
csui.define('csui/widgets/search.results/controls/sorting/sort.menu.view',['module',
  'require',
  'csui/lib/jquery',
  'csui/lib/underscore',
  'csui/lib/backbone',
  'csui/lib/marionette',
  'csui/utils/log',
  'i18n!csui/widgets/search.results/controls/sorting/impl/nls/localized.strings',
  'hbs!csui/widgets/search.results/controls/sorting/impl/sort.menu',
  'csui/controls/tile/behaviors/perfect.scrolling.behavior',
  'csui/behaviors/keyboard.navigation/tabable.region.behavior',
  'csui/lib/binf/js/binf'
], function (module, require, $, _, Backbone, Marionette, log, lang, template,
    PerfectScrollingBehavior, TabableRegionBehavior) {

  var SearchSortingView = Marionette.ItemView.extend({

    className: 'cs-sort-links',
    template: template,
    templateHelpers: function () {
      var messages = {
        sortBy: lang.sortBy
      };
      var selectedTitle = this.selected.get('title') ? this.selected.get('title') :
                          this.constants.DEFAULT_SORT;
      return {
        messages: messages,
        sortEnable: this.collection.models.length && !!this.collection.sorting &&
                    this.options.enableSorting,
        id: _.uniqueId('sortButton'),
        sortButtonAria: lang.sortOptionsAria,
        listAria: lang.sortOptionsAria
      };
    },

    constants: {
      SORT_ASC: "asc",
      SORT_DESC: "desc",
      DEFAULT_SORT: "relevance"
    },

    events: {
      'click .binf-dropdown-menu > li > a': 'onSortOptionClick',
      'click a.search-sort-btn': 'onSortOrderClick',
      "keydown": "onKeyInView"
    },

    ui: {
      toggle: '>.csui-search-sort-options>.binf-dropdown-toggle',
      selectedLabel: '>.csui-search-sort-options>.binf-dropdown-toggle >.cs-label',
      selectedIcon: '>.csui-search-sort-options>.binf-dropdown-toggle >.cs-icon',
      sortOrderBtn: 'a.search-sort-btn',
      dropdownToggle: '.binf-dropdown-toggle'
    },

    constructor: function SearchSortingView(options) {
      Marionette.View.prototype.constructor.apply(this, arguments);

      this.config = this.options.config || {};

      this.selected = new Backbone.Model();
      if (this.collection) {
        var orderBy = this.options.orderBy || this.collection.orderBy;
        this.collection.setOrder(orderBy, false);
        this.listenTo(this.collection, 'reset', this.render); // render after reset of collection
      }
      this.listenTo(this.collection, 'change', this._refreshSelection);
      this.listenTo(this.selected, 'change', this._updateSelection);
    },

    onRender: function () {
      var self = this;
      this.ui.toggle.binf_dropdown();
      this.ui.dropdownToggle.on('binf.dropdown.after.show', function () {
        self.trigger('ensure:scrollbar');
      });
      this.ui.sortOrderBtn.hide();
      if (this.collection.sorting !== undefined
          && this.collection.sorting.links !== undefined) {
        if (this.collection.sorting.sort &&
            this.collection.sorting.sort[0] !== this.constants.DEFAULT_SORT) {
          this._setSelection(this.collection.sorting.links[this.collection.sorting.sort]);
          this._addDropdownItems($.extend({}, this.collection.sorting.links),
              this.collection.sorting.sort[0]);
          this.ui.sortOrderBtn.show();
        } else {
          this._setSelection(this.collection.sorting.links[this.constants.DEFAULT_SORT]);
          this._addDropdownItems($.extend({}, this.collection.sorting.links), "");
          this.$el.find(".binf-dropdown-menu > :first-child").addClass("binf-active");
          this.$el.find(".binf-dropdown-menu > :first-child a.csui-sort-option").attr("aria-checked", "true");
          this.$el.find(".binf-dropdown-menu > :first-child .cs-icon").addClass(
              "icon-listview-checkmark");
          this.ui.sortOrderBtn.hide();
        }
        this.ui.selectedLabel.text(this.selected.get('title'));
        if (this.selected.get("order") === this.constants.SORT_ASC) {
          this.ui.sortOrderBtn.removeClass("icon-sortArrowDown");
          this.ui.sortOrderBtn.addClass("icon-sortArrowUp");
          var titleD = _.str.sformat(lang.descending, this.selected.get('titleAttr'));
          this.ui.sortOrderBtn.attr('title', titleD).attr('aria-label', titleD);
        } else {
          this.ui.sortOrderBtn.removeClass("icon-sortArrowUp");
          this.ui.sortOrderBtn.addClass("icon-sortArrowDown");
          var titleA = _.str.sformat(lang.ascending, this.selected.get('titleAttr'));
          this.ui.sortOrderBtn.attr('title', titleA).attr('aria-label', titleA);
        }
      }
    },
    onKeyInView: function (event) {
      // Watch for tab key
      if (event.keyCode === 9) {
        !!this.$el.find('.binf-open') && this.$el.find('.binf-open').removeClass('binf-open');
      }

    },
    behaviors: {
      PerfectScrolling: {
        behaviorClass: PerfectScrollingBehavior,
        contentParent: '.binf-dropdown-menu',
        suppressScrollX: true
      },
      TabableRegionBehavior: {
        behaviorClass: TabableRegionBehavior
      }
    },

    currentlyFocusedElement: function (event) {
      var tabElements = this.$('*[tabindex]');
      if (tabElements.length) {
        tabElements.prop('tabindex', 0);
      }
      if (!!event && event.shiftKey) {
        return $(tabElements[tabElements.length - 1]);
      } else {
        if (this.orderClicked) {
          return this.ui.sortOrderBtn;
        } else {
          return $(tabElements[0]);
        }
      }
    },

    _setSelection: function (model) {
      var sortObj = {};
      if (this.collection.sorting.sort) {
        if (this.collection.sorting.sort[0].indexOf(this.constants.SORT_DESC) === 0) {
          sortObj.id = this.collection.sorting.sort[0].replace(/desc_/g, '');
          sortObj.order = this.constants.SORT_DESC;
        }
        if (this.collection.sorting.sort[0].indexOf(this.constants.SORT_ASC) === 0) {
          sortObj.id = this.collection.sorting.sort[0].replace(/asc_/g, '');
          sortObj.order = this.constants.SORT_ASC;
        }
      } else {
        sortObj.id = "";
        sortObj.order = this.constants.SORT_DESC;
      }
      sortObj.titleAttr = _.str.trim((model && model.name) ? this.trimSortOptionName(model.name) :
                            "empty");
      sortObj.title = this.truncateCategoryName(sortObj.titleAttr);
      var titleVal = _.str.sformat(lang.sortByThis, this.formatColon(sortObj.titleAttr));
      this.$el.find('.csui-search-sort-options 	.binf-dropdown-toggle').attr('title', titleVal);
      this.selected.set(sortObj);
    },

    _updateSelection: function () {
      this.ui.selectedLabel.text(this.selected.get('title'));
    },

    _refreshSelection: function (model) {
      if (!!(model.collection && model.collection.inMetadataNavigationView)) {
        model.collection.isSortOptionSelected = true;
      }
      if (model.get('id') === this.selected.get('id')) {
        this._setSelection(model);
      }
    },

    resetCollection: function (filter, autoFetch) {
      this.collection.setOrder(filter, true);
    },

    sortPage: function (e) {
      e.preventDefault();
      e.stopPropagation();
      var orderBy = [];
      var idVal = $(e.currentTarget).attr('data-csui-sortoption-id');
      if (idVal !== undefined) {
        orderBy.push(idVal + " " + this.constants.SORT_DESC);
      } else {
        orderBy.push(this.constants.DEFAULT_SORT);
      }
      this.resetCollection(orderBy.join(), true);
    },

    _addDropdownItems: function (sorting, activeOption) {
      var jqUl = this.$el.find('.binf-dropdown-menu'),
        self = this;
      if (sorting[this.constants.DEFAULT_SORT]) {
        var name = self.trimSortOptionName(sorting[self.constants.DEFAULT_SORT].name);
        jqUl.append(
          '<li role="presentation"><a role="menuitemradio" aria-checked="false" href="#" class="csui-sort-option" data-binf-toggle="tab"><span class="cs-icon"></span><span class="cs-label" title="' +
           name + '">' + name + '</span></a></li>');
        delete sorting[self.constants.DEFAULT_SORT];
      }

      for (var sort in sorting) {
        if (sort.search("asc_") === 0) {
          delete sorting[sort];
        } else {
          var id2Use = sort.replace(/desc_/g, '');
          var titleAttr = self.trimSortOptionName(sorting[sort].name);
          titleAttr = self.formatColon(titleAttr);
          var sortOption = self.truncateCategoryName(titleAttr);
          if (activeOption.split(/_(.+)/, 2)[1] === sort.split(/_(.+)/, 2)[1]) {
            jqUl.append('<li role="presentation" class="binf-active"><a role="menuitemradio" aria-checked="true" data-csui-sortoption-id="' +
              id2Use +
              '" href="#" class="csui-sort-option" data-binf-toggle="tab"><span class="cs-icon icon-listview-checkmark"></span><span class="cs-label" title="' +
              titleAttr + '">' + sortOption + '</span></a></li>');
          } else {
            jqUl.append('<li role="presentation"><a role="menuitemradio" aria-checked="false" data-csui-sortoption-id="' +
              id2Use +
              '" href="#" class="csui-sort-option" data-binf-toggle="tab"><span class="cs-icon"></span><span class="cs-label" title="' +
              titleAttr + '">' + sortOption + '</span></a></li>');
          }
        }
      }
    },

    activate: function (element) {
      if (this.$el.find("li").hasClass("binf-active") === true) {
        this.$el.find("li").removeClass("binf-active");
        this.$el.find("li a.csui-sort-option").attr('aria-checked', 'false');
        this.$el.find("li .cs-icon").removeClass("icon-listview-checkmark");
      }
      $(element.parentElement).addClass("binf-active");
      $(element).find("a.csui-sort-option").attr('aria-checked', 'true');
      $(element).find("span.cs-icon").addClass("icon-listview-checkmark");
    },

    resetSelection: function (id, elem) {
      var sortObj = {};
      sortObj.id = id;
      sortObj.title = _.str.trim(elem.innerText);
      sortObj.titleAttr = _.str.trim(elem.title);
      sortObj.order = this.constants.SORT_DESC;
      this.selected.set(sortObj);
    },

    onSortOptionClick: function (event) {
      this.collection.isSortOptionSelected = true;
      event.preventDefault();
      event.stopPropagation();
      this.orderClicked = false;
      this.activate(event.currentTarget);
      var id2Use = $(event.currentTarget).attr('data-csui-sortoption-id');
      if (id2Use === undefined) {
        id2Use = "";
      }
      this.sortPage(event);
      this.ui.toggle.binf_dropdown('toggle');
      this.trigger("change:sortOrder");
    },

    onSortOrderClick: function (event) {
      this.collection.isSortOptionSelected = true;
      event.preventDefault();
      event.stopPropagation();
      this.orderClicked = true;
      var orderBy = [];
      if (this.ui.sortOrderBtn.hasClass("icon-sortArrowDown")) {
        this.ui.sortOrderBtn.removeClass("icon-sortArrowDown");
        this.ui.sortOrderBtn.addClass("icon-sortArrowUp");
        orderBy.push(this.selected.id + " " + this.constants.SORT_ASC);
      } else {
        this.ui.sortOrderBtn.removeClass("icon-sortArrowUp");
        this.ui.sortOrderBtn.addClass("icon-sortArrowDown");
        orderBy.push(this.selected.id + " " + this.constants.SORT_DESC);
      }
      this.collection.setOrder(orderBy.join(), true);
    },

    trimSortOptionName: function (name) {
      return name.replace(/\(([;\s\w\"\=\,\:\.\/\~\{\}\?\!\-\%\&\#\$\^\(\)]*?)\)/g, "");
    },

    //Removes string before first available(if exist) colon from name
    truncateCategoryName: function (name, truncateCategoryName) {
      return name.replace(/^[^:]*:\s*/,'');
    },

    //Adds a space behind colon(if exist) in column name
    formatColon: function (name) {
      return name.replace(/:([^\s])/, ': $1');
    }

  });

  return SearchSortingView;
});

// TODO: Deprecate this module and endorse the public one.
csui.define('csui/widgets/metadata/impl/metadata.forms',[
  'csui/widgets/metadata/metadata.forms'
], function (MetadataFormCollection) {
   return MetadataFormCollection;
});

csui.define('csui/widgets/metadata/impl/metadata.utils',["csui/lib/underscore", "csui/lib/jquery", "csui/lib/backbone", "csui/utils/url",
  "csui/widgets/metadata/impl/metadata.forms",
  'csui/models/appliedcategories/category.validation.model'
], function (_, $, Backbone, Url, MetadataFormCollection, CategoryValidationModel) {

  function MetadataUtils() {
  }

  _.extend(MetadataUtils.prototype, Backbone.Events, {

    //
    // Public: check the container for enforced required metadata
    // Parameters:
    // - <object> options: {action, id|addableType, container [,inheritance, enforcedRequiredAttrs]}
    // Return:
    // - jquery deferred that is always resolved with resp.hasRequiredMetadata = true/false
    //
    ContainerHasEnforcedEmptyRequiredMetadata: function (options) {
      var deferred = $.Deferred();
      var tempNode = new Backbone.Model({
        name: options.name,
        id: options.id,
        docParentId: options.docParentId,
        type: options.addableType
      });
      if (options.enforcedRequiredAttrs) {
        tempNode.options || (tempNode.options = {});
        tempNode.options.enforcedRequiredAttrs = true;
      }

      var allForms = new MetadataFormCollection(undefined, {
        node: tempNode,
        action: options.action,
        connector: options.container.connector,
        container: options.container,
        inheritance: options.inheritance,
        autofetch: true,
        autoreset: true
      });

      allForms.fetch()
          .done(_.bind(function () {
            if (allForms.models.length === 0) {
              deferred.resolve({hasRequiredMetadata: false});
            } else {
              var formsValid = this.FormsCollectionHasRequiredAttributes(allForms);
              deferred.resolve({hasRequiredMetadata: !formsValid, initialFormData: allForms});
            }
          }, this));

      return deferred.promise();
    },

    // Public: check the forms collection for required attributes
    // Parameters:
    // - <object> allForms: collection of all forms
    // Return:
    // - has required attributes: true/false
    FormsCollectionHasRequiredAttributes: function (allForms) {
      var formsValid = true;
      _.each(allForms.models, _.bind(function (form) {
        var valid = this._checkForAlpacaRequiredFields(form);
        formsValid = formsValid && valid;
      }, this));
      return formsValid;
    },

    jsonObjTraverse: function (jsonObj, stack, key, val, res, prop) {
      for (var property in jsonObj) {
        if (jsonObj.hasOwnProperty(property)) {
          if (jsonObj[key] !== undefined && jsonObj[key] === val && _.indexOf(res, prop) === -1) {
            res.push(prop);
          }
          if (typeof jsonObj[property] == "object") {
            this.jsonObjTraverse(jsonObj[property], stack + '.' + property, key, val, res,
                property);
          }
        }
      }
    },

    // private
    _checkForAlpacaRequiredFields: function (form) {
      var valid                = true,
          data                 = form.get('data'),
          options              = form.get('options'),
          schema               = form.get('schema'),
          reqArray             = [],
          reqFieldId           = [],
          nonValidateFieldsIds = [];

      // getting field id for Required Fields.
      this.jsonObjTraverse(schema, '', 'required', true, reqFieldId, 'properties');

      // getting field id for validate is false.
      this.jsonObjTraverse(options, '', 'validate', false, nonValidateFieldsIds, 'fields');

      // eliminating non validating fields from required field ids.
      var removeNonValidateFields = function (nvFields, rFields) {
        var rFields_ = rFields.filter(function (n) {
          return nvFields.indexOf(n) === -1;
        });
        return rFields_;
      };

      var filteredRequiredFieldsIds = removeNonValidateFields(nonValidateFieldsIds, reqFieldId),
          getReqArray               = function (jsonObj, stack, ele, res) {
            for (var property in jsonObj) {
              if (jsonObj.hasOwnProperty(property)) {
                if (property === ele) {
                  res.push(jsonObj[ele]);
                }
                if (typeof jsonObj[property] == "object") {
                  getReqArray(jsonObj[property], stack + '.' + property, ele, res);
                }
              }
            }
          };

      if (!!filteredRequiredFieldsIds) {
        var nullCount = false;
        _.each(filteredRequiredFieldsIds, function (arrayElement) {
          reqArray = [];
          getReqArray(data, '', arrayElement.toString(), reqArray);
          _.each(reqArray, function (arrayElement) {
            var checkNull = function (element) {
              if (element instanceof Array && (element !== null || element !== "")) {
                _.each(element, function (childElement) {
                  checkNull(childElement);
                });
              } else if (element === null || element === "") {
                nullCount = true;
                return;
              }
            };
            if (!nullCount) {
              checkNull(arrayElement);
            } else {
              valid = false;
              return;
            }
          });
          if (nullCount) {
            valid = false;
            return;
          }
        });
      }

      return valid;
    },

    //
    // Public: check the Alpaca options and schema for required field
    // Parameters:
    // - <object> options: Alpaca form's options
    // - <object> schema: Alpaca form's schema
    // Return:
    // - true/false
    //
    AlpacaFormOptionsSchemaHaveRequiredFields: function (formOptions, formSchema, metadataTab) {
      var required  = false,
          reqFields = [];
      if (!!metadataTab && metadataTab === 'general') { //for 'general' traverse all the properties.
        if (formSchema && formSchema.properties) {
          if (!!formSchema.properties.name) {
            formSchema.properties.name.required = false;
          }
          if (!!formSchema.properties.advanced_versioning) {
            formSchema.properties.advanced_versioning.required = false;
          }
          if (!!formSchema.properties.file) {
            formSchema.properties.file.required = false;
          }

          for (var key in formSchema.properties) {
            // required true, only when the current property is required and it's hidden is false.
            if (formSchema.properties.hasOwnProperty(key) && formSchema.properties[key].required &&
                !formOptions.fields[key].hidden) {
              required = true;
            }
          }
        }
      } else { // other than 'general' tab, search for required property.
        if (formSchema && required === false) {
          this.jsonObjTraverse(formSchema, '', 'required', true, reqFields, 'properties');
          if (reqFields.length > 0) {
            required = true;
          }
        }
      }
      return required;
    },

    //
    // Public: check the server to see if the nodes being performed by the action (copy/move, etc.)
    //         are enforced to fill in required metadata
    // Parameters:
    // - <object> options: {items, container}
    // Return:
    // - jquery deferred object containing following response when done:
    //   - response.requiredMetadata: true/false
    //   - response.enforcedItems: array of the node ids that are enforced to fill required metadata
    //
    ContainerHasEnforcedEmptyRequiredMetadataOnNodes: function (options) {
      if (!options.items || options.items.length < 1 || !options.container) {
        return $.Deferred().reject({});
      }

      var deferred  = $.Deferred(),
          ids       = _.map(options.items, function (item) { return item.id }),
          data      = {'ids': ids},
          connector = options.container.connector;

      var categoryValidationModel = new CategoryValidationModel({}, {connector: connector});
      categoryValidationModel.save(data, {
        type: 'POST',
        processData: false,
        contentType: false
      }).done(_.bind(function (resp) {
            if (options.inheritance === 'original') {
              deferred.resolve({requiredMetadata: false, enforcedItems: resp.results});
            } else {  // inheritance == 'destination' or 'merged'
              if (resp.results && resp.results.length > 0) {
                // only need to get the categories forms for just one item and check required fields
                var utilOptions = {
                  action: options.action,
                  id: resp.results[0].id,
                  inheritance: options.inheritance,
                  container: options.container,
                  enforcedRequiredAttrs: true
                };
                this.ContainerHasEnforcedEmptyRequiredMetadata(utilOptions)
                    .done(function (resp2) {
                      if (resp2.hasRequiredMetadata === true) {
                        deferred.resolve({requiredMetadata: true, enforcedItems: resp.results});
                      } else {
                        deferred.resolve({requiredMetadata: false, enforcedItems: resp.results});
                      }
                    })
                    .fail(function (error) {
                      deferred.reject(error);
                    });
              } else {
                deferred.resolve({requiredMetadata: false, enforcedItems: resp.results});
              }
            }
          }, this))
          .fail(function (error) {
            deferred.reject(error);
          });

      return deferred.promise();
    }

  });

  MetadataUtils.prototype.get = Backbone.Model.prototype.get;
  _.extend(MetadataUtils, {version: "1.0"});

  return MetadataUtils;
});

csui.define('csui/models/appliedcategories/category.action.server.adaptor.mixin',[
  'csui/lib/jquery', 'csui/lib/underscore', 'csui/utils/url', 'csui/models/version'
], function ($, _, Url, VersionModel) {
  'use strict';

  var ServerAdaptorMixin = {
    mixin: function (prototype) {
      return _.extend(prototype, {
        makeServerAdaptor: function (options) {
          return this;
        },

        url: function () {
          return Url.combine(this.node.urlBase(), this.options.urlResource);
        },

        parse: function () {
          // with document version, the is no categories/actions call but luckily everything is
          // read-ony in UX specs for this release of the UI
          if (this.node instanceof VersionModel) {
            return {};
          }
          // with add item, the object has not been created yet on the server
          if (this.node.get("id") === undefined || this.options.action) {
            return {categories_add: "dummy value"};
          }
          return this.constructor.__super__.parse.apply(this, arguments);
        }
      });
    }
  };


  return ServerAdaptorMixin;
});

csui.define('csui/models/appliedcategories/appliedcategoriesaction',['csui/lib/jquery', 'csui/lib/underscore', 'csui/lib/backbone', 'csui/utils/url',
  'csui/models/appliedcategories', 'csui/models/version',
  'csui/models/appliedcategories/category.action.server.adaptor.mixin'
], function ($, _, Backbone, Url, AppliedCategoryCollection, VersionModel, ServerAdaptorMixin) {
  'use strict';

  var AppliedCategoryActionsCollection = AppliedCategoryCollection.extend({

    constructor: function AppliedCategoryActionsCollection(attributes, options) {
      AppliedCategoryCollection.prototype.constructor.apply(this, arguments);
      this.options = options || {};
      _.defaults(this.options, {urlResource: ''});
    },

    fetch: function () {
      //
      // 1. with document version, the is no categories/actions call but luckily everything is
      // read-ony in UX specs for this release of the UI
      //
      // 2. with add item, the object has not been created yet on the server
      //
      if (this.node instanceof VersionModel ||
          this.node.get("id") === undefined || this.options.action) {
        this.fetching = false;
        this.fetched = true;
        return $.Deferred().resolve();
      }

      return AppliedCategoryCollection.prototype.fetch.apply(this, arguments);
    },

    isFetchable: function () {
      return this.node.isFetchableDirectly ? this.node.isFetchableDirectly() : false;
    }

  });
  ServerAdaptorMixin.mixin(AppliedCategoryActionsCollection.prototype);

  return AppliedCategoryActionsCollection;

});

csui.define('csui/temporary/cop/commands/defaultactionitems',[],function () {
  'use strict';

  return [
    // Blog, Blog Entry
    {
      equals: {type: [356, 357]},
      signature: 'OpenBlog',
      sequence: 30
    },
    {
      // FAQ, FAQ Entry
      equals: {type: [123475, 123476]},
      signature: 'OpenFAQ',
      sequence: 30
    },
    // Forum, Forum Topic
    {
      equals: {type: [123469, 123470]},
      signature: 'OpenForum',
      sequence: 30
    },
    // Wiki, Wiki Page
    {
      equals: {type: [5573, 5574]},
      signature: 'OpenWiki',
      sequence: 30
    },
    // MailStore
    {
      equals: {type: 3030331},
      signature: 'OpenMailStore',
      sequence: 30
    }
  ];

});

csui.define('csui/temporary/activeviews/commands/defaultactionitems',[],function () {
  'use strict';

  return [
    // ActiveView
    {
      equals: {type: 30309},
      signature: 'Disabled',
      sequence: 30
    }
  ];

});

csui.define('csui/temporary/appearances/commands/defaultactionitems',[],function () {
  'use strict';

  return [
    // Appearance
    {
      equals: {type: 480},
      signature: 'Disabled',
      sequence: 30
    }
  ];

});

csui.define('csui/utils/letter-avatar-random-color/letter-avatar-colors',['module'], function (module) {

    var config = {

        colors: ["#414979", "#2e3d98", "#4f3690", "#e00051", "#006353", "#007599", "#147bbc",
            "#a0006b", "#ba004C"]
    };

    var LetterAvatarColor = {

        getLetterAvatarColor: function (initials) {
            if (!initials) {
                return "";
            }
            var charIndex = 0,
                    colourIndex = 0,
                    initialsLen = initials.length;
            initials = initials.toUpperCase();
            for (var i = 0; i < initialsLen; i++) {
                charIndex += initials.charCodeAt(i);
            }
            colourIndex = parseInt(charIndex.toString().split('').pop());
            colourIndex = (colourIndex === 9) ? colourIndex - 1 : colourIndex;
            return config.colors[colourIndex];
        }
    };

    return LetterAvatarColor;

});

csui.define('csui/utils/user.avatar.color',['csui/lib/underscore',
    'csui/utils/letter-avatar-random-color/letter-avatar-colors'
], function (_, LetterAvatarColor) {

    var UserAvatarColor = {

        getUserAvatarColor: function (user) {
            if (!user || _.isEmpty(user)) {
                return "";
            }
            var initials = (user.initials && user.initials.length > 1) ? user.initials : (user.name ? user.name.substring(0, 2) : "");
            return LetterAvatarColor.getLetterAvatarColor(initials);
        }

    };
    return UserAvatarColor;
});

csui.define('csui/controls/node-type.icon/node-type.icon.item.view.mixin',[ 'csui/lib/underscore',
  'csui/lib/jquery',
  'csui/utils/user.avatar.color',
  'csui/utils/nodesprites',
  'csui/controls/node-type.icon/node-type.icon.view'
], function ( _, $,
  UserAvatarColor, nodeSpriteCollection, NodeTypeIconView) {

  var NodeTypeIconViewMixin = {
    mixin: function (prototype) {

      return _.extend(prototype, {

        makeNodeTypeIconItemView: function () {
          this.listenTo(this,"destroy",function(){
            if (this.nodeTypeIconView) {
              this.nodeTypeIconView.destroy();
            }
          });
        },

        /**
         * Render node type icon view and replace target element.
         *
         * @param {*} node with attributes, connector, imageAttribute and nameAttribute.
         * @param {*} targetElement ui element to replace with the node type icon view. (mandatory)
         * @param {*} iconClasses classes to attach to the icon element and for later identification. (optional)
         * @param {*} imageClasses classes to attach to the image element and for later identification. (optional)
         * @param {*} options additonal options. (optional)
         */
        renderNodeTypeIconView: function(node,targetElement,iconClasses,imageClasses,options) {
          var target = $(targetElement);
          targetElement = target[0] ? target : targetElement;
          iconClasses = iconClasses || "";
          imageClasses = imageClasses || "";
          options = options || {};
          var csuiInitials = (" "+iconClasses+" ").indexOf(" csui-initials ")>=0;
          var nodeTypeOptions = {
            node: node,
            nodeSprite: csuiInitials ? new nodeSpriteCollection.model({ className: iconClasses }) : options.nodeSprite,
            size: options.size
          };
          this.nodeTypeIconView && this.nodeTypeIconView.destroy();
          var nodeTypeIconView = this.nodeTypeIconView = new NodeTypeIconView(nodeTypeOptions);
          nodeTypeIconView.render();
          nodeTypeIconView.$el.removeAttr("title aria-label");
          nodeTypeIconView.$el.addClass(targetElement.attr("class"));
          if (csuiInitials) {
            var initials = node.attributes.initials;
            var backcolor;
            if (initials) {
              backcolor = UserAvatarColor.getUserAvatarColor(node.attributes);
            } else {
              var name = node.get(node.nameAttribute||'name')||'';
              var ii = name.trim().indexOf(' ');
              initials = ii>0 ? name[0]+name[ii+1] : name.substring(0,2);
              backcolor = UserAvatarColor.getUserAvatarColor({initials:initials});
            }
            nodeTypeIconView.ui.iconElement.text(initials);
            nodeTypeIconView.ui.iconElement.css("background", backcolor);
          }
          nodeTypeIconView.ui.iconElement.addClass(iconClasses);
          nodeTypeIconView.ui.imageElement.addClass(imageClasses);
          targetElement.replaceWith(nodeTypeIconView.el);
        }
      });
    }
  };

  return NodeTypeIconViewMixin;
});

csui.define('bundles/csui-view-support',[
  // 3rd-party libraries
  'csui/lib/ally',
  'csui/lib/bootstrap3-typeahead',
  'csui/lib/jquery.mousehover',
  'csui/lib/fancytree/jquery.fancytree',
  'csui/lib/fancytree/jquery.fancytree.filter',

  // Behaviors
  'csui/behaviors/collection.error/collection.error.behavior',
  'csui/behaviors/collection.state/collection.state.behavior',
  'csui/behaviors/collection.state/collection.state.view',

  //Controls
  'csui/controls/dialog/dialog.view',
  // TODO: Remove this private module, once zip & download stops their bad practice.
  'csui/controls/dialog/impl/header.view',
  // TODO: Remove this private module, once zip & download stops their bad practice.
  'csui/controls/dialog/footer.view',
  'csui/controls/facet.bar/facet.bar.view',
  'csui/controls/facet.panel/facet.panel.view',
  'csui/controls/list/behaviors/list.view.keyboard.behavior',
  'csui/controls/list/emptylist.view',
  'csui/controls/list/list.view',
  'csui/controls/list/list.state.view',
  'csui/controls/treebrowse/node.tree.view',
  // FIXME: Some controls like tile or nodelist require this file,
  // although it is private in list
  'css!csui/controls/list/impl/list',
  'csui/controls/list/simplelist.view',
  'csui/controls/list/simpletreelist.view',
  'csui/controls/listitem/inline.menu.view',
  'csui/controls/listitem/listitemobject.view',
  'csui/controls/listitem/listitemstandard.view',
  'csui/controls/listitem/listitemstateful.view',
  'csui/controls/listitem/simpletreelistitem.view',
  'csui/controls/table/cells/search/category/category.popover.list.view',
  'csui/controls/toolbar/toolbar.view',
  'csui/controls/toolbar/toolbar.command.controller',
  'csui/controls/toolbar/toolitem.model',
  'csui/controls/toolbar/toolitem.custom.view',
  'csui/controls/toolbar/toolitem.view',
  'csui/controls/toolbar/flyout.toolitem.view',
  'csui/controls/toolbar/toolitems.factory',
  'csui/controls/toolbar/toolitems.filtered.model',
  'csui/controls/toolbar/toolitems.mask',
  'csui/controls/toolbar/delayed.toolbar.view',
  'csui/controls/toolbar/toolbar.state.behavior',
  'hbs!csui/controls/toolbar/toolitem',
  'csui/controls/fileupload/impl/upload.controller',
  'csui/controls/checkbox/checkbox.view',
  'csui/controls/disclosure/disclosure.view',
  'i18n!csui/controls/listitem/impl/nls/lang',

  //Models
  'csui/models/appliedcategories',
  'csui/models/appliedcategory',
  'csui/models/fileupload',
  'csui/models/fileuploads',
  'csui/models/namequery',
  'csui/models/nodeversions',
  'csui/models/versions',
  'csui/models/facet',
  'csui/models/facets',
  'csui/models/facettopic',
  'csui/models/facettopics',
  'csui/models/node.facets/facet.query.mixin',
  'csui/models/node.facets2/facet.query.mixin',
  'csui/models/widget/search.results/search.facet.query.mixin',
  'csui/models/node/node.facet.factory',
  'csui/models/node/node.facet2.factory',
  'csui/models/nodefacets',
  'csui/models/nodefacets2',
  'csui/models/widget/search.results/search.results.model',
  'csui/models/permission/permission.table.columns.model',

  //Utilities
  // TODO: Make public modules out of these.
  'csui/utils/commands/impl/full.page.modal/full.page.modal.view',
  'csui/utils/thumbnail/thumbnail.object',
  'csui/utils/thumbnail/thumbnail.view',
  // Expiration warning handling
  'csui/utils/expiration.warning/expiration.warning.dialog',
  // TODO: Why is this module public?
  'json!csui/utils/commands/open.types.json',
  'csui/utils/commands/open.plugins/impl/core.open.plugins',
  'csui/utils/contexts/factories/search.results.factory',
  'csui/utils/high.contrast/detector',
  'csui/utils/impl/signin.dialog/signin.dialog',
  'csui/utils/toolitem.masks/global.toolitems.mask',

  //Form
  'css!csui/controls/form/impl/form',

  //widget components
  'csui/widgets/metadata/metadata.forms',
  'csui/widgets/search.results/controls/sorting/sort.menu.view',
  // TODO: Remove these private modules from here.
  'csui/widgets/metadata/impl/metadata.forms',
  'csui/widgets/metadata/impl/metadata.utils',
  'i18n!csui/widgets/metadata/impl/nls/lang',

  //Forms
  'csui/models/appliedcategoryform',
  'csui/models/appliedcategories/appliedcategoriesaction',
  'csui/models/form',
  'csui/models/forms',
  'csui/models/nodecreateforms',
  'csui/models/nodeforms',
  'csui/models/nodeupdateforms',

  // TODO: Remove this, as long as the module owners take over
  // the commands and default action rules
  'csui/temporary/cop/commands/defaultactionitems',
  'csui/temporary/activeviews/commands/defaultactionitems',
  'csui/temporary/appearances/commands/defaultactionitems',

  // Server Adaptors
  // TODO: Move them to the csui-server-adaptors bundle.
  'csui/models/node.facets/server.adaptor.mixin',
  'csui/models/node.facets2/server.adaptor.mixin',
  'csui/widgets/metadata/metadata.forms/server.adaptor.mixin',
  'csui/models/appliedcategories/server.adaptor.mixin',
  'csui/models/appliedcategories/category.action.server.adaptor.mixin',
  'csui/models/namequery/server.adaptor.mixin',

  // User Avatar Color
  'csui/utils/user.avatar.color',
  'csui/utils/letter-avatar-random-color/letter-avatar-colors',

  // View mixins
  'csui/controls/node-type.icon/node-type.icon.item.view.mixin'
], {});

csui.require(['require', 'css'], function (require, css) {
  css.styleLoad(require, 'csui/bundles/csui-view-support', true);
});

